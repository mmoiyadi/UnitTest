/*

Ext Scheduler 3.0.6
Copyright(c) 2009-2015 Bryntum AB
http://bryntum.com/contact
http://bryntum.com/license

*/
/**
@class Sch.locale.Locale

Base locale class. You need to subclass it, when creating new locales for Bryntum components. Usually subclasses of this class
will be singletones.

See <a href="#!/guide/gantt_scheduler_localization">Localization guide</a> for additional details.

*/
Ext.define('Sch.locale.Locale', {

    /**
     * @cfg {Object} l10n An object with the keys corresponding to class names and values are in turn objects with "phraseName/phraseTranslation"
     * key/values. For example:
     *
    l10n        : {
        'Sch.plugin.EventEditor' : {
            saveText: 'Speichern',
            deleteText: 'LÃ¶schen',
            cancelText: 'Abbrechen'
        },
        'Sch.plugin.CurrentTimeLine' : {
            tooltipText : 'Aktuelle Zeit'
        },

        ...
    }

     */
    l10n            : null,

    legacyMode      : true,

    localeName      : null,
    namespaceId     : null,


    constructor : function () {
        if (!Sch.locale.Active) {
            Sch.locale.Active = {};
            this.bindRequire();
        }

        var name            = this.self.getName().split('.');
        var localeName      = this.localeName = name.pop();
        this.namespaceId    = name.join('.');

        var currentLocale   = Sch.locale.Active[ this.namespaceId ];

        // let's localize all the classes that are loaded
        // except the cases when English locale is being applied over some non-english locale
        if (!(localeName == 'En' && currentLocale && currentLocale.localeName != 'En')) this.apply();
    },

    bindRequire : function () {
        // OVERRIDE
        // we need central hook to localize class once it's been created
        // to achieve it we override Ext.ClassManager.triggerCreated
        var _triggerCreated = Ext.ClassManager.triggerCreated;

        Ext.ClassManager.triggerCreated = function(className) {
            _triggerCreated.apply(this, arguments);

            if (className) {
                var cls     = Ext.ClassManager.get(className);
                // trying to apply locales for the loaded class
                for (var namespaceId in Sch.locale.Active) {
                    Sch.locale.Active[namespaceId].apply(cls);
                }
            }
        };
    },


    applyToClass : function (className, cls) {
        var me        = this,
            localeId  = me.self.getName();

        cls = cls || Ext.ClassManager.get(className);

        if (cls && (cls.activeLocaleId !== localeId)) {
            var locale = me.l10n[className];

            // if it's procedural localization - run provided callback
            if (typeof locale === 'function') {
                locale(className);

            // if it's a singleton - apply to it
            } else if (cls.singleton) {
                cls.l10n = Ext.apply({}, locale, cls.prototype && cls.prototype.l10n);

            // otherwise we override class
            } else {
                Ext.override(cls, { l10n : locale });
            }

            // if we support old locales approach let's duplicate locale to old places
            if (me.legacyMode) {
                var target;

                // we update either class prototype
                if (cls.prototype) {
                    target = cls.prototype;
                // or object itself in case of singleton
                } else if (cls.singleton) {
                    target = cls;
                }

                if (target && target.legacyMode) {

                    if (target.legacyHolderProp) {
                        if (!target[target.legacyHolderProp]) target[target.legacyHolderProp] = {};

                        target = target[target.legacyHolderProp];
                    }

                    for (var p in locale) {
                        if (typeof target[p] !== 'function') target[p] = locale[p];
                    }
                }
            }

            // keep applied locale
            cls.activeLocaleId  = localeId;

            // for singletons we can have some postprocessing
            if (cls.onLocalized) cls.onLocalized();
        }
    },


    /**
     * Apply this locale to classes.
     * @param {String[]/Object[]} [classNames] Array of class names (or classes themself) to localize.
     * If no classes specified then will localize all exisiting classes.
     */
    apply : function (classNames) {
        if (this.l10n) {
            var me = this;

            // if class name is specified
            if (classNames) {
                if (!Ext.isArray(classNames)) classNames = [classNames];

                var name, cls;
                for (var i = 0, l = classNames.length; i < l; i++) {
                    if (Ext.isObject(classNames[i])) {
                        if (classNames[i].singleton) {
                            cls     = classNames[i];
                            name    = Ext.getClassName(Ext.getClass(cls));
                        } else {
                            cls     = Ext.getClass(classNames[i]);
                            name    = Ext.getClassName(cls);
                        }
                    } else {
                        cls     = null;
                        name    = 'string' === typeof classNames[i] ? classNames[i] : Ext.getClassName(classNames[i]);
                    }

                    if (name && name in this.l10n) {
                        me.applyToClass(name, cls);
                    }
                }

            // localize all the classes that we know about
            } else {
                // update active locales
                Sch.locale.Active[this.namespaceId] = this;

                for (var className in this.l10n) {
                    me.applyToClass(className);
                }
            }
        }
    }
});

/**
 * English translations for the Scheduler component
 *
 * NOTE: To change locale for month/day names you have to use the corresponding Ext JS language file.
 */
Ext.define('Sch.locale.En', {
    extend      : 'Sch.locale.Locale',
    singleton   : true,

    constructor : function (config) {

        Ext.apply(this , {
            l10n        : {
                'Sch.util.Date' : {
                    unitNames : {
                        YEAR        : { single : 'year',    plural : 'years',   abbrev : 'yr' },
                        QUARTER     : { single : 'quarter', plural : 'quarters',abbrev : 'q' },
                        MONTH       : { single : 'month',   plural : 'months',  abbrev : 'mon' },
                        WEEK        : { single : 'week',    plural : 'weeks',   abbrev : 'w' },
                        DAY         : { single : 'day',     plural : 'days',    abbrev : 'd' },
                        HOUR        : { single : 'hour',    plural : 'hours',   abbrev : 'h' },
                        MINUTE      : { single : 'minute',  plural : 'minutes', abbrev : 'min' },
                        SECOND      : { single : 'second',  plural : 'seconds', abbrev : 's' },
                        MILLI       : { single : 'ms',      plural : 'ms',      abbrev : 'ms' }
                    }
                },

                'Sch.panel.TimelineGridPanel' : {
                    loadingText : 'Loading, please wait...',
                    savingText  : 'Saving changes, please wait...'
                },

                'Sch.panel.TimelineTreePanel' : {
                    loadingText : 'Loading, please wait...',
                    savingText  : 'Saving changes, please wait...'
                },

                'Sch.mixin.SchedulerView' : {
                    loadingText : 'Loading events...'
                },

                'Sch.plugin.CurrentTimeLine' : {
                    tooltipText : 'Current time'
                },

                'Sch.plugin.EventEditor' : {
                    saveText    : 'Save',
                    deleteText  : 'Delete',
                    cancelText  : 'Cancel'
                },

                'Sch.plugin.SimpleEditor' : {
                    newEventText    : 'New booking...'
                },

                'Sch.widget.ExportDialog' : {
                    generalError                : 'An error occured, try again.',
                    title                       : 'Export Settings',
                    formatFieldLabel            : 'Paper format',
                    orientationFieldLabel       : 'Orientation',
                    rangeFieldLabel             : 'Export range',
                    showHeaderLabel             : 'Add page number',
                    showFooterLabel             : 'Add footer',
                    orientationPortraitText     : 'Portrait',
                    orientationLandscapeText    : 'Landscape',
                    completeViewText            : 'Complete schedule',
                    currentViewText             : 'Current view',
                    dateRangeText               : 'Date range',
                    dateRangeFromText           : 'Export from',
                    pickerText                  : 'Resize column/rows to desired value',
                    dateRangeToText             : 'Export to',
                    exportButtonText            : 'Export',
                    cancelButtonText            : 'Cancel',
                    progressBarText             : 'Exporting...',
                    exportersFieldLabel         : 'Export mode',
                    adjustCols                  : 'Adjust column width',
                    adjustColsAndRows           : 'Adjust column width and row height',
                    specifyDateRange            : 'Specify date range'
                },

                'Sch.plugin.Export' : {
                    fetchingRows            : 'Fetching row {0} of {1}',
                    builtPage               : 'Built page {0} of {1}',
                    requestingPrintServer   : 'Please wait...'
                },

                'Sch.plugin.exporter.AbstractExporter' : {
                    name    : 'Exporter'
                },

                'Sch.plugin.exporter.SinglePage' : {
                    name    : 'Single page'
                },

                'Sch.plugin.exporter.MultiPageVertical' : {
                    name    : 'Multiple pages (vertically)'
                },

                'Sch.plugin.exporter.MultiPage' : {
                    name    : 'Multiple pages'
                },

                // -------------- View preset date formats/strings -------------------------------------
                'Sch.preset.Manager' : {
                    hourAndDay  : {
                        displayDateFormat   : 'G:i',
                        middleDateFormat    : 'G:i',
                        topDateFormat       : 'D d/m'
                    },

                    secondAndMinute : {
                        displayDateFormat   : 'g:i:s',
                        topDateFormat       : 'D, d g:iA'
                    },

                    dayAndWeek      : {
                        displayDateFormat   : 'm/d h:i A',
                        middleDateFormat    : 'D d M'
                    },

                    weekAndDay      : {
                        displayDateFormat   : 'm/d',
                        bottomDateFormat    : 'd M',
                        middleDateFormat    : 'Y F d'
                    },

                    weekAndMonth : {
                        displayDateFormat   : 'm/d/Y',
                        middleDateFormat    : 'm/d',
                        topDateFormat       : 'm/d/Y'
                    },

                    weekAndDayLetter : {
                        displayDateFormat   : 'm/d/Y',
                        middleDateFormat    : 'D d M Y'
                    },

                    weekDateAndMonth : {
                        displayDateFormat   : 'm/d/Y',
                        middleDateFormat    : 'd',
                        topDateFormat       : 'Y F'
                    },

                    monthAndYear : {
                        displayDateFormat   : 'm/d/Y',
                        middleDateFormat    : 'M Y',
                        topDateFormat       : 'Y'
                    },

                    year : {
                        displayDateFormat   : 'm/d/Y',
                        middleDateFormat    : 'Y'
                    },

                    manyYears : {
                        displayDateFormat   : 'm/d/Y',
                        middleDateFormat    : 'Y'
                    }
                }
            }
        });

        this.callParent(arguments);
    }
});

/**
 * @class Sch.util.Patch
 * @static
 * @private
 * Private utility class for Ext JS patches for the Bryntum components
 */
Ext.define('Sch.util.Patch', {
    /**
     * @cfg {String} target The class name to override
     */
    target      : null,

    /**
     * @cfg {String} minVersion The minimum Ext JS version for which this override is applicable. E.g. "4.0.5"
     */
    minVersion  : null,
    
    /**
     * @cfg {String} maxVersion The highest Ext JS version for which this override is applicable. E.g. "4.0.7"
     */
    maxVersion  : null,

    /**
     * @cfg {String} reportUrl A url to the forum post describing the bug/issue in greater detail
     */
    reportUrl   : null,
    
    /**
     * @cfg {String} description A brief description of why this override is required
     */
    description : null,
    
    /**
     * @cfg {Function} applyFn A function that will apply the patch(es) manually, instead of using 'overrides';
     */
    applyFn : null,

    /**
     * @cfg {Boolean} ieOnly true if patch is only applicable to IE
     */
    ieOnly : false,

    /**
     * @cfg {Boolean} macOnly true if patch is only applicable for Mac
     */
    macOnly : false,

    /**
     * @cfg {Object} overrides a custom object containing the methods to be overridden.
     */
    overrides : null,

    onClassExtended: function(cls, data) {
        
        if (Sch.disableOverrides) {
            return;
        }

        if (data.ieOnly && !Ext.isIE) {
            return;
        }

        if (data.macOnly && !Ext.isMac) {
            return;
        }

        if ((!data.minVersion || Ext.versions.extjs.equals(data.minVersion) || Ext.versions.extjs.isGreaterThan(data.minVersion)) &&
            (!data.maxVersion || Ext.versions.extjs.equals(data.maxVersion) || Ext.versions.extjs.isLessThan(data.maxVersion))) {
            if (data.applyFn) {
                // Custom override, implementor has full control
                data.applyFn();
            } else {
                // Simple case, just an Ext override
                Ext.ClassManager.get(data.target).override(data.overrides);
            }
        }
    }
});

if (!Ext.ClassManager.get("Sch.patches.BufferedRenderer")) {

    Ext.define('Sch.patches.BufferedRenderer', {
        extend : 'Sch.util.Patch',

        requires : ['Ext.grid.plugin.BufferedRenderer'],
        target   : 'Ext.grid.plugin.BufferedRenderer',

        overrides : {
            // Patch to solve this issue: http://www.sencha.com/forum/showthread.php?294996
            // remove when fixed
            onRangeFetched : function () {
                this.tableTopBorderWidth = this.tableTopBorderWidth || 0;

                return this.callParent(arguments);
            },

            refreshSize : function (e, t) {

                var me = this,
                    view = me.view;

                if (view.body.dom) {
                    this.callParent(arguments);
                }
            }
        }
    });
}

// IE8 doesn't have indexOf() on native array
// http://www.sencha.com/forum/showthread.php?292336-5.0.1-IE8-treepanel-broken-after-editing
if (!Ext.ClassManager.get("Sch.patches.NodeStore")) Ext.define('Sch.patches.NodeStore', {
    extend          : 'Sch.util.Patch',

    requires        : ['Ext.data.NodeStore'],

    target          : 'Ext.data.NodeStore',
    ieOnly          : true,
    maxVersion      : '5.1.1',
    overrides      : {

        afterEdit       : function (record, modifiedFields) {

            if (this.getNode() && modifiedFields) {
                if (Ext.Array.indexOf(modifiedFields, 'loaded') !== -1) {
                    return this.add(this.retrieveChildNodes(record));
                }
                if (Ext.Array.indexOf(modifiedFields, 'expanded') !== -1) {
                    return this.filter();
                }
                if (Ext.Array.indexOf(modifiedFields, 'sorted') !== -1) {
                    return this.sort();
                }
            }

            //
            Ext.data.Store.prototype.afterEdit.apply(this, arguments);
        }
    }

});

//@PATCH to fix https://www.assembla.com/spaces/bryntum/tickets/869#/activity/ticket
// When resizing columns with fixed locked grid width, columns become smaller due to the default Ext header resizing logic
Ext.define('Sch.patches.ColumnResizeTree', {
    override      : 'Sch.panel.TimelineTreePanel',

    afterRender : function() {
        this.callParent(arguments);

        var resizer = this.lockedGrid.headerCt.findPlugin('gridheaderresizer');

        if (resizer) {
            // Implementation from Ext 4.2.0
            resizer.getConstrainRegion = function() {
                var me       = this,
                    dragHdEl = me.dragHd.el,
                    nextHd;



                if (me.headerCt.forceFit) {
                    nextHd = me.dragHd.nextNode('gridcolumn:not([hidden]):not([isGroupHeader])');
                    if (!me.headerInSameGrid(nextHd)) {
                        nextHd = null;
                    }
                }

                return me.adjustConstrainRegion(
                    Ext.util.Region.getRegion(dragHdEl),
                    0,
                    me.headerCt.forceFit ? (nextHd ? nextHd.getWidth() - me.minColWidth : 0) : me.maxColWidth - dragHdEl.getWidth(),
                    0,
                    me.minColWidth
                );
            };
        }
    }
});

if (!Ext.ClassManager.get("Sch.patches.RowSynchronizer")) {
    Ext.define('Sch.patches.RowSynchronizer', {
        extend : 'Sch.util.Patch',

        requires : ['Ext.grid.locking.RowSynchronizer'],

        target     : 'Ext.grid.locking.RowSynchronizer',
        minVersion : '5.1.0',

        overrides : Ext.versions.extjs.isGreaterThan('5.1.0') ? {

            finish : function (other) {
                if (!other) return;

                return this.callParent(arguments);
            }
        } : {}
    });
}

// http://www.sencha.com/forum/showthread.php?295795-Crash-when-adding-new-record-to-tree-with-locked-cols&p=1079983#post1079983
//
if (!Ext.ClassManager.get("Sch.patches.NodeCache")) {

    Ext.define('Sch.patches.NodeCache', {
        extend : 'Sch.util.Patch',

        requires   : ['Ext.view.NodeCache'],
        target     : 'Ext.view.NodeCache',
        minVersion : '5.1.0',

        overrides : {
            scroll : function (newRecords, direction, removeCount) {
                var res;

                if (newRecords.length === 0) {
                    res = [];
                } else {
                    res = this.callParent(arguments);
                }

                return res;
            }
        }
    });
}

//http://www.sencha.com/forum/showthread.php?296703-iOS-devices-Crash-in-TouchScroller&p=1083470#post1083470
Ext.define('Sch.patches.TouchScroll', {
    extend   : 'Sch.util.Patch',

    requires   : ['Ext.scroll.TouchScroller'],
    target     : 'Ext.scroll.TouchScroller',
    
    minVersion : '5.1.0',

    overrides  : {
        privates : {
            onEvent: function(e) {
                var me = this;

                if (!me[me.listenerMap[e.type]]) return;

                return this.callParent(arguments);
            }
        }
    }
});
//https://www.sencha.com/forum/showthread.php?299097-5.1.0-Chrome-Mac-Scrolling-stutters-in-locked-grid
Ext.define('Sch.patches.PartnerScroll', {
    extend   : 'Sch.util.Patch',

    requires   : ['Ext.scroll.Scroller'],

    minVersion : '5.1.0',

    maxVersion : '5.1.1',

    applyFn : function () {
        // https://www.assembla.com/spaces/bryntum/tickets/2114
        // This patch fixes not only scroll in mac but also in FF for Ext 5.1.0
        // Also in Ext 5.1.1 same issue is not reproducible for FF
        if (Ext.isMac || Ext.isGecko) {
            Ext.ClassManager.get('Ext.scroll.Scroller').override({

                constructor: function (config) {
                    var me = this;

                    me.callParent([config]);

                    this.doNotCall = {};
                },

                privates: {

                    onPartnerScrollEnd: function () {
                        this.doNotCall = {};
                    },

                    invokePartners: function (method, x, y) {
                        var partners = this._partners,
                            partner,
                            id;

                        if (!this.suspendSync) {
                            for (id in partners) {
                                partner = partners[id];
                                //do not bounce back
                                if (!partner.suspendSync && !this.doNotCall[partner.scroller.id]) {
                                    partner.scroller[method](this, x, y);
                                }
                                else {
                                    //needed to sync columnlines
                                    if (!partner.scroller.component.isTableView) {
                                        delete this.doNotCall[partner.scroller.id];
                                    }
                                }
                            }
                        }
                    },

                    onPartnerScroll: function (partner, x, y) {

                        var axis = partner._partners[this.getId()].axis;

                        if (axis) {
                            if (axis === 'x') {
                                y = null;
                            } else if (axis === 'y') {
                                x = null;
                            }
                        }

                        //do not bounce back on partner
                        this.doNotCall[partner.id] = true;

                        this.doScrollTo(x, y, null, false);

                    }
                }
            });
        }
    }
});

//http://www.sencha.com/forum/showthread.php?295892-Ext-JS-5.1-Post-GA-Patches&p=1080371&viewfull=1#post1080371
Ext.define('Sch.patches.View', {
    extend : 'Sch.util.Patch',

    requires   : ['Ext.view.View'],
    target     : 'Ext.view.View',
    minVersion : '5.1.0',

    overrides : {
        handleEvent: function(e) {
            var me = this,
                isKeyEvent = me.keyEventRe.test(e.type),
                nm = me.getNavigationModel();

            e.view = me;

            if (isKeyEvent) {
                e.item = nm.getItem();
                e.record = nm.getRecord();
            }

            // If the key event was fired programatically, it will not have triggered the focus
            // so the NavigationModel will not have this information.
            if (!e.item) {
                e.item = e.getTarget(me.itemSelector);
            }
            if (e.item && !e.record) {
                e.record = me.getRecord(e.item);
            }

            if (me.processUIEvent(e) !== false) {
                me.processSpecialEvent(e);
            }

            // We need to prevent default action on navigation keys
            // that can cause View element scroll unless the event is from an input field.
            // We MUST prevent browser's default action on SPACE which is to focus the event's target element.
            // Focusing causes the browser to attempt to scroll the element into view.

            if (isKeyEvent && !Ext.fly(e.target).isInputField()) {
                if (e.getKey() === e.SPACE || e.isNavKeyPress(true)) {
                    e.preventDefault();
                }
            }
        }
    }
});

Ext.define('Sch.patches.TableView', {
    extend : 'Sch.util.Patch',

    requires   : ['Ext.view.Table'],
    target     : 'Ext.view.Table',
    minVersion : '5.1.0',

    overrides : {
        //https://www.sencha.com/forum/showthread.php?301110-Last-focused-item-is-not-synced-which-causes-scroll-jump
        getLastFocused : function () {
            var result = this.callParent(arguments);

            return result || this.navigationModel.lastFocused;
        }
    }
});

//http://www.sencha.com/forum/showthread.php?295892-Ext-JS-5.1-Post-GA-Patches&p=1080371&viewfull=1#post1080371
Ext.define('Sch.patches.Collection', {
    extend : 'Sch.util.Patch',

    requires   : ['Ext.util.Collection'],
    target     : 'Ext.util.Collection',
    minVersion : '5.1.0',

    overrides : {

        updateKey: function (item, oldKey) {
            var me = this,
                map = me.map,
                indices = me.indices,
                source = me.getSource(),
                newKey;

            if (source && !source.updating) {
                // If we are being told of the key change and the source has the same idea
                // on keying the item, push the change down instead.
                source.updateKey(item, oldKey);
            }
            // If there *is* an existing item by the oldKey and the key yielded by the new item is different from the oldKey...
            else if (map[oldKey] && (newKey = me.getKey(item)) !== oldKey) {
                if (oldKey in map || map[newKey] !== item) {
                    if (oldKey in map) {

                        delete map[oldKey];
                    }

                    // We need to mark ourselves as updating so that observing collections
                    // don't reflect the updateKey back to us (see above check) but this is
                    // not really a normal update cycle so we don't call begin/endUpdate.
                    me.updating++;

                    me.generation++;
                    map[newKey] = item;
                    if (indices) {
                        indices[newKey] = indices[oldKey];
                        delete indices[oldKey];
                    }

                    me.notify('updatekey', [{
                        item: item,
                        newKey: newKey,
                        oldKey: oldKey
                    }]);

                    me.updating--;
                }
            }
        }
    }
});
// TreeStore doesn't support rejectChanges very well
// https://www.sencha.com/forum/showthread.php?300339-rejectChanges-doesn-t-work-for-TreeStore-added-removed-records&p=1097116#post1097116
if (!Ext.ClassManager.get("Sch.patches.TreeStore")) {

    Ext.define('Sch.patches.TreeStore', {
        extend          : 'Sch.util.Patch',

        requires        : ['Ext.data.TreeStore'],

        target          : 'Ext.data.TreeStore',
        minVersion      : '5.1.0',
        overrides      : {

            getRejectRecords : function () {
                return this.getModifiedRecords();
            },

            rejectChanges : function () {
                this.removed = this.removedNodes;
                this.callParent(arguments);
            },

            remove : function (node) {
                if (node.isModel) {

                    node.remove();

                } else if (node instanceof Array && node[0].isModel) {

                    for (var i = 0; i < node.length; i++) node[i].remove();

                } else {
                    this.callParent(arguments);
                }
            }
        }

    });

}
// byInternalIdMap is removed from 5.1.1 and it is widely used in projection mechanism
Ext.define('Sch.patches.TreeStoreInternalIdMap', {
    extend      : 'Sch.util.Patch',

    requires    : ['Ext.data.TreeStore'],
    target      : 'Ext.data.TreeStore',

    minVersion  : '5.1.1',

    overrides   : {
        registerNode: function(node, includeChildren) {
            var me = this;

            if (!me.byInternalIdMap) {
                me.byInternalIdMap = {};
            }

            me.byInternalIdMap[node.internalId] = node;

            me.callParent(arguments);
        },

        unregisterNode: function(node, includeChildren) {
            var me = this;

            if (me.byInternalIdMap) {
                delete me.byInternalIdMap[node.internalId];
            }

            me.callParent(arguments);
        },

        updateRoot: function () {
            this.byInternalIdMap = {};

            this.callParent(arguments);
        }
    }
});
// https://www.sencha.com/forum/showthread.php?301258-Tooltip-should-not-ignore-mouseover-event-on-touch-devices
Ext.define('Sch.patches.ToolTip', {
    extend  : 'Sch.util.Patch',
    
    requires   : ['Ext.tip.ToolTip'],
    target     : 'Ext.tip.ToolTip',
    
    minVersion : '5.1.0',
    
    overrides : {
        setTarget: function(target) {
            var me = this,
                t = Ext.get(target),
                tg;
    
            if (me.target) {
                tg = Ext.get(me.target);
                me.mun(tg, {
                    mouseover: me.onTargetOver,
                    tap: me.onTargetOver,
                    mouseout: me.onTargetOut,
                    mousemove: me.onMouseMove,
                    scope: me
                });
            }
    
            me.target = t;
            if (t) {
                me.mon(t, {
                    mouseover: me.onTargetOver,
                    tap: me.onTargetOver,
                    mouseout: me.onTargetOut,
                    mousemove: me.onMouseMove,
                    scope: me
                });
            }
            if (me.anchor) {
                me.anchorTarget = me.target;
            }
        }
    }
});
Ext.define('Sch.patches.OperationDestroy', {
    extend      : 'Sch.util.Patch',

    requires    : ['Ext.data.operation.Destroy'],
    target      : 'Ext.data.operation.Destroy',

    minVersion  : '5.1.1',

    maxVersion  : '5.1.2',

    overrides   : {
        doProcess   : function () {
            // clientRecords record size gets down on each clientRecords[i].setErased() call
            // so we make a copy by slicing this.getRecords()
            var clientRecords = Ext.Array.slice(this.getRecords()),
                clientLen = clientRecords.length,
                i;
            for (i = 0; i < clientLen; ++i) {
                clientRecords[i].setErased();
            }
        }
    }
});
// fixes issue fix fields layout in Chrome43
Ext.define('Sch.patches.Chrome', {

    extend      : 'Sch.util.Patch',

    requires    : ['Ext.util.CSS'],

    minVersion  : '5.1.0',

    applyFn : function () {
        if (Ext.isChrome && Ext.browser.version.isGreaterThanOrEqual('43')) {
            Ext.util.CSS.createStyleSheet('.sch-timelinepanel .' + Ext.baseCSSPrefix + 'form-text { display: inherit; }');
        }
    }

});
/**
@class Sch.mixin.Localizable

A mixin providing localization functionality to the consuming class.

    Ext.define('My.Toolbar', {
        extend      : 'Ext.Toolbar',
        mixins      : [ 'Sch.mixin.Localizable' ],

        initComponent   : function () {
            Ext.apply(this, {
                items   : [
                    {
                        xtype       : 'button',

                        // get the button label from the current locale
                        text        : this.L('loginText')
                    }
                ]
            });

            this.callParent(arguments);
        }
    });

*/
Ext.define('Sch.mixin.Localizable', {

    // This line used to be like this:
    //      if Sch.config.locale is specified then we'll require corresponding class
    //      by default we require Sch.locale.En class
//          requires            : [ typeof Sch != 'undefined' && Sch.config && Sch.config.locale || 'Sch.locale.En' ],
    //
    // But, SenchaCMD does not support dynamic expressions for `requires`
    // Falling back to requiring English locale - that will cause English locale to always be included in the build
    // (even if user has specified another locale in other `requires`), but thats better than requiring users
    // to always specify and load the locale they need explicitly
    requires            : [ 'Sch.locale.En' ],

    legacyMode          : false,

    activeLocaleId      : '',

    /**
     * @cfg {Object} l10n Container of locales for the class.
     */
    l10n                : null,

    isLocaleApplied     : function () {
        var activeLocaleId = (this.singleton && this.activeLocaleId) || this.self.activeLocaleId;

        if (!activeLocaleId) return false;

        for (var ns in Sch.locale.Active) {
            if (activeLocaleId === Sch.locale.Active[ns].self.getName()) return true;
        }

        return false;
    },

    applyLocale         : function () {
        // loop over activated locale classes and call apply() method of each one
        for (var ns in Sch.locale.Active) {
            Sch.locale.Active[ns].apply(this.singleton ? this : this.self.getName());
        }
    },

    /**
     * This is shorthand reference to {@link #localize}. Retrieves translation of a phrase.
     * @param {String} id Identifier of phrase.
     * @param {String} [legacyHolderProp=this.legacyHolderProp] Legacy class property name containing locales.
     * @param {Boolean} [skipLocalizedCheck=false] Do not localize class if it's not localized yet.
     * @return {String} Translation of specified phrase.
     */
    L                   : function () {
        return this.localize.apply(this, arguments);
    },

    /**
     * Retrieves translation of a phrase. There is a shorthand {@link #L} for this method.
     * @param {String} id Identifier of phrase.
     * @param {String} [legacyHolderProp=this.legacyHolderProp] Legacy class property name containing locales.
     * @param {Boolean} [skipLocalizedCheck=false] Do not localize class if it's not localized yet.
     * @return {String} Translation of specified phrase.
     */
    localize            : function (id, legacyHolderProp, skipLocalizedCheck) {
        // if not localized yet let's do it
        if (!this.isLocaleApplied() && !skipLocalizedCheck) {
            this.applyLocale();
        }

        // `l10n` instance property has highest priority
        if (this.hasOwnProperty('l10n') && this.l10n.hasOwnProperty(id) && 'function' != typeof this.l10n[id]) return this.l10n[id];

        var clsProto    = this.self && this.self.prototype;

        // if there were old properties for localization on this class
        if (this.legacyMode) {
            // if they were kept under some property
            var prop        = legacyHolderProp || this.legacyHolderProp;

            // check object instance first
            var instHolder  = prop ? this[prop] : this;
            if (instHolder && instHolder.hasOwnProperty(id) && 'function' != typeof instHolder[id]) return instHolder[id];

            if (clsProto) {
                // then let's check class definition
                var clsHolder = prop ? clsProto[prop] : clsProto;
                if (clsHolder && clsHolder.hasOwnProperty(id) && 'function' != typeof clsHolder[id]) return clsHolder[id];
            }
        }

        // let's try to get locale from class prototype `l10n` property
        var result      = clsProto.l10n && clsProto.l10n[id];

        // if no transalation found
        if (result === null || result === undefined) {

            var superClass  = clsProto && clsProto.superclass;
            // if parent class also has localize() method
            if (superClass && superClass.localize) {
                // try to get phrase translation from parent class
                result = superClass.localize(id, legacyHolderProp, skipLocalizedCheck);
            }

            if (result === null || result === undefined) throw 'Cannot find locale: '+id+' ['+this.self.getName()+']';
        }

        return result;
    }
});

/**
 * @class Sch.tooltip.ClockTemplate
 * @extends Ext.XTemplate
 * @private
 * A template showing a clock. It accepts an object containing a 'date' and a 'text' property to its apply method.
 * @constructor
 * @param {Object} config The object containing the configuration of this model.
 **/
Ext.define("Sch.tooltip.ClockTemplate", {
    extend : 'Ext.XTemplate',

    minuteHeight : 8,
    minuteTop    : 2,
    hourHeight   : 8,
    hourTop      : 2,
    handLeft     : 10,

    getRotateStyle : function (degrees) {
        return "transform:rotate(Ddeg);-ms-transform:rotate(Ddeg);-moz-transform: rotate(Ddeg);-webkit-transform: rotate(Ddeg);-o-transform:rotate(Ddeg);".replace(/D/g, degrees);
    },

    getRotateStyleIE : (function () {
        var toRad = Math.PI / 180,
            cos = Math.cos,
            sin = Math.sin;

        return function (degrees, top, height) {
            var me = this,
                rad = degrees * toRad,
                cosV = cos(rad),
                sinV = sin(rad),
                y = height * sin((90 - degrees) * toRad),
                x = height * cos((90 - degrees) * toRad),
                topAdjust = Math.min(height, height - y),
                leftAdjust = degrees > 180 ? x : 0,
                matrixString = "progid:DXImageTransform.Microsoft.Matrix(sizingMethod='auto expand', M11 = " + cosV + ", M12 = " + (-sinV) + ", M21 = " + sinV + ", M22 = " + cosV + ")";

            return Ext.String.format("filter:{0};-ms-filter:{0};top:{1}px;left:{2}px;", matrixString, topAdjust + top, leftAdjust + me.handLeft);
        };
    })(),

    constructor : function () {
        var isLegacyIE = Ext.isIE && Ext.isIE8m;

        this.callParent([
            '<div class="sch-clockwrap ' + (isLegacyIE ? '' : 'sch-supports-border-radius') + ' {cls}">' +
                '<div class="sch-clock">' +
                    '<div class="sch-hourIndicator" style="{[this.getHourStyle((values.date.getHours() % 12) * 30,' + this.hourTop + ', + ' + this.hourHeight + ')]}">{[Ext.Date.monthNames[values.date.getMonth()].substr(0,3)]}</div>' +
                    '<div class="sch-minuteIndicator" style="{[this.getMinuteStyle(values.date.getMinutes() * 6,' + this.minuteTop + ', + ' + this.minuteHeight + ')]}">{[values.date.getDate()]}</div>' +
                    (isLegacyIE ? '' : '<div class="sch-clock-dot"></div>') +
                '</div>' +
                '<span class="sch-clock-text">{text}</span>' +
            '</div>',
            {
                disableFormats : true,

                getMinuteStyle : isLegacyIE ? this.getRotateStyleIE : this.getRotateStyle,
                getHourStyle   : isLegacyIE ? this.getRotateStyleIE : this.getRotateStyle
            }
        ]);
    }
})
;

/**
 @class Sch.tooltip.Tooltip
 @extends Ext.ToolTip
 @private

 Internal plugin showing a tooltip with event start/end information.
 */
Ext.define("Sch.tooltip.Tooltip", {
    extend : "Ext.tip.ToolTip",

    requires : [
        'Sch.tooltip.ClockTemplate'
    ],

    autoHide          : false,
    anchor            : 'b',
    padding           : '0 3 0 0',
    showDelay         : 0,
    hideDelay         : 0,
    quickShowInterval : 0,
    dismissDelay      : 0,
    trackMouse        : false,
    anchorOffset      : 5,
    shadow            : false,
    frame             : false,

    schedulerView     : null,
    message           : null,
    valid             : true,
    offsetAdjust      : [18, 5],

    constructor : function (config) {
        var clockTpl = new Sch.tooltip.ClockTemplate();

        this.startDate = this.endDate = new Date();

        if (!this.template) {
            this.template = Ext.create("Ext.XTemplate",
                '<div class="sch-tip-{[values.valid ? "ok" : "notok"]}">' +
                '{[this.renderClock(values.startDate, values.startText, "sch-tooltip-startdate")]}' +
                '{[this.renderClock(values.endDate, values.endText, "sch-tooltip-enddate")]}' +
                '<div class="sch-tip-message">{message}</div>' +
                '</div>',
                {
                    disableFormats : true,

                    renderClock : function (date, text, cls) {
                        return clockTpl.apply({
                            date : date,
                            text : text,
                            cls  : cls
                        });
                    }
                }
            );
        }

        this.callParent(arguments);
    },

    // set redraw to true if you want to force redraw of the tip
    // required to update drag tip after scroll
    update      : function (startDate, endDate, valid, message) {

        if (this.startDate - startDate !== 0 ||
            this.endDate - endDate !== 0 ||
            this.valid !== valid ||
            this.message !== message) {

            // Readjust position if message is removed or appears
            var realignNeeded = (this.message && !message) || (!this.message && message);

            // This will be called a lot so cache the values
            this.startDate = startDate;
            this.endDate = endDate;
            this.valid = valid;
            this.message = message;

            var startText = this.schedulerView.getFormattedDate(startDate),
                endText = this.schedulerView.getFormattedEndDate(endDate, startDate);

            // If resolution is day or greater, and end date is greater then start date
            if (this.mode === 'calendar' && endDate.getHours() === 0 && endDate.getMinutes() === 0 && !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) {
                endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
            }

            this.callParent([
                this.template.apply({
                    valid     : valid,
                    startDate : startDate,
                    endDate   : endDate,
                    startText : startText,
                    endText   : endText,
                    message   : message
                })
            ]);

            if (realignNeeded) {
                this.realign();
            }
        }
    },

    show : function (el, xOffset) {
        // Ext internal tooltip code may call this method with an Array, ignore it
        if (!el || Ext.isArray(el)) {
            return;
        }

        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
            this.mode = 'calendar';

            this.addCls('sch-day-resolution');
            this.removeCls('sch-hour-resolution');
        } else {
            this.mode = 'clock';

            this.removeCls('sch-day-resolution');
            this.addCls('sch-hour-resolution');
        }

        // xOffset has to have default value
        // when it's 18 tip is aligned to left border
        xOffset = arguments.length > 1 ? xOffset : this.offsetAdjust[0];

        this.mouseOffsets = [xOffset - this.offsetAdjust[0], -this.offsetAdjust[1]];

        this.setTarget(el);
        this.callParent();

        this.realign();
    },

    realign : function () {
        this.el.alignTo(this.target, 'bl-tl', this.mouseOffsets);
    },

    afterRender : function () {
        this.callParent(arguments);

        // In slower browsers, the mouse pointer may end up over the tooltip interfering with drag drop etc
        this.el.on('mouseenter', this.realign, this);
    }
});

/**
 * @class Sch.tooltip.HoverTip
 * HoverTip is a class that represents a tooltip with clock and time which updates as the mouse pointer moves over the schedule area.
 */
Ext.define('Sch.tooltip.HoverTip', {
    extend          : 'Ext.tip.ToolTip',
    
    alias           : 'widget.scheduler_hovertip',
    
    requires        : [
        'Sch.tooltip.ClockTemplate'
    ],
    
    trackMouse      : true,
    
    bodyCls         : 'sch-hovertip',
    
    messageTpl      : '<div class="sch-hovertip-msg">{message}</div>',
    
    autoHide        : false,
    
    dismissDelay    : 1000,
    
    showDelay       : 300,
    
    /**
     * @cfg {Sch.mixin.SchedulerView} schedulerView View instance to bind this tooltip to
     * @required
     */
    schedulerView   : null,
    
    initComponent   : function () {
        var me = this;
        
        var view = me.schedulerView;
        
        me.clockTpl = new Sch.tooltip.ClockTemplate();
        
        me.messageTpl = new Ext.XTemplate(me.messageTpl);
        
        me.lastTime = null;
        
        me.lastResource = null;
        
        me.callParent(arguments);
        
        me.on('beforeshow', me.tipOnBeforeShow, me);
        
        view.mon(view.el, {
            mouseleave : function () {
                me.hide();
            },
            mousemove  : me.handleMouseMove,
            scope      : me
        });
    },
    
    handleMouseMove       : function (e) {
        var me      = this;
        
        var view    = me.schedulerView;
        
        if (me.disabled) {
            return;
        }

        if (e.getTarget('.' + view.timeCellCls, 5) && !e.getTarget(view.eventSelector)) {
            var time = view.getDateFromDomEvent(e, 'floor');

            if (time) {
                var resourceRecord = view.resolveResource(e.getTarget());
                
                if (time - me.lastTime !== 0 || resourceRecord !== me.lastResource) {
                    me.lastResource = resourceRecord;
                    
                    me.updateHoverTip(time, e);

                    if (me.hidden) { // HACK, find better solution
                        if (Sch.util.Date.compareUnits(this.schedulerView.getTimeResolution().unit, Sch.util.Date.DAY) >= 0) {
                            me.addCls('sch-day-resolution');
                            me.removeCls('sch-hour-resolution');
                        } else {
                            me.removeCls('sch-day-resolution');
                            me.addCls('sch-hour-resolution');
                        }
                        me.show();
                    }
                }
            } else {
                me.hide();
                me.lastTime = null;
                me.lastResource = null;
            }
        } else {
            me.hide();
            me.lastTime = null;
            me.lastResource = null;
        }
    },
    
    /**
     * Override this to render custom text to default hover tip
     * @param {Date} date
     * @param {Ext.EventObject} e Browser event
     * @return {String}
     */
    getText : function () {},

    // private
    updateHoverTip    : function (date, e) {
        if (date) {
            var clockHtml = this.clockTpl.apply({ 
                date : date,
                text : this.schedulerView.getFormattedDate(date)
            });
            
            var messageHtml = this.messageTpl.apply({
                message : this.getText(date, e)
            });
            
            this.update(clockHtml + messageHtml);
            
            this.lastTime = date;
        }
    },
    
    tipOnBeforeShow : function (tip) {
        return !this.disabled && this.lastTime !== null;
    }
});

/**
 @class Sch.crud.AbstractManager
 @abstract

 This is an abstract class serving as the base for the Sch.data.CrudManager class.
 It implements basic mechanisms to organize batch communication with a server.
 Yet it does not contain methods related to _data transfer_ nor _encoding_.
 These methods are to be provided in sub-classes by consuming the appropriate mixins.

 For example, this is how the class can be used to implement an XML encoding system:

        // let's make new CrudManager using AJAX as a transport system and XML for encoding
        Ext.define('MyCrudManager', {
            extend  : 'Sch.crud.AbstractManager',

            mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
        });

 Data transfer and encoding methods
 ======================================

 Here are the methods that must be provided by subclasses of this class:

 - {@link #sendRequest}
 - {@link #cancelRequest}
 - {@link #encode}
 - {@link #decode}

 */
Ext.define('Sch.crud.AbstractManager', {

    require                 : [
        'Ext.data.StoreManager'
    ],

    mixins                  : {
        observable          : 'Ext.util.Observable'
    },

    /**
     * @property {Integer} revision
     * @readonly
     * The server revision stamp.
     * The _revision stamp_ is a number which should be incremented after each server-side change.
     * This property reflects the current version of the data retrieved from the server and gets updated after each {@link #load} and {@link #sync} call.
     */
    revision                : null,

    /**
     * @property {Object[]} stores
     * A list of registered stores whose server communication will be collected into a single batch.
     * Each store is represented by a _store descriptor_, an object having following structure:
     * @property {String} stores.storeId Unique store identifier.
     * @property {Ext.data.AbstractStore} stores.store Store itself.
     * @property {String} [stores.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
     * @property {String} [stores.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */

    /**
     * @cfg {Ext.data.AbstractStore[]/String[]/Object[]} stores
     * Sets the list of stores controlled by the CRUD manager.
     * Store can be provided by itself, its storeId or an object having the following structure:
     * @cfg {String} stores.storeId Unique store identifier. Under this name the store related requests/responses will be sent.
     * @cfg {Ext.data.AbstractStore} stores.store The store itself.
     * @cfg {String} [stores.phantomIdField] Set this if the store model has a predefined field to keep phantom record identifier.
     * @cfg {String} [stores.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */
    stores                  : null,

    /**
     * @cfg {String} storeIdProperty Name of a store property to retrieve store identifiers from.
     * Store identifier is used as a container name holding corresponding store data while transferring them to/from the server.
     * By default `storeId` property is used. And in case a container identifier has to differ this config can be used:
     *
     *     Ext.define('CatStore', {
     *         model            : 'Cat',
     *         // storeId is "meow" but for sending/receiving store data
     *         // we want have "cats" container in JSON, so we create a new property "stoireIdForCrud"
     *         storeId          : 'meow',
     *         stoireIdForCrud  : 'cats',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('MyCrudManager', {
     *         ...
     *         stores           : ['meow'],
     *         // crud manager will get store identifier from "stoireIdForCrud" property
     *         storeIdProperty  : 'stoireIdForCrud'
     *     });
     *
     * The `storeIdProperty` property can also be specified directly on a store:
     *
     *     Ext.define('CatStore', {
     *         model            : 'Cat',
     *         // storeId is "meow" but for sending/receiving store data
     *         // we want have "cats" container in JSON
     *         storeId          : 'meow',
     *         // so we create a new property "stoireIdForCrud"..
     *         stoireIdForCrud  : 'cats',
     *         // and point CrudManager to use it as the store identifier source
     *         storeIdProperty  : 'stoireIdForCrud',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('DogStore', {
     *         model            : 'MyModel',
     *         // storeId is "dogs" and it will be used as a container name for the store data
     *         storeId          : 'dogs',
     *         proxy            : 'memory'
     *     });
     *
     *     Ext.define('MyCrudManager', {
     *         ...
     *         stores           : ['meow', 'dogs']
     *     });
     *
     */
    storeIdProperty         : 'storeId',

    storesIndex             : null,
    activeRequests          : null,
    delayedSyncs            : null,

    /**
     * @method sendRequest
     * @abstract
     * Sends request to the server.
     * @param {Object} request The request to send. An object having following properties:
     * @param {String} request.data {@link #encode Encoded} request.
     * @param {String} request.type Request type, can be either `load` or `sync`
     * @param {Function} request.success Callback to be started on successful request transferring
     * @param {Function} request.failure Callback to be started on request transfer failure
     * @param {Object} request.scope A scope for the above `success` and `failure` callbacks
     * @return {Object} The request descriptor.
     */

    /**
     * @method cancelRequest
     * @abstract
     * Cancels request to the server.
     * @param {Object} request The request to cancel (a value returned by corresponding {@link #sendRequest} call).
     */

    /**
     * @method encode
     * @abstract
     * Encodes request to the server.
     * @param {Object} request The request to encode.
     * @returns {String} The encoded request.
     */

    /**
     * @method decode
     * @abstract
     * Decodes response from the server.
     * @param {String} response The response to decode.
     * @returns {Object} The decoded response.
     */

    transport               : null,

    /**
     * When `true` forces the CRUD manager to process responses depending on their `type` attribute.
     * So `load` request may be responded with `sync` response for example.
     * Can be used for smart server logic allowing to decide if a client needs a complete data reloading (`load` response)
     * or it's enough to provide delta (`sync` response).
     * @cfg {Boolean} trackResponseType
     */
    trackResponseType       : false,

    /**
     * @cfg {String} phantomIdField
     * Field name to be used to transfer a phantom record identifier.
     */
    phantomIdField          : '$PhantomId',

    /**
     * @cfg {Boolean} autoLoad
     * `true` to automatically call {@link #load} method after creation.
     */
    autoLoad                : false,

    /**
     * @cfg {Integer} autoSyncTimeout
     * The timeout in milliseconds to wait before persisting changes to the server.
     * Used when {@link #autoSync} is set to `true`.
     */
    autoSyncTimeout         : 100,
    /**
     * @cfg {Boolean} autoSync
     * `true` to automatically persist stores changes after every edit to any of stores records.
     * Please note that sync request will not be invoked immediately but only after {@link #autoSyncTimeout} interval.
     */
    autoSync                : false,

    /**
     * @cfg {Boolean} resetIdsBeforeSync
     * `True` to reset identifiers (defined by `idProperty` config) of phantom records before submitting them to the server.
     */
    resetIdsBeforeSync      : true,

    /**
     * @property {Object[]} syncApplySequence
     * An array of stores presenting an alternative sync responses apply order.
     * Each store is represented by a _store descriptor_, an object having following structure:
     * @property {String} syncApplySequence.storeId Unique store identifier.
     * @property {Ext.data.Store/Ext.data.TreeStore} syncApplySequence.store Store itself.
     * @property {String} [syncApplySequence.phantomIdField] Set this if store model has a predefined field to keep phantom record identifier.
     * @property {String} [syncApplySequence.idProperty] id field name, if it's not specified then class will try to get it from a store model.
     */

    /**
     * @cfg {String[]} syncApplySequence
     * An array of store identifiers sets an alternative sync responses apply order.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But in case of some tricky dependencies between stores this order can be changed:

            Ext.create('MyCrudManager', {
                // register stores (they will be loaded in the same order: 'store1' then 'store2' and finally 'store3')
                stores : ['store1', 'store2', 'store3'],
                // but we apply changes from server to them in an opposite order
                syncApplySequence : ['store3', 'store2', 'store1']
            });

     */
    syncApplySequence       : null,

    /**
     * @cfg {Boolean} writeAllFields true to write all fields from the record to the server.
     * If set to false it will only send the fields that were modified.
     * Note that any fields that have Ext.data.field.Field.persist set to false will still be
     * ignored while those with Ext.data.field.Field.critical set to true will be included.
     */
    writeAllFields          : false,

    ignoreUpdates           : 0,

    createMissingRecords    : false,
    autoSyncTimerId         : null,


    constructor : function (config) {

        config = config || {};

        this.mixins.observable.constructor.call(this, config);

        this.activeRequests     = {};
        this.delayedSyncs       = [];
        this.transport          = config.transport || this.transport || {};

        // support stores defined in the class prototype as well
        var stores              = config.stores || this.stores;
        this.stores             = [];
        this.addStore(stores);

        var syncApplySequence   = config.syncApplySequence || this.syncApplySequence;
        if (syncApplySequence) {
            // reset this.syncApplySequence since addStoreToApplySequence() will build it
            this.syncApplySequence  = null;
            this.addStoreToApplySequence(syncApplySequence);
        }

        if (this.autoLoad) this.load();
    },


    updateStoreIndex : function () {
        var storesIndex = {};

        for (var i = 0, l = this.stores.length; i < l; i++) {
            var store   = this.stores[i];
            if (store.storeId) {
                storesIndex[store.storeId] = this.stores[i];
            }
        }

        this.storesIndex = storesIndex;
    },

    /**
     * Returns a registered store descriptor.
     * @param {String/Ext.data.AbstractStore} storeId The store identifier or registered store instance.
     * @returns {Object} The descriptor of the store.
     * Store descriptor is an object having following structure:
     *
     *  - `storeId` The store identifier that will be used as a key in requests.
     *  - `store` The store itself.
     *  - `idProperty` The idProperty of the store.
     *  - `phantomIdField` The field holding unique Ids of phantom records (if store has such model).
     */
    getStoreDescriptor : function (storeId) {
        if (!storeId) return;

        if (storeId instanceof Ext.data.AbstractStore) {
            for (var i = 0, l = this.stores.length; i < l; i++) {
                if (this.stores[i].store === storeId) return this.stores[i];
            }

        } else if (typeof storeId == 'object') {
            return this.storesIndex[storeId.storeId];

        } else {
            return this.storesIndex[storeId] || this.getStoreDescriptor(Ext.data.StoreManager.get(storeId));
        }
    },

    /**
     * Returns a registered store.
     * @param {String} storeId Store identifier.
     * @returns {Ext.data.AbstractStore} Found store instance.
     */
    getStore : function (storeId) {
        var storeInfo = this.getStoreDescriptor(storeId);
        return storeInfo && storeInfo.store;
    },

    forEachStore : function (fn, scope) {
        if (!fn) return;

        var stores  = this.stores;

        for (var i = 0, l = stores.length; i < l; i++) {
            if (fn.call(scope || this, stores[i].store, stores[i].storeId, stores[i]) === false) break;
        }
    },


    /**
     * Adds a store to the collection.

    // append stores to the end of collection
    crudManager.addStore([
        store1,
        // storeId
        'bar',
        // store descriptor
        {
            storeId : 'foo',
            store   : store3
        },
        {
            storeId         : 'bar',
            store           : store4,
            // to write all fields of modified records
            writeAllFields  : true
        }
    ]);

     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     * @param {Ext.data.AbstractStore/String/Object/Ext.data.AbstractStore[]/String[]/Object[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * The _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Ext.data.AbstractStore} store.store The store itself.
     * @param {String} [store.idProperty] The idProperty of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).
     * @param {Boolean} [store.writeAllFields] Set to true to write all fields from modified records
     * @param {Integer} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.

        // insert stores store4, store5 to the start of collection
        crudManager.addStore([ store4, store5 ], 0);

     * @param {String/Ext.data.AbstractStore/Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or descriptor (the result of {@link #getStoreDescriptor} call).

        // insert store6 just before a store having storeId equal to 'foo'
        crudManager.addStore(store6, 0, 'foo');

        // insert store7 just after store3 store
        crudManager.addStore(store7, 1, store3);

     */
    addStore : function (store, position, fromStore) {
        if (!store) return;

        if (!Ext.isArray(store)) store = [store];

        var data    = [];

        // loop over list of stores to be added
        for (var i = 0, l = store.length; i < l; i++) {
            var storeInfo   = store[i];

            // if store instance provided
            if (storeInfo instanceof Ext.data.AbstractStore) {
                storeInfo  = { store : storeInfo };

            } else if (typeof storeInfo == 'object') {
                // normalize sub-stores (if any)
                if (storeInfo.stores) {
                    if (!Ext.isArray(storeInfo.stores)) storeInfo.stores = [storeInfo.stores];

                    for (var j = 0, n = storeInfo.stores.length; j < n; j++) {
                        var subStore        = storeInfo.stores[j],
                            subStoreInfo    = subStore;

                        if ('string' === typeof subStore) {
                            subStoreInfo  = { storeId : subStore };
                        }

                        // keep reference to the "master" store descriptor
                        subStoreInfo.masterStoreInfo = storeInfo;

                        storeInfo.stores[j] = subStoreInfo;
                    }
                }

            // if it's a store identifier
            } else {
                storeInfo  = { store : Ext.data.StoreManager.get(storeInfo) };
            }

            data.push( this.fillStoreDescriptor(storeInfo) );

            storeInfo.store.crudManager = this;

            // listen to stores' changes
            this.mon(storeInfo.store, {
                add     : this.onStoreChange,
                append  : this.onStoreChange,
                insert  : this.onStoreChange,
                update  : this.onStoreUpdate,
                remove  : this.onStoreChange,
                clear   : this.onStoreChange,
                scope   : this
            });
        }

        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {

            this.stores.push.apply(this.stores, data);

        // if position specified
        } else {
            var pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore instanceof Ext.data.AbstractStore || typeof fromStore !== 'object') fromStore = this.getStoreDescriptor(fromStore);
                // get its position
                pos += Ext.Array.indexOf(this.stores, fromStore);
            }
            // insert new store(-s)
            this.stores.splice.apply(this.stores, [].concat([pos, 0], data));
        }

        this.updateStoreIndex();
    },


    fillStoreDescriptor : function (descriptor) {
        var store           = descriptor.store,
            storeIdProperty = store.storeIdProperty || this.storeIdProperty,
            model           = store.getModel && store.getModel() || store.model;

        model   = model && model.prototype;

        Ext.applyIf(descriptor, {
            storeId         : store[storeIdProperty],
            phantomIdField  : model && model.phantomIdField,
            idProperty      : model && model.idProperty,
            writeAllFields  : store.writeAllFields
        });

        return descriptor;
    },


    /**
     * Removes a store from collection. If the store was registered in alternative sync sequence list
     * it will be removed from there as well.

    // remove store having storeId equal to "foo"
    crudManager.removeStore("foo");

    // remove store3
    crudManager.removeStore(store3);

     * @param {Object/String/Ext.data.AbstractStore} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStore : function (store) {
        for (var i = 0, l = this.stores.length; i < l; i++) {
            var s   = this.stores[i];
            if (s === store || s.store === store || s.storeId === store) {

                // un-listen to store changes
                this.mun(s.store, {
                    add     : this.onStoreChange,
                    append  : this.onStoreChange,
                    insert  : this.onStoreChange,
                    update  : this.onStoreUpdate,
                    remove  : this.onStoreChange,
                    clear   : this.onStoreChange,
                    scope   : this
                });

                delete this.storesIndex[s.storeId];
                this.stores.splice(i, 1);
                if (this.syncApplySequence) {
                    this.removeStoreFromApplySequence(store);
                }

                break;
            }
        }
    },

    /**
     * Adds a store to the alternative sync responses apply sequence.
     * By default the order in which sync responses are applied to the stores is the same as they registered in.
     * But this order can be changes either on construction step using {@link #syncApplySequence} option
     * or but calling this method.
     *
     * **Please note**, that if the sequence was not initialized before this method call then
     * you will have to do it yourself like this for example:

        // alternative sequence was not set for this crud manager
        // so let's fill it with existing stores keeping the same order
        crudManager.addStoreToApplySequence(crudManager.stores);

        // and now we can add our new store

        // we will load its data last
        crudManager.addStore(someNewStore);
        // but changes to it will be applied first
        crudManager.addStoreToApplySequence(someNewStore, 0);

     * add registered stores to the sequence along with the store(s) you want to add
     *
     * @param {Ext.data.AbstractStore/Object/Ext.data.AbstractStore[]/Object[]} store The store to add or its _descriptor_ (or array of stores or descriptors).
     * Where _store descriptor_ is an object having following properties:
     * @param {String} store.storeId The store identifier that will be used as a key in requests.
     * @param {Ext.data.AbstractStore} store.store The store itself.
     * @param {String} [store.idProperty] The idProperty of the store. If not specified will be taken from the store model.
     * @param {String} [store.phantomIdField] The field holding unique Ids of phantom records (if store has such model).

     * @param {Integer} [position] The relative position of the store. If `fromStore` is specified the this position will be taken relative to it.
     * If not specified then store(s) will be appended to the end of collection.
     * Otherwise it will be just a position in stores collection.

        // insert stores store4, store5 to the start of sequence
        crudManager.addStoreToApplySequence([ store4, store5 ], 0);

     * @param {String/Ext.data.AbstractStore/Object} [fromStore] The store relative to which position should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of {@link #getStoreDescriptor} call).

        // insert store6 just before a store having storeId equal to 'foo'
        crudManager.addStoreToApplySequence(store6, 0, 'foo');

        // insert store7 just after store3 store
        crudManager.addStoreToApplySequence(store7, 1, store3);

     */
    addStoreToApplySequence : function (store, position, fromStore) {
        if (!store) return;

        if (!Ext.isArray(store)) store = [store];

        var data = [];
        // loop over list of stores to add
        for (var i = 0, l = store.length; i < l; i++) {
            var s   = this.getStoreDescriptor(store[i]);
            if (s) data.push(s);
        }

        if (!this.syncApplySequence) this.syncApplySequence = [];

        // if no position specified then append stores to the end
        if (typeof position === 'undefined') {
            this.syncApplySequence.push.apply(this.syncApplySequence, data);

        // if position specified
        } else {
            var pos = position;
            // if specified the store relative to which we should insert new one(-s)
            if (fromStore) {
                if (fromStore instanceof Ext.data.AbstractStore || typeof fromStore !== 'object') fromStore = this.getStoreDescriptor(fromStore);
                // get its position
                pos += Ext.Array.indexOf(this.syncApplySequence, fromStore);
            }
            // insert new store(-s)
            this.syncApplySequence.splice.apply(this.syncApplySequence, [].concat([pos, 0], data));
        }
    },


    /**
     * Removes a store from the alternative sync sequence.

    // remove store having storeId equal to "foo"
    crudManager.removeStore("foo");

    // remove store3
    crudManager.removeStore(store3);

     * @param {Object/String/Ext.data.AbstractStore} store The store to remove. Either the store descriptor, store identifier or store itself.
     */
    removeStoreFromApplySequence : function (store) {
        for (var i = 0, l = this.syncApplySequence.length; i < l; i++) {
            var s   = this.syncApplySequence[i];
            if (s === store || s.store === store || s.storeId === store) {
                this.syncApplySequence.splice(i, 1);
                break;
            }
        }
    },


    onStoreUpdate : function (store, record) {
        if (!store.isTreeStore || record !== store.getRoot()) {
            this.onStoreChange();
        }
    },


    onStoreChange : function () {
        if (this.ignoreUpdates) return;

        var me  = this;

        /**
         * @event haschanges
         * Fires when some of registered stores records gets changed.

        crudManager.on('haschanges', function (crud) {
            // enable persist changes button when some store gets changed
            saveButton.enable();
        });

         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         */

        this.fireEvent(this.hasChanges() ? 'haschanges' : 'nochanges', this);

        if (this.autoSync) {
            // add deferred call if it's not scheduled yet
            if (!this.autoSyncTimerId) {
                this.autoSyncTimerId    = setTimeout(function() {
                    me.autoSyncTimerId  = null;
                    me.sync();
                }, this.autoSyncTimeout);
            }
        }
    },

    /**
     * Returns `true` if any of registered stores (or some particular store) has non persisted changes.

    // if we have any unsaved changes
    if (crudManager.hasChanges()) {
        // persist them
        crudManager.sync();
    // otherwise
    } else {
        alert("There are no unsaved changes...");
    }

     * @param {String/Ext.data.AbstractStore} [storeId] The store identifier or store instance to check changes for.
     * If not specified then will check changes for all of the registered stores.
     * @returns {Boolean} `true` if there are not persisted changes.
     */
    hasChanges : function (storeId) {
        var store;

        if (storeId) {
            store   = this.getStore(storeId);
            if (!store) return;

            return Boolean(store.getModifiedRecords().length || store.getRemovedRecords().length);
        }

        for (var i = 0, l = this.stores.length; i < l; i++) {
            store   = this.stores[i].store;
            if (store.getModifiedRecords().length || store.getRemovedRecords().length) return true;
        }

        return false;
    },


    getLoadPackage : function (options) {
        var pack    = {
            type        : 'load',
            requestId   : this.getRequestId(),
            stores      : []
        };

        var stores      = this.stores,
            packStores  = pack.stores;

        for (var i = 0, l = stores.length; i < l; i++) {

            var store       = stores[i],
                opts        = options && options[store.storeId],
                pageSize    = store.pageSize || store.store.pageSize;

            if (opts || pageSize) {

                var params  = Ext.apply({
                    storeId     : store.storeId,
                    page        : 1,
                    pageSize    : pageSize
                }, opts);

                stores[i].currentPage   = params.page;

                packStores.push(params);

            } else {

                packStores.push(store.storeId);

            }
        }

        return pack;
    },

    prepareAdded : function (list, phantomIdField, stores) {
        var result  = [];

        for (var i = 0, l = list.length; i < l; i++) {
            var record  = list[i],
                data    = {},
                fields  = record.getFields();

            if (!data.hasOwnProperty(phantomIdField)) {
                data[phantomIdField]    = record.getId();
            }

            for (var f = 0, fLen = fields.length; f < fLen; f++) {
                var field   = fields[f];

                if (field) {
                    if (field.persist && (record.data.hasOwnProperty(field.name) || field.critical)) {
                        if (field.serialize) {
                            data[field.name]    = field.serialize(record.data[field.name], record);
                        } else {
                            data[field.name]    = record.data[field.name];
                        }
                    }
                }
            }

            if (this.resetIdsBeforeSync) delete data[record.idProperty];

            // if the store has embedded ones
            if (stores) {
                this.processSubStores(record, data, stores);
            }

            result.push(data);
        }

        return result;
    },

    prepareUpdated : function (list, stores, storeInfo) {
        var result          = [],
            writeAllFields  = storeInfo.writeAllFields || (storeInfo.writeAllFields !== false && this.writeAllFields),
            data, field;

        for (var i = 0, l = list.length; i < l; i++) {
            var record      = list[i],
                f;

            if (writeAllFields) {
                //write all fields
                data        = record.getData();
                data[record.idProperty] = record.getId();

                for (f in data) {
                    field   = record.getField(f);

                    // remove not persistable/critical fields
                    if (!field || !field.persist && !field.critical) {
                        delete data[f];
                    } else if (field.serialize) {
                        data[f]    = field.serialize(data[f], record);
                    } else {
                        data[f]    = record.get(f);
                    }
                }
            } else {
                data        = record.getChanges();
                data[record.idProperty] = record.getId();

                // process fields to get rid of non-persistable ones
                // and use "serialize" when it's presented
                for (f in data) {
                    field   = record.getField(f);

                    if (!field || !field.persist) {
                        delete data[f];
                    } else if (field.serialize) {
                        data[f]    = field.serialize(data[f], record);
                    } else {
                        data[f]    = record.get(f);
                    }
                }

                // critical fields should always be presented
                var criticalFields  = record.getCriticalFields();

                for (var j = 0; j < criticalFields.length; j++) {
                    field   = criticalFields[j];

                    if (field.serialize) {
                        data[field.getName()] = field.serialize(record.get(field.getName()), record);
                    } else {
                        data[field.getName()] = record.get(field.getName());
                    }
                }
            }

            // if the store has embedded ones
            if (stores) {
                this.processSubStores(record, data, stores);
            }

            result.push(data);
        }

        return result;
    },

    prepareRemoved : function (list) {
        var result  = [], data;

        for (var i = 0, l = list.length; i < l; i++) {
            data    = {};
            data[list[i].idProperty] = list[i].getId();

            result.push(data);
        }

        return result;
    },

    processSubStores : function (record, data, stores) {
        for (var j = 0, n = stores.length; j < n; j++) {
            var id      = stores[j].storeId,
                store   = record.get(id);
            // if embedded store is assigned to the record
            if (store) {
                // let's collect its changes as well
                var changes     = this.getStoreChanges(Ext.apply({ store : store }, stores[j]));

                if (changes) {
                    data[id]    = Ext.apply(changes, { $store : true });
                } else {
                    delete data[id];
                }
            } else {
                delete data[id];
            }
        }
    },

    getStoreChanges : function (store, phantomIdField) {

        phantomIdField  = phantomIdField || store.phantomIdField || this.phantomIdField;

        var s           = store.store,
            added       = s.getNewRecords(),
            updated     = s.getUpdatedRecords(),
            removed     = s.getRemovedRecords(),
            // sub-stores
            stores      = store.stores;

        var result;

        if (added.length) added       = this.prepareAdded(added, phantomIdField, stores);
        if (updated.length) updated   = this.prepareUpdated(updated, stores, store);
        if (removed.length) removed   = this.prepareRemoved(removed);

        // if this store has changes
        if (added.length || updated.length || removed.length) {

            result  = {};

            if (added.length) result.added       = added;
            if (updated.length) result.updated   = updated;
            if (removed.length) result.removed   = removed;
        }

        return result;
    },


    getChangeSetPackage : function () {
        var pack    = {
            type        : 'sync',
            requestId   : this.getRequestId(),
            revision    : this.revision
        };

        var stores  = this.stores,
            found   = 0;

        for (var i = 0, l = stores.length; i < l; i++) {
            var store           = stores[i],
                phantomIdField  = store.phantomIdField || this.phantomIdField,
                storeId         = store.storeId;

            var changes = this.getStoreChanges(store, phantomIdField);
            if (changes) {
                found++;

                pack[storeId]   = changes;
            }
        }

        return found ? pack : null;
    },


    getSubStoresData : function (rows, subStores, idProperty, isTree) {
        if (!rows) return;

        var result = [];

        var processRow  = function (row, subStores) {
            for (var j = 0, m = subStores.length; j < m; j++) {
                var storeId = subStores[j].storeId;
                // if row contains data for this sub-store
                if (row[storeId]) {
                    // keep them for the later loading
                    result.push({
                        id          : row[idProperty],
                        storeDesc   : subStores[j],
                        data        : row[storeId]
                    });
                    // and remove reference from the row
                    delete row[storeId];
                }
            }
        };

        var i = 0, l = rows.length;

        // if it's a TreeStore
        if (isTree) {
            // loop over nodes
            for (; i < l; i++) {
                processRow(rows[i], subStores);

                // also let's grab sub-stores from node children
                var childrenSubData = this.getSubStoresData(rows[i].children, subStores, idProperty, true);
                if (childrenSubData) {
                    result  = result.concat(childrenSubData);
                }
            }
        // if it's a "flat" store
        } else {
            for (; i < l; i++) processRow(rows[i], subStores);
        }

        return result;
    },


    loadDataToStore : function (storeDesc, data) {
        var store       = storeDesc.store,
            // nested stores list
            subStores   = storeDesc.stores,
            idProperty  = storeDesc.idProperty || 'id',
            isTree      = store instanceof Ext.data.TreeStore,
            subData;

        var rows        = data && data.rows;

        // apply server provided meta data to the store
        store.metaData  = data && data.metaData;

        if (rows) {
            if (subStores) subData  = this.getSubStoresData(rows, subStores, idProperty, isTree);

            store.__loading         = true;

            if (isTree) {
                store.proxy.data    = rows;
                store.load();
            } else {
                store.totalCount    = data.total;
                store.currentPage   = storeDesc.currentPage;
                store.loadData(rows);

                store.fireEvent('load', store, store.getRange(), true);
            }

            if (subData) {
                // load sub-stores as well (if we have them)
                for (var i = 0, l = subData.length; i < l; i++) {
                    var subDatum  = subData[i];

                    this.loadDataToStore(
                        Ext.apply({
                            store   : store[isTree ? 'getNodeById' : 'getById'](subDatum.id).get(subDatum.storeDesc.storeId)
                        }, subDatum.storeDesc),
                        subDatum.data
                    );
                }
            }

            store.__loading         = false;
        }
    },


    loadData : function (response) {
        // we load data to the stores in the order they're kept in this.stores array
        for (var i = 0, l = this.stores.length; i < l; i++) {
            var storeDesc   = this.stores[i],
                data        = response[storeDesc.storeId];

            if (data) this.loadDataToStore(storeDesc, data);
        }
    },


    applyChangesToRecord : function (record, changes, stores) {
        var fields      = record.fields,
            data        = record.data,
            done        = {},
            editStarted = false,
            name;


        // if this store has sub-stores assigned to some fields
        if (stores) {
            // then first we apply changes to that stores
            for (var j = 0, n = stores.length; j < n; j++) {
                name    = stores[j].storeId;

                if (changes.hasOwnProperty(name)) {
                    // remember that we processed this field
                    done[name]  = true;
                    var store   = record.get(name);

                    if (store) {
                        this.applyChangesToStore(Ext.apply({ store : store }, stores[j]), changes[name]);
                    } else {
                        Ext.log("Can't find store for the response sub-package");
                    }
                }
            }
        }

        // here we apply all the `changes` properties to the record
        // since in ExtJS 5 for some reason `fields` is not populated with items enumerated in store.fields config
        //for (var i = 0, l = fields.length; i < l; i++) {
        //    name    = fields[i].getName();
        for (name in changes) {

            if (changes.hasOwnProperty(name) && !done[name]) {
                var value   = changes[name];

                if (!record.isEqual(data[name], value)) {
                    // we call beginEdit/endEdit only if real changes were applied
                    if (!editStarted) {
                        editStarted     = true;
                        record.beginEdit();
                    }
                    // for the record ID we will use setId() call
                    if (name === record.idProperty) {
                        record.setId(value);
                    } else {
                        record.set(name, value);
                    }
                }
            }
        }

        this.ignoreUpdates++;

        // we call beginEdit/endEdit only if real changes were applied
        if (editStarted) record.endEdit();

        this.ignoreUpdates--;

        record.commit();
    },

    applyRemovals : function (store, removed, context) {

        var idProperty      = context.idProperty,
            removedStash    = store.getRemovedRecords(),
            findByIdFn      = context.findByIdFn,
            removeRecordFn  = context.removeRecordFn,
            applied         = 0;

        for (var j = 0, k = removed.length; j < k; j++) {
            var done    = false;
            var id      = removed[j][idProperty];

            // just find the record in store.removed array and delete it from there
            for (var jj = 0, kk = removedStash.length; jj < kk; jj++) {
                if (removedStash[jj].getId() == id) {
                    removedStash.splice(jj, 1);
                    done    = true;
                    // number of removals applied
                    applied++;
                    break;
                }
            }

            // if responded removed record isn`t found in store.removed
            // probably don't removed on the client side yet (server driven removal)
            if (!done) {
                var record  = findByIdFn(id);

                if (record) {
                    this.ignoreUpdates++;

                    removeRecordFn(record);

                    Ext.Array.remove(removedStash, record);
                    // number of removals applied
                    applied++;

                    this.ignoreUpdates--;
                } else {
                    Ext.log("Can't find record to remove from the response package");
                }
            }
        }

        return applied;
    },

    applyChangesToStore : function (store, storeResponse) {
        var j, k, id;

        var phantomIdField  = store.phantomIdField || this.phantomIdField,
            idProperty      = store.idProperty,
            s               = store.store;

        if (!idProperty) {
            var model   = s.getModel && s.getModel() || s.model;
            model       = model && model.prototype;
            idProperty  = model && model.idProperty || 'id';
        }

        // TODO: this might need to be refactored taking Sch.data.mixin.UniversalModelGetter methods into account
        var findByKey   = function (id) { return s.data.getByKey(id); },
            findById    = function (id) { return s.getById(id); },
            findNode    = function (id) { return s.getNodeById(id); },
            addRecordFn, removeRecordFn;

        var findByPhantomFn, findByIdFn;

        // if it's a tree store
        if (s instanceof Ext.data.TreeStore) {
            findByPhantomFn = findByIdFn = findNode;

            addRecordFn     = function (data) {
                var parent  = (data.parentId && s.getNodeById(data.parentId)) || s.getRootNode();

                return parent.appendChild(data);
            };

            removeRecordFn  = function (record) {
                return record.parentNode.removeChild(record);
            };

        // plain store
        } else {
            findByPhantomFn = findByKey;
            findByIdFn      = findById;
            addRecordFn     = function (data) { return s.add(data)[0]; };
            removeRecordFn  = function (record) { return s.remove(record); };
        }

        var rows    = storeResponse.rows,
            removed = storeResponse.removed,
            record;

        // process added/updated records
        if (rows) {

            var data, phantomId,
                // sub-stores
                stores  = store.stores;

            for (j = 0, k = rows.length; j < k; j++) {
                data        = rows[j];
                phantomId   = data[phantomIdField];
                id          = data[idProperty];
                record      = null;

                // if phantomId is provided then we will use it to find added record
                if (phantomId != null) {

                    record  = findByPhantomFn(phantomId);

                // if id is provided then we will use it to find updated record
                } else if (idProperty) {

                    record  = findByIdFn(id);

                }

                if (record) {
                    this.applyChangesToRecord(record, data, stores);
                } else {
                    this.ignoreUpdates++;

                    // create new record in the store
                    record  = addRecordFn(data);

                    this.ignoreUpdates--;

                    record.commit();
                }
            }
        }

        // process removed records
        if (removed && this.applyRemovals(s, removed, {
            idProperty      : idProperty,
            findByIdFn      : findByIdFn,
            removeRecordFn  : removeRecordFn
        })) {
            s.fireEvent('datachanged', s);
        }
    },


    applySyncResponse : function (response) {
        // we apply received changes to the stores in the order they're kept in either this.syncApplySequence or this.stores array
        var stores  = this.syncApplySequence || this.stores;
        for (var i = 0, l = stores.length; i < l; i++) {
            var storeResponse   = response[stores[i].storeId];

            if (storeResponse) {
                this.applyChangesToStore(stores[i], storeResponse);
            }
        }
    },


    applyLoadResponse : function (response) {
        this.loadData(response);
    },


    applyResponse : function (requestType, response) {
        // in trackResponseType we check response type before deciding how to react on the response
        if (this.trackResponseType) {
            requestType = response.type || requestType;
        }

        switch (requestType) {
            case 'load' : this.applyLoadResponse(response); break;
            case 'sync' : this.applySyncResponse(response); break;
        }
    },


    /**
     * Generates unique request identifier.
     * @protected
     * @template
     * @return {Integer} The request identifier.
     */
    getRequestId : function () {
        // TODO: this is not very reliable, two calls to this method withing one ms will ruin the logic
        return Ext.Date.now();
    },


    onResponse : function (requestType, rawResponse, responseOptions) {
        // reset last requested package ID
        this.activeRequests[requestType]    = null;

        var response    = this.decode(rawResponse);

        if (!response || !response.success) {

            /**
             * @event requestfail
             * Fires when a request gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent('requestfail', this, requestType, response, responseOptions);
            /**
             * @event loadfail
             * Fires when {@link #load load request} gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            /**
             * @event syncfail
             * Fires when {@link #sync sync request} gets failed.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The response options.
             */
            this.fireEvent(requestType+'fail', this, response, responseOptions);

            this.warn('CrudManager: '+requestType+' failed, please inspect the server response', rawResponse);

            return response;
        }

        /**
         * @event beforeresponseapply
         * Fires before server response gets applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {String} requestType The request type (`sync` or `load`).
         * @param {Object} response The decoded server response object.
         */
        /**
         * @event beforeloadapply
         * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         */
        /**
         * @event beforesyncapply
         * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.
         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} response The decoded server response object.
         */
        if ((this.fireEvent('beforeresponseapply', this, requestType, response) !== false) && (this.fireEvent('before'+requestType+'apply', this, response) !== false)) {

            this.revision = response.revision;

            this.applyResponse(requestType, response);

            /**
             * @event requestdone
             * Fires on successful request completion after data gets applied to the stores.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {String} requestType The request type (`sync` or `load`).
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             */
            this.fireEvent('requestdone', this, requestType, response, responseOptions);
            /**
             * @event load
             * Fires on successful {@link #load load request} completion after data gets loaded to the stores.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             */
            /**
             * @event sync
             * Fires on successful {@link #sync sync request} completion.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} response The decoded server response object.
             * @param {Object} responseOptions The server response options.
             */
            this.fireEvent(requestType, this, response, responseOptions);

            if (!this.hasChanges()) {
                /**
                 * @event nochanges
                 * Fires when registered stores get into state when they don't have any
                 * not persisted change. This happens after {@link #method-load load} or {@link #method-sync sync} request
                 * completion. Or this may happen after a record update which turns its fields back to their original state.

                crudManager.on('nochanges', function (crud) {
                    // disable persist changes button when there is no changes
                    saveButton.disable();
                });

                 * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
                 */
                this.fireEvent('nochanges', this);
            }
        }

        return response;
    },


    onLoad : function (rawResponse, responseOptions) {
        return this.onResponse('load', rawResponse, responseOptions);
    },


    onSync : function (rawResponse, responseOptions) {
        return this.onResponse('sync', rawResponse, responseOptions);
    },

    /**
     * Loads data to the stores registered in the crud manager. For example:

        crudManager.load(
            // here are request parameters
            {
                store1 : { page : 3, smth : 'foo' },
                store2 : { page : 2, bar : '!!!' }
            },
            // here is callback
            function () { alert('OMG! It works!') },
            // here is errback
            function (response) { alert('Oops: '+response.message); }
        );

     * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by {@link #cancelRequest} calling.

     * @param {Object} [parameters] The request parameters. This argument can be omitted like this:

        crudManager.load(
            // here is callback
            function () { alert('OMG! It works!') },
            // here is errback
            function (response) { alert('Oops: '+response.message); }
        );

     * When presented it should be an object where keys are store Ids and values are, in turn, objects
     * of parameters related to the corresponding store. And these parameters will be transferred with a load request.

            {
                store1 : { page : 3, smth : 'foo' },
                store2 : { page : 2, bar : '!!!' }
            },

     * @param {Function} [callback] An optional callback to be started on successful request completion.
     * There is also a {@link #event-load load} event which can be used for load request completion processing.
     * @param {Function} [errback] A callback to be started on request failure.
     * There is also an {@link #loadfail} event which can be used for load request failures processing.
     * @param {Object/Function} [scope] A scope to be used for `callback` and `errback` calls.
     */
    load : function (callback, errback, scope) {
        var options;

        if (typeof callback === 'object') {
            options     = callback;
            callback    = errback;
            errback     = scope;
            scope       = arguments[3];
        }

        var pack    = this.getLoadPackage(options);

        /**
         * @event beforeload
         * Fires before {@link #load load request} is sent. Return `false` to cancel load request.
         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (this.fireEvent('beforeload', this, pack) !== false) {
            scope   = scope || this;

            // if another load request is in progress let's cancel it
            if (this.activeRequests.load) {
                this.cancelRequest(this.activeRequests.load.desc);

                this.fireEvent('loadcanceled', this, pack);
            }

            this.activeRequests.load = { id : pack.requestId };

            this.activeRequests.load.desc = this.sendRequest({
                data        : this.encode(pack),
                type        : 'load',
                success     : function (rawResponse, responseOptions) {
                    var response = this.onLoad(rawResponse, responseOptions);

                    if (errback && (!response || !response.success)) {
                        errback.call(scope, response, rawResponse);

                    } else if (callback) {
                        callback.call(scope, response, rawResponse);
                    }
                },
                failure     : function (rawResponse, responseOptions) {
                    this.onLoad(rawResponse, responseOptions);

                    if (errback) errback.apply(scope, arguments);
                },
                scope       : this
            });
        // if loading was canceled let's fire event
        } else {
            /**
             * @event loadcanceled
             * Fired after {@link #load load request} was canceled by some {@link #beforeload} listener
             * or due to incomplete prior load request.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} request The request object.
             */
            this.fireEvent('loadcanceled', this, pack);
        }
    },

    /**
     * Persists changes made on the registered stores to the server.
     * Request runs asynchronously so if user need to execute some code after request completion it has to be provided in the `callback` function:
     *
     *      // persist and run a callback on request completion
     *      sync(function(){ alert("Changes saved..."); }, function(response){ alert("Error: "+response.message); });
     *
     * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it until previous request completion.
     * In this case {@link #syncdelayed} event will be fired.
     *
     * ** Note: ** Please take a look at {@link #autoSync} config. This option allows to persist changes automatically after any data modification.
     *
     * @param {Function} [callback] A function to start on successful request completion.
     * There is also a {@link #event-sync sync} event which can be used for sync request completion processing.
     *
     * **Note:** If there is no changes to persist then callback will be started immediately without sending any request
     * and {@link #event-sync sync} event will not be fired.
     * @param {Function} [errback] A function to start on request failure.
     * There is also an {@link #syncfail} event which can be used for sync request failures processing.
     * @param {Object} [scope] A scope for above `callback` and `errback` functions.
     */
    sync : function (callback, errback, scope) {
        if (this.activeRequests.sync) {
            // let's delay this call and start it only after server response
            this.delayedSyncs.push(arguments);

            /**
             * @event syncdelayed
             * Fires after {@link #sync sync request} was delayed due to incomplete previous one.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} arguments The arguments of {@link #sync} call.
             */
            this.fireEvent('syncdelayed', this, arguments);

            return;
        }

        // get current changes set package
        var pack    = this.getChangeSetPackage();

        scope       = scope || this;

        // if no data to persist we run callback and exit
        if (!pack) {
            if (callback) callback.call(scope, null, null);

            return;
        }

        /**
         * @event beforesync
         * Fires before {@link #sync sync request} is sent. Return `false` to cancel sync request.

        crudManager.on('beforesync', function() {
            // cannot persist changes before at least one record is added
            // to the `someStore` store
            if (!someStore.getCount()) return false;
        });

         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} request The request object.
         */
        if (this.fireEvent('beforesync', this, pack) === false) {
            // if this sync was canceled let's fire event about it
            /**
             * @event synccanceled
             * Fires after {@link #sync sync request} was canceled by some {@link #beforesync} listener.
             * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
             * @param {Object} request The request object.
             */
            this.fireEvent('synccanceled', this, pack);

            return;
        }

        // keep active reaqest Id
        this.activeRequests.sync = { id : pack.requestId };

        // send sync package
        this.activeRequests.sync.desc = this.sendRequest({
            data        : this.encode(pack),
            type        : 'sync',
            success     : function (rawResponse, options) {
                var request     = this.activeRequests.sync;
                var response    = this.onSync(rawResponse, options);

                if (errback && (!response || !response.success)) {
                    errback.call(scope, response, rawResponse, request);

                } else if (callback) {
                    callback.call(scope, response, rawResponse, request);
                }

                // execute delayed sync() call
                this.runDelayedSync();
            },
            failure     :  function (rawResponse, options) {
                this.onSync(rawResponse, options);

                if (errback) errback.apply(scope, arguments);

                // execute delayed sync() call
                this.runDelayedSync();
            },
            scope       : this
        });
    },


    runDelayedSync : function () {
        var args  = this.delayedSyncs.shift();
        if (!args) return;

        this.sync.apply(this, args);
    },

    /**
     * Commits all records changes of all the registered stores.
     */
    commit : function () {
        for (var i = 0, l = this.stores.length; i < l; i++) {
            this.stores[i].store.commitChanges();
        }
    },

    /**
     * Rejects all records changes on all stores and re-insert any records that were removed locally. Any phantom records will be removed.
     */
    reject : function () {
        for (var i = 0, l = this.stores.length; i < l; i++) {
            this.stores[i].store.rejectChanges();
        }
    },

    warn : function() {
        if ('console' in window) {
            var c = console;
            c.log && c.log.apply && c.log.apply(c, arguments);
        }
    },

    // Used to help the UI know if the manager is already working and a loadmask should be shown when a consuming UI panel is created.
    isLoading               : function() {
        return !!this.activeRequests.load;
    }
});

/**
@class Sch.crud.transport.Ajax
@abstract
Implements data transferring functional that can be used for {@link Sch.crud.AbstractManager} super classing.
Uses AJAX as a transport system.

    // let's make new CrudManager using AJAX as a transport system and XML for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
    });

*/
Ext.define('Sch.crud.transport.Ajax', {

    /**
     * @cfg {Object} transport
     * Configuration of the AJAX requests used to communicate with a server-side.
     * An object where you can set the following possible properties:
     * @cfg {Object} transport.load Load requests configuration:
     * @cfg {String} transport.load.url URL to request for data loading.
     * @cfg {String} [transport.load.method='POST'] HTTP method to be used for load requests.
     * @cfg {String} [transport.load.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @cfg {Object} [transport.load.params] Extra load request params if needed.
     * @cfg {Object} [transport.load.requestConfig] Ext.Ajax.request config. Can be used instead of above `url`, `method`, `params`:
     *
     *      transport   : {
     *          load    : {
     *              requestConfig : {
     *                  url             : 'http://some-url',
     *                  method          : 'GET',
     *                  // get rid of cache-buster parameter
     *                  disableCaching  : false,
     *                  // extra request parameters
     *                  params          : {
     *                      foo         : 'bar'
     *                  },
     *                  // custom request headers
     *                  headers         : {
     *                      ...
     *                  }
     *              }
     *          }
     *      }
     *
     * @cfg {Object} transport.sync Sync requests configuration:
     * @cfg {String} transport.sync.url URL to request for data persisting.
     * @cfg {String} [transport.sync.method='POST'] HTTP method to be used for sync requests.
     * @cfg {String} [transport.sync.paramName] Name of parameter in which a packet will be transfered. If not specified then a packet will be transfered in a request body (default).
     * @cfg {Object} [transport.sync.params] Extra sync request params if needed.
     * @cfg {Object} [transport.sync.requestConfig] Ext.Ajax.request config. Can be used instead of above `url`, `method`, `params`:
     *
     *      transport   : {
     *          sync    : {
     *              requestConfig : {
     *                  url             : 'http://some-url',
     *                  method          : 'GET',
     *                  // get rid of cache-buster parameter
     *                  disableCaching  : false,
     *                  // extra request parameters
     *                  params          : {
     *                      foo         : 'bar'
     *                  },
     *                  // custom request headers
     *                  headers         : {
     *                      ...
     *                  }
     *              }
     *          }
     *      }
     */

    defaultMethod   : {
        load    : 'GET',
        sync    : 'POST'
    },

    /**
     * Cancels sent request.
     * @param {Object} request The descriptor of request to be canceled. The _request descriptor_ is a value returned by corresponding {@link #sendRequest} call.
     */
    cancelRequest : function (request) {
        Ext.Ajax.abort(request);
    },

    /**
     * Sends request to the server.
     * @param {Object} request The request configuration object having following properties:
     * @param {String} request.data The encoded request.
     * @param {String} request.type The request type. Either `load` or `sync`.
     * @param {Function} request.success A function to be started on successful request transferring.
     * @param {Function} request.failure A function to be started on request transfer failure.
     * @param {Object} request.scope A scope for the above `success` and `failure` functions.
     * @return {Object} The request descriptor.
     */
    sendRequest : function (config) {
        var pack        = config.data,
            packCfg     = this.transport[config.type],
            paramName   = packCfg.paramName,
            params      = Ext.apply({}, packCfg && packCfg.params),
            method      = packCfg.method || this.defaultMethod[config.type];

        var requestConfig   = Ext.apply({
            url         : packCfg.url,
            method      : method,
            params      : params,
            failure     : config.failure,
            success     : function (response, options) {
                if (config.success) {
                    config.success.call(config.scope || this, response.responseXml || response.responseText);
                }
            },
            scope       : config.scope
        }, packCfg.requestConfig);

        // if no param name specified then we'll transfer package in the request body
        if (!paramName) {
            if (this.format === 'xml') {
                Ext.apply(requestConfig, { xmlData : pack });
            } else {
                Ext.apply(requestConfig, { jsonData : pack });
            }
        // ..otherwise we use parameter
        } else {
            requestConfig.params            = requestConfig.params || {};
            requestConfig.params[paramName] = pack;
        }

        /**
         * @event beforesend
         * Fires before a request is sent to the server.

        crudManager.on('beforesend', function (crud, params, requestType) {
            // let's set "sync" request parameters
            if (requestType == 'sync') {
                // dynamically depending on "flag" value
                if (flag) {
                    params.foo = 'bar';
                } else {
                    params.foo = 'smth';
                }
            }
        });

         * @param {Sch.crud.AbstractManager} crudManager The CRUD manager.
         * @param {Object} params Request params
         * @param {String} requestType Request type (`load`/`sync`)
         * @param {Object} requestConfig Configuration object for Ext.Ajax.request call
         */
        this.fireEvent('beforesend', this, params, config.type, requestConfig);

        return Ext.Ajax.request(requestConfig);
    }

});

/**
@class Sch.crud.encoder.Json
@abstract
Implements data encoding functional that should be mixed to a {@link Sch.crud.AbstractManager} sub-class.
Uses _JSON_ as an encoding system.

    // let's make new CrudManager using AJAX as a transport system and JSON for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Json', 'Sch.crud.transport.Ajax']
    });

*/
Ext.define('Sch.crud.encoder.Json', {

    format  : 'json',

    /**
     * Encodes an request object to _JSON_ encoded string.
     * @param {Object} request The request to encode.
     */
    encode : function (request) {
        return Ext.JSON.encode(request);
    },

    /**
     * Decodes (parses) a _JSON_ response string to an object.
     * @param {Object} response The response to decode.
     */
    decode : function (response) {
        if (typeof response == 'object') return response;

        return Ext.JSON.decode(response, true);
    }

});

/**
@class Sch.crud.encoder.Xml
@abstract
Implements data encoding functional that should be mixed to a {@link Sch.crud.AbstractManager} sub-class.
Uses _XML_ as an encoding system.

    // let's make new CrudManager using AJAX as a transport system and XML for encoding
    Ext.define('MyCrudManager', {
        extend  : 'Sch.crud.AbstractManager',

        mixins  : ['Sch.crud.encoder.Xml', 'Sch.crud.transport.Ajax']
    });

# Request structure

Load request example:

    <load requestId="123890">
        <store id="store1" page="1" pageSize="10"/>
        <store id="store2"/>
        <store id="store3"/>
    </load>

Sync request:

    <sync requestId="123890" revision="123">
        <store id="store1">
            <added>
                <record>
                    <field id="$PhantomId">q1w2e3r4t5</field>
                    <field id="SomeField">smth</field>
                    ...
                </record>
                ...
            </added>
            <updated>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField">new value</field>
                    ...
                </record>
                ...
            </updated>
            <removed>
                <record>
                    <field id="Id">345</field>
                </record>
                ...
            </removed>
        </store>

        <store id="store2">
            <added>...</added>
            <updated>...</updated>
            <removed>...</removed>
        </store>
    </sync>

# Response structure

Load response example:

    <data requestId="123890" revision="123" success="true">

        <store id="store1">
            <rows total="5">
                <record>
                    <field id="Id">9000</field>
                    <field id="SomeField">xxxx</field>
                    ...
                </record>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField">yyyy</field>
                    ...
                </record>
            </rows>
        </store>

        <store id="store2">
            <rows total="2">
                <record>
                    <field id="Id">1</field>
                    <field id="Field1">aaa</field>
                    ...
                </record>
                <record>
                    <field id="Id">2</field>
                    <field id="Field1">bbb</field>
                    ...
                </record>
            </rows>
        </store>

        <store id="store3">
            <rows total="2">
                <record>
                    <field id="Id">1</field>
                    <field id="Field2">aaa</field>
                    ...
                </record>
                <record>
                    <field id="Id">2</field>
                    <field id="Field2">bbb</field>
                    ...
                </record>
            </rows>
        </store>
    </data>

Sync response:

    <data requestId="123890" success="true" revision="124">
        <store id="store1">
            <rows>
                <record>
                    <field id="$PhantomId">q1w2e3r4t5</field>
                    <field id="Id">9000</field>
                </record>
                <record>
                    <field id="Id">123</field>
                    <field id="SomeField2">2013-08-01</field>
                </record>
            </rows>
            <removed>
                <record>
                    <field id="Id">345</field>
                </record>
                ...
            </removed>
        </store>

        <store id="store2">
            <rows>...</rows>
            <removed>...</removed>
        </store>
    </data>

# Error response

    <data requestId="123890" success="true" code="13">
        <message>Error description goes here</message>
    </data>

*/
Ext.define("Sch.crud.encoder.Xml", {

    requires        : ['Ext.XTemplate'],

    format          : 'xml',

    stringReplaces  : [
        [ /&/g, '&amp;' ],
        [ /</g, '&lt;' ],
        [ />/g, '&gt;' ],
        [ /"/g, '&quot;' ]
    ],

    // Translates a string characters to XML safe ones
    encodeString : function (text) {
        if (!text) return text;

        var result      = text.toString(),
            replaces    = this.stringReplaces;
        for (var i = 0, l = replaces.length; i < l; i++) {
            result  = result.replace(replaces[i][0], replaces[i][1]);
        }

        return result;
    },

    encodeRecords : function (records) {
        var result = '';
        for (var i = 0, l = records.length; i < l; i++) {
            result += this.encodeRecord(records[i]);
        }
        return result;
    },

    encodeRecord : function (record) {
        var result = '<record>';

        for (var i in record) {
            var field   = record[i];

            result  += '<field id="' + this.encodeString(i) + '">' +
                (field && field.$store ? this.encodeStoreChanges({ storeId : i }, field) : this.encodeString(field)) +
                '</field>';
        }

        result += '</record>';

        return result;
    },

    encodeStoreChanges : function (store, changes) {
        var result = '<store id="' + this.encodeString(store.storeId) + '">';

        if (changes.added) {
            result += '<added>' + this.encodeRecords(changes.added) + '</added>';
        }
        if (changes.updated) {
            result += '<updated>' + this.encodeRecords(changes.updated) + '</updated>';
        }
        if (changes.removed) {
            result += '<removed>' + this.encodeRecords(changes.removed) + '</removed>';
        }

        result += '</store>';

        return result;
    },

    /**
     * Encodes an request object to _XML_ encoded string. The formats of requests are displayed in an intro.
     * @param {Object} request The request to encode.
     */
    encode : function (packet) {
        var result, i, l, store;

        switch (packet.type) {
            case 'load':
                result = '<load requestId="' + this.encodeString(packet.requestId) + '">';

                for (i = 0, l = packet.stores.length; i < l; i ++) {
                    store   = packet.stores[i];

                    if (typeof store === 'string') {
                        result += '<store id="' + this.encodeString(store) + '"/>';
                    } else {
                        result += '<store id="' + this.encodeString(store.storeId) + '" page="' +
                            this.encodeString(store.page) + '" pageSize="' + this.encodeString(store.pageSize) + '"/>';
                    }
                }

                result += '</load>';

                return result;

            case 'sync':
                result = '<sync requestId="' + this.encodeString(packet.requestId) + '" revision="' + this.encodeString(packet.revision) + '">';
                for (i in packet) {
                    if (packet.hasOwnProperty(i)) {
                        store   = this.getStore(i);

                        if (store) {
                            result += this.encodeStoreChanges(store, packet[i]);
                        }
                    }
                }
                result += '</sync>';
                break;
        }

        return result;
    },


    stringToXML : function (text) {
        if (!text) return;

        var document;
        
        /*global DOMParser: false, ActiveXObject: false */

        if (window.DOMParser) {
            document    = (new DOMParser()).parseFromString(text, 'text/xml');
        } else if (window.ActiveXObject) {
            document        = new ActiveXObject('Microsoft.XMLDOM');
            document.async  = false;
            document.loadXML(text);
        }

        return document;
    },


    decodeRecords : function (rows) {
        var result   = [];

        for (var j = 0, m = rows.length; j < m; j++) {
            result.push( this.decodeRecord(rows[j]) );
        }

        return result;
    },


    decodeRecord : function (node) {
        var fields  = node.childNodes,
            result  = {},
            value;

        for (var i = 0, l = fields.length; i < l; i++) {
            var field   = fields[i];

            if (field.nodeName == 'field') {

                value       = '';

                if (field.firstChild) {
                    var store   = this.getElementByTagName(field, 'store');

                    value       = store ? this.decodeStore(store) : field.firstChild.nodeValue;
                }

                result[field.getAttribute('id')]    = value;
            }
        }

        return result;
    },

    // search specified nodes only in a first level of children
    getElementsByTagName : function (node, name) {
        var children    = node.childNodes,
            records     = [];

        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].nodeName == name) records.push(children[i]);
        }

        return records;
    },

    getElementByTagName : function (node, name) {
        var children    = node.childNodes;

        for (var i = 0, l = children.length; i < l; i++) {
            if (children[i].nodeName == name) return children[i];
        }
    },

    decodeStore : function (store) {
        var data    = {},
            rows    = this.getElementsByTagName(store, 'rows');

        if (rows.length) {
            data.rows   = this.decodeRecords(this.getElementsByTagName(rows[0], 'record'));

            var total   = parseInt(rows[0].getAttribute('total'), 10);
            if (isNaN(total) || total < data.rows.length) total = data.rows.length;

            data.total  = total;
        }

        var removed = this.getElementByTagName(store, 'removed');
        if (removed) {
            data.removed    = this.decodeRecords(this.getElementsByTagName(removed, 'record'));
        }

        return data;
    },

    /**
     * Decodes (parses) a _XML_ response string to an object. The formats of processable server responses are displayed in an intro.
     * @param {Object} response The response to decode.
     */
    decode : function (packet) {
        var xml = typeof packet == 'string' ? this.stringToXML(packet) : packet;

        if (!xml) return;

        var result  = {},
            root    = xml.documentElement,
            stores  = root.getElementsByTagName('store'),
            store, storeId;

        result.requestId    = root.getAttribute('requestId');
        result.revision     = root.getAttribute('revision');
        result.success      = root.getAttribute('success') || 'false';
        result.success      = result.success.toLowerCase() == 'true';

        if (!result.success) {
            // extract error code
            result.code     = root.getAttribute('code');

            var message     = root.getElementsByTagName('message')[0];
            result.message  = message && message.firstChild && message.firstChild.nodeValue;
        }

        for (var i = 0, l = stores.length; i < l; i++) {
            store   = stores[i];
            storeId = store.getAttribute('id');

            if (this.getStore(storeId)) {
                result[storeId]     = this.decodeStore(store);
            }
        }

        return result;
    }

});

/**
@class Sch.data.CrudManager

The Crud Manager (or "CM") is a class implementing centralized loading and saving of data in multiple stores.
Loading the stores and saving all changes is done using one ajax request. This class uses AJAX as a transport mechanism and JSON as the data encoding format.

For usage details please see [this guide](#!/guide/scheduler_crud_manager).

# Scheduler stores

The class supports Ext Scheduler specific stores (namely: resource, event and assignment stores).
For these stores, the CM has separate configs ({@link #resourceStore}, {@link #eventStore}, {@link #assignmentStore)
to register them. The class can also grab them from the task store (this behavior can be changed using
{@link #addRelatedStores} config).

    var crudManager = Ext.create('Sch.data.CrudManager', {
        autoLoad        : true,
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

# AJAX request configuration

To configure AJAX request parameters please take a look at the {@link #transport} config.

    var crudManager = Ext.create('Sch.data.CrudManager', {
        autoLoad        : true,
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        transport       : {
            load    : {
                url         : 'php/read.php',
                // use GET request
                method      : 'GET',
                // pass request JSON in "rq" parameter
                paramName   : 'rq',
                // extra HTTP request parameters
                params      : {
                    foo     : 'bar'
                }
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });


# Load order

The CM is aware of the proper load order for Scheduler specific stores so you don't need to worry about it.
If you provide any extra stores (using {@link #stores} config) they will be added to the start of collection before
 the Scheduler specific stores.
If you a different load order, you should use {@link #addStore} method to register your store:

    var crudManager = Ext.create('Sch.data.CrudManager', {
        resourceStore   : resourceStore,
        eventStore      : eventStore,
        assignmentStore : assignmentStore,
        // extra user defined stores will get to the start of collection
        // so they will be loaded first
        stores          : [ store1, store2 ],
        transport       : {
            load    : {
                url     : 'php/read.php'
            },
            sync    : {
                url     : 'php/save.php'
            }
        }
    });

    // append store3 to the end so it will be loaded last
    crudManager.addStore(store3);

    // now when we registered all the stores let's load them
    crudManager.load();

*/
Ext.define('Sch.data.CrudManager', {
    extend          : 'Sch.crud.AbstractManager',

    mixins          : ['Sch.crud.encoder.Json', 'Sch.crud.transport.Ajax'],

    /**
     * @cfg {Sch.data.ResourceStore/Object} resourceStore A store with resources (or its descriptor).
     */
    /**
     * @property {Object} resourceStore The resource store descriptor.
     */
    resourceStore   : null,
    /**
     * @cfg {Sch.data.EventStore/Object} eventStore A store with events (or its descriptor).
     */
    /**
     * @property {Object} eventStore The event store descriptor.
     */
    eventStore      : null,
    /**
     * @cfg {Sch.data.AssignmentStore/Object} assignmentStore A store with assignments (or its descriptor).
     */
    /**
     * @property {Object} assignmentStore The assignment store descriptor.
     */
    assignmentStore : null,

    /**
     * @cfg {Boolean} addRelatedStores
     * When set to `true` this class will try to get the {@link #resourceStore} and {@link #assignmentStore} stores from
     * the specified {@link #eventStore} instance.
     */
    addRelatedStores    : true,

    constructor : function (config) {
        config  = config || {};

        var resourceStore   = config.resourceStore   || this.resourceStore,
            eventStore      = config.eventStore      || this.eventStore,
            assignmentStore = config.assignmentStore || this.assignmentStore,
            // list of stores to add
            stores          = [];

        // retrieve stores registered on the provided taskStore
        if (eventStore && config.addRelatedStores !== false) {
            var extracted   = this.getEventStoreInfo(eventStore, config);

            assignmentStore = assignmentStore || extracted.assignmentStore;
            resourceStore   = resourceStore   || extracted.resourceStore;
        }

        // event store
        eventStore && stores.push(eventStore);
        // resource store
        resourceStore && stores.push(resourceStore);
        // assignment store
        assignmentStore && stores.push(assignmentStore);

        // all the Scheduler related stores will go after the user defined stores from the config.stores
        if (stores.length) {
            var syncSequence   = [];

            // For applying sync results we have a different order:
            // resources -> events -> assignments
            resourceStore && syncSequence.push(resourceStore);
            eventStore && syncSequence.push(eventStore);
            assignmentStore && syncSequence.push(assignmentStore);

            if (syncSequence.length) {
                config.syncApplySequence    = (config.syncApplySequence || config.stores || []).concat(syncSequence);
            }

            var _stores      = config.stores || this.stores;

            if (_stores && !Ext.isArray(_stores)) _stores = [_stores];

            config.stores   = (_stores || []).concat(stores);
        }

        this.callParent([ config ]);

        this.eventStore      = this.getStoreDescriptor(eventStore);
        this.resourceStore   = this.getStoreDescriptor(resourceStore);
        this.assignmentStore = this.getStoreDescriptor(assignmentStore);
    },

    getEventStoreInfo : function (eventStore, config) {
        if (!(eventStore instanceof Ext.data.AbstractStore)) {
            if (typeof eventStore == 'string') {
                eventStore   = Ext.data.StoreManager.get(eventStore);
            } else {
                eventStore   = eventStore.store;
            }
        }
        var result          = {},
            assignmentStore = config.assignmentStore,
            resourceStore   = config.resourceStore;

        !assignmentStore && (result.assignmentStore = eventStore.getAssignmentStore());
        !resourceStore   && (result.resourceStore   = eventStore.getResourceStore());

        return result;
    },

    /**
     * Returns the resource store bound to the CRUD manager.
     * @return {Sch.data.ResourceStore} The resource store.
     */
    getResourceStore : function () {
        return this.resourceStore && this.resourceStore.store;
    },

    /**
     * Returns the event store bound to the CRUD manager.
     * @return {Sch.data.EventStore} The event store.
     */
    getEventStore : function () {
        return this.eventStore && this.eventStore.store;
    },

    /**
     * Returns the assignment store bound to the CRUD mananger.
     * @return {Sch.data.AssignmentStore} The assignment store
     */
    getAssignmentStore : function() {
        return this.assignmentStore && this.assignmentStore.store;
    }
});

/**
 * @class Sch.util.Date
 * @static
 * Static utility class for Date manipulation
 */
Ext.define('Sch.util.Date', {
    requires        : 'Ext.Date',
    mixins          : ['Sch.mixin.Localizable'],
    singleton       : true,

    // These stem from Ext.Date in Ext JS but since they don't exist in Sencha Touch we'll need to keep them here
    stripEscapeRe   : /(\\.)/g,
    hourInfoRe      : /([gGhHisucUOPZ]|MS)/,

    unitHash        : null,
    unitsByName     : {},

    // Override this to localize the time unit names.
    //unitNames   : {
        //YEAR    : { single : 'year', plural : 'years', abbrev : 'yr' },
        //QUARTER : { single : 'quarter', plural : 'quarters', abbrev : 'q' },
        //MONTH   : { single : 'month', plural : 'months', abbrev : 'mon' },
        //WEEK    : { single : 'week', plural : 'weeks', abbrev : 'w' },
        //DAY     : { single : 'day', plural : 'days', abbrev : 'd' },
        //HOUR    : { single : 'hour', plural : 'hours', abbrev : 'h' },
        //MINUTE  : { single : 'minute', plural : 'minutes', abbrev : 'min' },
        //SECOND  : { single : 'second', plural : 'seconds', abbrev : 's' },
        //MILLI   : { single : 'ms', plural : 'ms', abbrev : 'ms' }
    //},


    constructor : function () {
        var ED = Ext.Date;
        var unitHash = this.unitHash = {
            /**
             * Date interval constant
             * @static
             * @type String
             */
            MILLI : ED.MILLI,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            SECOND : ED.SECOND,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            MINUTE : ED.MINUTE,

            /** Date interval constant
             * @static
             * @type String
             */
            HOUR : ED.HOUR,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            DAY : ED.DAY,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            WEEK : "w",

            /**
             * Date interval constant
             * @static
             * @type String
             */
            MONTH : ED.MONTH,

            /**
             * Date interval constant
             * @static
             * @type String
             */
            QUARTER : "q",

            /**
             * Date interval constant
             * @static
             * @type String
             */
            YEAR : ED.YEAR
        };
        Ext.apply(this, unitHash);

        var me = this;
        this.units = [me.MILLI, me.SECOND, me.MINUTE, me.HOUR, me.DAY, me.WEEK, me.MONTH, me.QUARTER, me.YEAR];
    },


    onLocalized : function () {
        this.setUnitNames(this.L('unitNames'));
    },


    /**
     * Call this method to provide your own, localized values for duration unit names. See the "/js/Sch/locale/sch-lang-*.js" files for examples
     *
     * @param {Object} unitNames
     */
    setUnitNames : function (unitNames, preserveLocales) {
        var unitsByName = this.unitsByName = {};

        this.l10n.unitNames = unitNames;

        this._unitNames     = Ext.apply({}, unitNames);

        var unitHash        = this.unitHash;

        // Make it possible to lookup readable date names from both 'DAY' and 'd' etc.
        for (var name in unitHash) {
            if (unitHash.hasOwnProperty(name)) {
                var unitValue = unitHash[name];

                this._unitNames[ unitValue ] = this._unitNames[name];

                unitsByName[ name ] = unitValue;
                unitsByName[ unitValue ] = unitValue;
            }
        }
    },


    /**
     * Checks if this date is >= start and < end.
     * @param {Date} date The source date
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Boolean} true if this date falls on or between the given start and end dates.
     * @static
     */
    betweenLesser : function (date, start, end) {
        var t = date.getTime();
        return start.getTime() <= t && t < end.getTime();
    },

    /**
     * Constrains the date within a min and a max date
     * @param {Date} date The date to constrain
     * @param {Date} min Min date
     * @param {Date} max Max date
     * @return {Date} The constrained date
     * @static
     */
    constrain : function (date, min, max) {
        return this.min(this.max(date, min), max);
    },

    /**
     * Returns 1 if first param is a greater unit than second param, -1 if the opposite is true or 0 if they're equal
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    compareUnits : function (u1, u2) {
        var ind1 = Ext.Array.indexOf(this.units, u1),
            ind2 = Ext.Array.indexOf(this.units, u2);

        return ind1 > ind2 ? 1 : (ind1 < ind2 ? -1 : 0);
    },

    /**
     * Returns true if first unit passed is strictly greater than the second.
     * @static
     *
     * @param {String} unit1 The 1st unit
     * @param {String} unit2 The 2nd unit
     */
    isUnitGreater : function (u1, u2) {
        return this.compareUnits(u1, u2) > 0;
    },

    /**
     * Copies hours, minutes, seconds, milliseconds from one date to another
     * @static
     *
     * @param {String} targetDate The target date
     * @param {String} sourceDate The source date
     */
    copyTimeValues : function (targetDate, sourceDate) {
        targetDate.setHours(sourceDate.getHours());
        targetDate.setMinutes(sourceDate.getMinutes());
        targetDate.setSeconds(sourceDate.getSeconds());
        targetDate.setMilliseconds(sourceDate.getMilliseconds());
    },

    /**
     * Adds a date unit and interval
     * @param {Date} date The source date
     * @param {String} unit The date unit to add
     * @param {Number} value The number of units to add to the date
     * @return {Date} The new date
     * @static
     */
    add : function (date, unit, value) {
        var d = Ext.Date.clone(date);
        if (!unit || value === 0) return d;

        switch (unit.toLowerCase()) {
            case this.MILLI:
                d = new Date(date.getTime() + value);
                break;
            case this.SECOND:
                d = new Date(date.getTime() + (value * 1000));
                break;
            case this.MINUTE:
                d = new Date(date.getTime() + (value * 60000));
                break;
            case this.HOUR:
                d = new Date(date.getTime() + (value * 3600000));
                break;
            case this.DAY:
                d.setDate(date.getDate() + value);

                if(d.getHours() === 23 && date.getHours() === 0) {
                    d = Ext.Date.add(d, Ext.Date.HOUR, 1);
                }
                break;
            case this.WEEK:
                d.setDate(date.getDate() + value * 7);
                break;
            case this.MONTH:
                var day = date.getDate();
                if (day > 28) {
                    day = Math.min(day, Ext.Date.getLastDateOfMonth(this.add(Ext.Date.getFirstDateOfMonth(date), this.MONTH, value)).getDate());
                }
                d.setDate(day);
                d.setMonth(d.getMonth() + value);
                break;
            case this.QUARTER:
                d = this.add(date, this.MONTH, value * 3);
                break;
            case this.YEAR:
                d.setFullYear(date.getFullYear() + value);
                break;
        }
        return d;
    },
    
    
    getUnitDurationInMs : function (unit) {
        // hopefully there were no DST changes in year 1
        return this.add(new Date(1, 0, 1), unit, 1) - new Date(1, 0, 1);
    },


    getMeasuringUnit : function (unit) {
        if (unit === this.WEEK) {
            return this.DAY;
        }
        return unit;
    },


    /**
     * Returns a duration of the timeframe in the given unit.
     * @static
     * @param {Date} start The start date of the timeframe
     * @param {Date} end The end date of the timeframe
     * @param {String} unit Duration unit
     * @return {Number} The duration in the units
     */
    getDurationInUnit : function (start, end, unit, doNotRound) {
        var units;

        switch (unit) {
            case this.YEAR:
                units = this.getDurationInYears(start, end);
                break;

            case this.QUARTER:
                units = this.getDurationInMonths(start, end) / 3;
                break;

            case this.MONTH:
                units = this.getDurationInMonths(start, end);
                break;

            case this.WEEK:
                units = this.getDurationInDays(start, end) / 7;
                break;

            case this.DAY:
                units = this.getDurationInDays(start, end);
                break;

            case this.HOUR:
                units = this.getDurationInHours(start, end);
                break;

            case this.MINUTE:
                units = this.getDurationInMinutes(start, end);
                break;

            case this.SECOND:
                units = this.getDurationInSeconds(start, end);
                break;

            case this.MILLI:
                units = this.getDurationInMilliseconds(start, end);
                break;
        }

        return doNotRound ? units : Math.round(units);
    },


    getUnitToBaseUnitRatio : function (baseUnit, unit) {
        if (baseUnit === unit) {
            return 1;
        }

        switch (baseUnit) {
            case this.YEAR:
                switch (unit) {
                    case this.QUARTER:
                        return 1 / 4;

                    case this.MONTH:
                        return 1 / 12;
                }
                break;

            case this.QUARTER:
                switch (unit) {
                    case this.YEAR:
                        return 4;

                    case this.MONTH:
                        return 1 / 3;
                }
                break;

            case this.MONTH:
                switch (unit) {
                    case this.YEAR:
                        return 12;

                    case this.QUARTER:
                        return 3;
                }
                break;

            case this.WEEK:
                switch (unit) {
                    case this.DAY:
                        return 1 / 7;

                    case this.HOUR:
                        return 1 / 168;
                }
                break;

            case this.DAY:
                switch (unit) {
                    case this.WEEK:
                        return 7;

                    case this.HOUR:
                        return 1 / 24;

                    case this.MINUTE:
                        return 1 / 1440;
                }
                break;

            case this.HOUR:
                switch (unit) {
                    case this.DAY:
                        return 24;

                    case this.MINUTE:
                        return 1 / 60;
                }
                break;

            case this.MINUTE:
                switch (unit) {
                    case this.HOUR:
                        return 60;

                    case this.SECOND:
                        return 1 / 60;

                    case this.MILLI:
                        return 1 / 60000;
                }
                break;

            case this.SECOND:
                switch (unit) {
                    case this.MILLI:
                        return 1 / 1000;
                }
                break;


            case this.MILLI:
                switch (unit) {
                    case this.SECOND:
                        return 1000;
                }
                break;

        }

        return -1;
    },

    /**
     * Returns the number of milliseconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of minutes between the two dates
     * @static
     */
    getDurationInMilliseconds : function (start, end) {
        return (end - start);
    },

    /**
     * Returns the number of seconds between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of seconds between the two dates
     * @static
     */
    getDurationInSeconds : function (start, end) {
        return (end - start) / 1000;
    },

    /**
     * Returns the number of minutes between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of minutes between the two dates
     * @static
     */
    getDurationInMinutes : function (start, end) {
        return (end - start) / 60000;
    },

    /**
     * Returns the number of hours between the two dates.
     *
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of hours between the two dates
     * @static
     */
    getDurationInHours : function (start, end) {
        return (end - start) / 3600000;
    },

    /**
     * This method returns the number of days between the two dates. It assumes a day is 24 hours and tries to take the DST into account.
     * 
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} true number of days between the two dates
     * 
     * @static
     */
    getDurationInDays : function (start, end) {
        var dstDiff     = start.getTimezoneOffset() - end.getTimezoneOffset();
        
        return (end - start + dstDiff * 60 * 1000) / 86400000;
    },

    /**
     * Returns the number of whole months between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of whole months between the two dates
     * @static
     */
    getDurationInMonths : function (start, end) {
        return ((end.getFullYear() - start.getFullYear()) * 12) + (end.getMonth() - start.getMonth());
    },

    /**
     * Returns the number of years between the two dates
     * @param {Date} start Start date
     * @param {Date} end End date
     * @return {Number} The number of whole months between the two dates
     * @static
     */
    getDurationInYears : function (start, end) {
        return this.getDurationInMonths(start, end) / 12;
    },

    /**
     * Returns the lesser of the two dates
     * @param {Date} date1
     * @param {Date} date2
     * @return {Date} Returns the lesser of the two dates
     * @static
     */
    min : function (d1, d2) {
        return d1 < d2 ? d1 : d2;
    },

    /**
     * Returns the greater of the two dates
     * @param {Date} date1
     * @param {Date} date2
     * @return {Date} Returns the greater of the two dates
     * @static
     */
    max : function (d1, d2) {
        return d1 > d2 ? d1 : d2;
    },

    /**
     * Returns true if dates intersect
     * @param {Date} start1
     * @param {Date} end1
     * @param {Date} start2
     * @param {Date} end2
     * @return {Boolean} Returns true if dates intersect
     * @static
     */
    intersectSpans : function (date1Start, date1End, date2Start, date2End) {
        return this.betweenLesser(date1Start, date2Start, date2End) ||
            this.betweenLesser(date2Start, date1Start, date1End);
    },

    /**
     * Returns a name of the duration unit, matching its property on the Sch.util.Date class.
     * So, for example:
     *
     *      Sch.util.Date.getNameOfUnit(Sch.util.Date.DAY) == 'DAY' // true
     *
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getNameOfUnit : function (unit) {
        unit = this.getUnitByName(unit);

        switch (unit.toLowerCase()) {
            case this.YEAR      :
                return 'YEAR';
            case this.QUARTER   :
                return 'QUARTER';
            case this.MONTH     :
                return 'MONTH';
            case this.WEEK      :
                return 'WEEK';
            case this.DAY       :
                return 'DAY';
            case this.HOUR      :
                return 'HOUR';
            case this.MINUTE    :
                return 'MINUTE';
            case this.SECOND    :
                return 'SECOND';
            case this.MILLI     :
                return 'MILLI';
        }

        throw "Incorrect UnitName";
    },

    /**
     * Returns a human-readable name of the duration unit. For for example for `Sch.util.Date.DAY` it will return either
     * "day" or "days", depending from the `plural` argument
     * @static
     * @param {String} unit Duration unit
     * @param {Boolean} plural Whether to return a plural name or singular
     * @return {String}
     */
    getReadableNameOfUnit : function (unit, plural) {
        if (!this.isLocaleApplied()) this.applyLocale();
        return this._unitNames[ unit ][ plural ? 'plural' : 'single' ];
    },

    /**
     * Returns an abbreviated form of the name of the duration unit.
     * @static
     * @param {String} unit Duration unit
     * @return {String}
     */
    getShortNameOfUnit : function (unit) {
        if (!this.isLocaleApplied()) this.applyLocale();
        return this._unitNames[ unit ].abbrev;
    },

    getUnitByName : function (name) {
        if (!this.isLocaleApplied()) this.applyLocale();

        if (!this.unitsByName[ name ]) {
            Ext.Error.raise('Unknown unit name: ' + name);
        }

        return this.unitsByName[ name ];
    },


    /**
     * Returns the beginning of the Nth next duration unit, after the provided `date`.
     * For example for the this call:
     *      Sch.util.Date.getNext(new Date('Jul 15, 2011'), Sch.util.Date.MONTH, 1)
     *
     * will return: Aug 1, 2011
     *
     * @static
     * @param {Date} date The date
     * @param {String} unit The duration unit
     * @param {Number} increment How many duration units to skip
     * @param {Number} weekStartDay The day index of the 1st day of the week.
     *                Only required when `unit` is `WEEK`. 0 for Sunday, 1 for Monday, 2 for Tuesday, and so on (defaults to 1).
     * @return {Date} The beginning of the next duration unit interval
     */
    getNext : function (date, unit, increment, weekStartDay) {
        var dt          = Ext.Date.clone(date);

        weekStartDay    = arguments.length < 4 ? 1 : weekStartDay;
        // support 0 increment
        increment       = increment == null ? 1 : increment;

        switch (unit) {
            case this.MILLI:
                dt = this.add(date, unit, increment);
                break;

            case this.SECOND:
                dt = this.add(date, unit, increment);

                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                }
                break;

            case this.MINUTE:
                dt = this.add(date, unit, increment);

                if (dt.getSeconds() > 0) {
                    dt.setSeconds(0);
                }
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                }
                break;

            case this.HOUR:
                dt = this.add(date, unit, increment);

                // Without these checks Firefox messes up the date and it changes timezone in certain edge cases
                // See test 021_sch_util_date_dst.t.js
                if (dt.getMinutes() > 0) {
                    dt.setMinutes(0);
                }
                if (dt.getSeconds() > 0) {
                    dt.setSeconds(0);
                }
                if (dt.getMilliseconds() > 0) {
                    dt.setMilliseconds(0);
                }
                break;

            case this.DAY:
                // Check if date has 23 hrs and is in Chile timezone
                var midnightNotInTimeScale = date.getHours() === 23 && this.add(dt, this.HOUR, 1).getHours() === 1;

                if (midnightNotInTimeScale) {
                    // Correct the date manually for DST transitions happening at 00:00
                    dt = this.add(dt, this.DAY, 2);
                    this.clearTime(dt);

                    return dt;
                }

                this.clearTime(dt);

                dt = this.add(dt, this.DAY, increment);

                // Brazil timezone issue #1642, tested in 028_timeaxis_dst.t.js
                if (dt.getHours() === 1) {
                    this.clearTime(dt);
                }
                break;

            case this.WEEK:

                this.clearTime(dt);
                var day = dt.getDay();
                dt = this.add(dt, this.DAY, weekStartDay - day + 7 * (increment - (weekStartDay <= day ? 0 : 1)));

                // For south american timezones, midnight does not exist on DST transitions, adjust...
                if (dt.getDay() !== weekStartDay) {
                    dt = this.add(dt, this.HOUR, 1);
                } else {
                    this.clearTime(dt);
                }
                break;

            case this.MONTH:
                dt = this.add(dt, this.MONTH, increment);
                dt.setDate(1);
                this.clearTime(dt);
                break;

            case this.QUARTER:
                dt = this.add(dt, this.MONTH, ((increment - 1) * 3) + (3 - (dt.getMonth() % 3)));
                this.clearTime(dt);
                dt.setDate(1);
                break;

            case this.YEAR:
                dt = new Date(dt.getFullYear() + increment, 0, 1);
                break;

            default:
                throw 'Invalid date unit';
        }

        return dt;
    },


    getNumberOfMsFromTheStartOfDay : function (date) {
        return date - this.clearTime(date, true) || 86400000;
    },


    getNumberOfMsTillTheEndOfDay : function (date) {
        return this.getStartOfNextDay(date, true) - date;
    },


    getStartOfNextDay : function (date, clone, noNeedToClearTime) {
        var nextDay = this.add(noNeedToClearTime ? date : this.clearTime(date, clone), this.DAY, 1);

        // DST case
        if (nextDay.getDate() == date.getDate()) {
            var offsetNextDay   = this.add(this.clearTime(date, clone), this.DAY, 2).getTimezoneOffset();
            var offsetDate      = date.getTimezoneOffset();

            nextDay             = this.add(nextDay, this.MINUTE, offsetDate - offsetNextDay);
        }

        return nextDay;
    },

    getEndOfPreviousDay : function (date, noNeedToClearTime) {
        var dateOnly = noNeedToClearTime ? date : this.clearTime(date, true);

        // dates are different
        if (dateOnly - date) {
            return dateOnly;
        } else {
            return this.add(dateOnly, this.DAY, -1);
        }
    },

    /**
     * Returns true if the first time span completely 'covers' the second time span. E.g.
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 4)) ==> true
     *      Sch.util.Date.timeSpanContains(new Date(2010, 1, 2), new Date(2010, 1, 5), new Date(2010, 1, 3), new Date(2010, 1, 6)) ==> false
     * @static
     * @param {Date} spanStart The start date for initial time span
     * @param {Date} spanEnd The end date for initial time span
     * @param {Date} otherSpanStart The start date for the 2nd time span
     * @param {Date} otherSpanEnd The end date for the 2nd time span
     * @return {Boolean}
     */
    timeSpanContains : function (spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
        return (otherSpanStart - spanStart) >= 0 && (spanEnd - otherSpanEnd) >= 0;
    },

    /**
     * Compares two days with given precision, for example if `date1` is Aug 1st, 2014 08:00 AM and `date2` 
     * is Aug 1st, 2014 09:00 and `precisionUnit` is {@link Sch.util.Date.DAY} then both dates a considered equal
     * since they point to the same day.
     *
     * @param {Date} date1
     * @param {Date} date2
     * @param {String} [precisionUnit=Sch.util.Date.MILLI]
     * @return {Integer}
     * - -1 if `date1` is lesser than `date2`
     * - +1 if `date1` is greater than `date2`
     * -  0 if `date1` is equal to `date2`
     */
    compareWithPrecision : function(date1, date2, precisionUnit) {
        var D = Sch.util.Date,
            ED = Ext.Date,
            result;
        
        switch (precisionUnit) {
            case D.DAY:
                date1 = Number(ED.format(date1, 'Ymd'));
                date2 = Number(ED.format(date2, 'Ymd'));
                break;
            case D.WEEK:
                date1 = Number(ED.format(date1, 'YmW'));
                date2 = Number(ED.format(date2, 'YmW'));
                break;
            case D.MONTH:
                date1 = Number(ED.format(date1, 'Ym'));
                date2 = Number(ED.format(date2, 'Ym'));
                break;
            case D.QUARTER:
                date1 = date1.getFullYear() * 4 + Math.floor(date1.getMonth() / 3);
                date2 = date2.getFullYear() * 4 + Math.floor(date2.getMonth() / 3);
                break;
            case D.YEAR:
                date1 = date1.getFullYear();
                date2 = date2.getFullYear();
                break;
            default:
            case D.MILLI:
            case D.SECOND:
            case D.MINUTE:
            case D.HOUR:
                precisionUnit = precisionUnit && this.getUnitDurationInMs(precisionUnit) || 1;
                date1 = Math.floor(date1.valueOf() / precisionUnit);
                date2 = Math.floor(date2.valueOf() / precisionUnit);
                break;
        }

        ((date1 < date2) && (result = -1)) ||
        ((date1 > date2) && (result = +1)) ||
                            (result =  0);
                            
        return result;
    },

    getValueInUnits : function (date, unit) {
        switch (unit) {
            case this.MONTH : return date.getMonth();
            case this.DAY   : return date.getDate();
            case this.HOUR  : return date.getHours();
            case this.MINUTE    : return date.getMinutes();
            case this.SECOND    : return date.getSeconds();
        }
    },
    
    setValueInUnits : function (date, unit, value) {
        var result = Ext.Date.clone(date),
            f;
        
        switch (unit) {
            case this.YEAR      : f = 'setFullYear'; break;
            case this.MONTH     : f = 'setMonth'; break;
            case this.DAY       : f = 'setDate'; break;
            case this.HOUR      : f = 'setHours'; break;
            case this.MINUTE    : f = 'setMinutes'; break;
            case this.SECOND    : f = 'setSeconds'; break;
            case this.MILLI     : f = 'setMilliseconds'; break;
        }
        
        result[f](value);
        
        return result;
    },
    
    getSubUnit          : function (unit) {
        switch (unit) {
            case this.YEAR      : return this.MONTH;
            /* falls through */
            case this.MONTH     : return this.DAY;
            /* falls through */
            case this.DAY       : return this.HOUR;
            /* falls through */
            case this.HOUR      : return this.MINUTE;
            /* falls through */
            case this.MINUTE    : return this.SECOND;
            /* falls through */
            case this.SECOND    : return this.MILLI;
            /* falls through */
        }
    },
    
    setValueInSubUnits  : function (date, unit, value) {
        unit = this.getSubUnit(unit);
        return this.setValueInUnits(date, unit, value);
    },
    /*
     * section for calendar view related functions
     */
    
    mergeDates : function (target, source, unit) {
        var copy        = Ext.Date.clone(target);

        switch (unit) {
            case this.YEAR      : copy.setFullYear(source.getFullYear()); 

            /* falls through */
            case this.MONTH     : copy.setMonth(source.getMonth()); 

            /* falls through */
            case this.WEEK      :

            /* falls through */
            case this.DAY       :
                // we want to return week start day for this case
                if (unit === this.WEEK) {
                    copy = this.add(copy, this.DAY, source.getDay() - copy.getDay());
                } else {
                    copy.setDate(source.getDate());
                }

            /* falls through */
            case this.HOUR      : copy.setHours(source.getHours()); 

            /* falls through */
            case this.MINUTE    : copy.setMinutes(source.getMinutes()); 

            /* falls through */
            case this.SECOND    : copy.setSeconds(source.getSeconds());

            /* falls through */
            case this.MILLI     : copy.setMilliseconds(source.getMilliseconds());
        }
        
        return copy;
    },
    
    // splitting specified unit to subunits including start of the next span
    // e.g. week will be split to days, days to hours, etc.
    splitToSubUnits : function (start, unit, increment, weekStartDay) {
        increment       = increment || 1;
        weekStartDay    = arguments.length < 4 ? 1 : weekStartDay;
        switch (unit) {
//            case this.YEAR      : return this.splitYear(start, increment, weekStartDay);
            case this.MONTH     : return this.splitMonth(start, increment, weekStartDay);
            case this.WEEK      : //return this.splitWeek(start, increment, weekStartDay);
            /* falls through */
            case this.DAY       : return this.splitDay(start, increment);
//            case this.HOUR      : return this.splitHour(start, increment);
//            case this.MINUTE    : return this.splitMinute(start, increment);
            default : break;
        }
    },
    
    splitYear   : function (start, increment) {
        var newStart    = this.clearTime(start, true);
        newStart.setMonth(0);
        newStart.setDate(1);
        
        var result      = [];
        
        for (var i = 0; i <= 12; i = i + increment) {
            result.push(this.add(newStart, this.MONTH, i));
        }
        
        return result;
    },
    
    splitMonth  : function (start, increment, weekStartDay) {
        var newStart    = this.clearTime(start, true);
        newStart.setDate(1);
        newStart        = this.add(newStart, this.DAY, weekStartDay - newStart.getDay());
        
        var currentDate = Ext.Date.clone(newStart);
        var monthEnd    = this.add(newStart, this.MONTH, 1);
        
        var result      = [];
        
        for (var i = 0; currentDate.getTime() < monthEnd.getTime(); i = i + increment) {
            currentDate = this.add(newStart, this.WEEK, i);
            result.push(currentDate);
        }
        
        return result;
    },
    
    splitWeek   : function (start, increment, weekStartDay) {
        var newStart    = this.add(start, this.DAY, weekStartDay - start.getDay());
        newStart        = this.clearTime(newStart);
        
        var result      = [];
        
        for (var i = 0; i <= 7; i = i + increment) {
            result.push(this.add(newStart, this.DAY, i));
        }
        
        return result;
    },
    
    splitDay    : function (start, increment) {
        var copy    = this.clearTime(start, true);
        
        var result  = [];
        
        for (var i = 0; i <= 24; i = i + increment) {
            result.push(this.add(copy, this.HOUR, i));
        }

        return result;
    },
    
    splitHour   : function (start, increment) {
        var copy = new Date(start.getTime());
        copy.setMinutes(0);
        copy.setSeconds(0);
        copy.setMilliseconds(0);
        
        var result = [];
        
        for (var i = 0; i <= 60; i = i + increment) {
            result.push(this.add(copy, this.MINUTE, i));
        }
        
        return result;
    },
    
    splitMinute : function (start, increment) {
        var copy    = Ext.Date.clone(start);
        copy.setSeconds(0);
        copy.setMilliseconds(0);
        
        var result  = [];
        
        for (var i = 0; i <= 60; i = i + increment) {
            result.push(this.add(copy, this.SECOND, i));
        }
        
        return result;
    },

    // Need this to prevent some browsers (Safari in Sydney timezone) to not mess up a date
    // See tests marked *dst* and https://www.assembla.com/spaces/bryntum/tickets/1757#/activity/ticket:
    clearTime : function(dt, clone) {
        if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0) {
            return Ext.Date.clearTime(dt, clone);
        }
        
        return clone ? Ext.Date.clone(dt) : dt;
    }
});

/**
 * To analyze possible errors in your setup, include this on your HTML page and use Firebug (or any other console application) to execute line below:
 * >
 * > Sch.util.Debug.runDiagnostics();
 * > ...
 */
Ext.define("Sch.util.Debug", {
    singleton : true,

    runDiagnostics : function () {
        var log;
        var me = this;
        var C = window.console;

        if (C && C.log) {
            log = function () {
                C.log.apply(C, arguments);
            };
        } else {
            if (!me.schedulerDebugWin) {
                me.schedulerDebugWin = new Ext.Window({
                    height      : 400,
                    width       : 500,
                    bodyStyle   : 'padding:10px',
                    closeAction : 'hide',
                    autoScroll  : true
                });
            }
            me.schedulerDebugWin.show();
            me.schedulerDebugWin.update('');

            log = function (text) {
                me.schedulerDebugWin.update((me.schedulerDebugWin.body.dom.innerHTML || '') + text + '<br/>');
            };
        }

        var els = Ext.select('.sch-schedulerpanel');

        if (els.getCount() === 0) log('No scheduler component found');

        var s               = Ext.getCmp(els.elements[0].id),
            resourceStore   = s.getResourceStore(),
            eventStore      = s.getEventStore();

        if (!eventStore.isEventStore) {
            log("Your event store must be or extend Sch.data.EventStore");
        }

        log('Scheduler view start: ' + s.getStart() + ', end: ' + s.getEnd());

        if (!resourceStore) {
            log('No store configured');
            return;
        }
        if (!eventStore) {
            log('No event store configured');
            return;
        }

        var eventFields     = new Ext.util.MixedCollection(),
            resourceFields  = new Ext.util.MixedCollection();

        for (var i = 0; i < eventStore.model.prototype.fields.length; i++) {
            eventFields.add(eventStore.model.prototype.fields[i].name, eventStore.model.prototype.fields[i]);
        }

        for (i = 0; i < resourceStore.model.prototype.fields.length; i++) {
            resourceFields.add(resourceStore.model.prototype.fields[i].name, resourceStore.model.prototype.fields[i]);
        }

        log(resourceStore.getCount() + ' records in the resource store');
        log(eventStore.getCount() + ' records in the eventStore');
        var eventIdProp = eventStore.model.prototype.idProperty;
        var resourceIdProp = resourceStore.model.prototype.idProperty;

        var eventIdPropertyFound = eventFields.getByKey(eventIdProp);
        var resourceIdPropertyFound = resourceFields.getByKey(resourceIdProp);

        if (!(new eventStore.model() instanceof Sch.model.Event)) {
            log("Your event model must extend Sch.model.Event");
        }
        if (!(new resourceStore.model() instanceof Sch.model.Resource)) {
            log("Your resource model must extend Sch.model.Resource");
        }

        if (!eventIdPropertyFound) {
            log("idProperty on the event model is incorrectly setup, value: " + eventIdProp);
        }
        if (!resourceIdPropertyFound) {
            log("idProperty on the resource model is incorrectly setup, value: " + resourceIdProp);
        }

        var view = s.getSchedulingView();

        log(view.el.select(view.eventSelector).getCount() + ' events present in the DOM');

        if (eventStore.getCount() > 0) {
            if (!eventStore.first().getStartDate() || !(eventStore.first().getStartDate() instanceof Date)) {
                log('The eventStore reader is misconfigured - The StartDate field is not setup correctly, please investigate');
                log('StartDate is configured with dateFormat: ' + eventFields.getByKey(eventStore.model.prototype.startDateField).dateFormat);
                log('See Ext JS docs for information about different date formats: http://docs.sencha.com/extjs/#!/api/Ext.Date');
            }

            if (!eventStore.first().getEndDate() || !(eventStore.first().getEndDate() instanceof Date)) {
                log('The eventStore reader is misconfigured - The EndDate field is not setup correctly, please investigate');
                log('EndDate is configured with dateFormat: ' + eventFields.getByKey(eventStore.model.prototype.endDateField).dateFormat);
                log('See Ext JS docs for information about different date formats: http://docs.sencha.com/extjs/#!/api/Ext.Date');
            }

            if (eventStore.proxy && eventStore.proxy.reader && eventStore.proxy.reader.jsonData) {
                log('Dumping jsonData to console');
                console && console.dir && console.dir(eventStore.proxy.reader.rawData);
            }

            log('Records in the event store:');
            eventStore.each(function (r, i) {
                log((i + 1) + '. ' + r.startDateField + ':' + r.getStartDate() + ', ' + r.endDateField + ':' + r.getEndDate() + ', ' + r.resourceIdField + ':' + r.getResourceId());

                if (!r.getStartDate()) {
                    log(r.getStartDate());
                }
            });
        } else {
            log('Event store has no data. Has it been loaded properly?');
        }

        if (resourceStore instanceof Ext.data.TreeStore) resourceStore = resourceStore.nodeStore;

        if (resourceStore.getCount() > 0) {
            log('Records in the resource store:');
            resourceStore.each(function (r, i) {
                log((i + 1) + '. ' + r.idProperty + ':' + r.getId());
                return;
            });
        } else {
            log('Resource store has no data.');
            return;
        }

        log('Everything seems to be setup ok!');
    }
});

/**
 * @class Sch.util.DragTracker
 * @private
 *
 * Simple drag tracker with an extra useful getRegion method
 **/
Ext.define('Sch.util.DragTracker', {
    extend : 'Ext.dd.DragTracker',

    requires : [
        'Ext.util.Region'
    ],

    /**
     * @cfg {Number} xStep
     * The number of horizontal pixels to snap to when dragging
     */
    xStep : 1,

    /**
     * @cfg {Number} yStep
     * The number of vertical pixels to snap to when dragging
     */
    yStep : 1,

    /**
     * @cfg {Number} deferredActivation
     * The number of ms to defer the activation of the drag tracker
     */
    deferredActivation : 0,

    constructor : function () {

        this.callParent(arguments);

        // ScrollManager might trigger a scroll as we are dragging, trigger manual onMouseMove in this case
        this.on('dragstart', function () {
            var el = this.el;

            var listeners = {
                scroll     : this.onMouseMove,
                // We only care about single touches
                pinchstart : this.onMouseUp,
                scope      : this
            };

            el.on(listeners);

            this.on('dragend', function () {
                el.un(listeners);
            }, this, {single : true});
        });

        this.moveListener = {
            pinchstart : this.abortWait,
            touchend   : this.abortWait,
            mouseup    : this.abortWait,
            mousemove  : this.onMoveWhileWaiting,
            scope      : this,
            capture    : true
        };
    },

    /**
     * Set the number of horizontal pixels to snap to when dragging
     * @param {Number} step
     */
    setXStep : function (step) {
        this.xStep = step;
    },

    startScroll : null,

    deferTimer     : null,
    deferTolerance : 10,

    moveListener : null,

    /**
     * Set the number of vertical pixels to snap to when dragging
     * @param {Number} step
     */
    setYStep : function (step) {
        this.yStep = step;
    },

    onMoveWhileWaiting : function (e, t) {

        var xy = e.getXY();
        var s = this.startXY;

        if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > this.deferTolerance) {
            this.abortWait();
            this.onMouseUp(e);
        }
    },

    abortWait : function () {
        clearTimeout(this.deferTimer);
        this.deferTimer = null;

        Ext.getDoc().un(this.moveListener);
    },

    getRegion   : function () {
        var startXY = this.startXY,
            currentScroll = this.el.getScroll(),
            currentXY = this.getXY(),
            currentX = currentXY[0],
            currentY = currentXY[1],
            scrollLeftDelta = currentScroll.left - this.startScroll.left,
            scrollTopDelta = currentScroll.top - this.startScroll.top,
            startX = startXY[0] - scrollLeftDelta,
            startY = startXY[1] - scrollTopDelta,
            minX = Math.min(startX, currentX),
            minY = Math.min(startY, currentY),
            width = Math.abs(startX - currentX),
            height = Math.abs(startY - currentY);

        return new Ext.util.Region(minY, minX + width, minY + height, minX);
    },


    // @OVERRIDE
    onMouseDown : function (e, target) {

        // Ignore multi touches
        if (e.event.touches && e.event.touches.length > 1) return;

        // HACK - Ext calls stopPropagation which prevents global mousedown listeners on the document/body
        // which messes up blur of EventEditor plugin. See event editor tests for reference
        e.stopPropagation = Ext.emptyFn;

        this.startXY = e.getXY();

        if (this.deferredActivation) {
            var me = this;

            Ext.getDoc().on(this.moveListener);

            this.deferTimer = setTimeout(function () {
                var old = me.deferredActivation;

                // Detect moves and abort if exceeding threshold
                Ext.getDoc().un(me.moveListener);

                me.deferredActivation = false;
                me.onMouseDown(e, target);
                me.deferredActivation = old;
            }, this.deferredActivation);

            return;
        }

        this.callParent([e, target]);

        this.lastXY = this.startXY;
        this.startScroll = this.el.getScroll();
    },

    // @OVERRIDE
    // Adds support for snapping to increments while dragging
    onMouseMove : function (e, target) {
        // Bug fix required for IE
        if (this.active && e.type === 'mousemove' && Ext.isIE9m && !e.browserEvent.button) {
            e.preventDefault();
            this.onMouseUp(e);
            return;
        }

        e.preventDefault();

        var xy = e.type === 'scroll' ? this.lastXY : e.getXY(),
            s = this.startXY;

        if (!this.active) {
            if (Math.max(Math.abs(s[0] - xy[0]), Math.abs(s[1] - xy[1])) > this.tolerance) {
                this.triggerStart(e);
            } else {
                return;
            }
        }

        var x = xy[0],
            y = xy[1];

        // TODO handle if this.el is scrolled
        if (this.xStep > 1) {
            x -= this.startXY[0];
            x = Math.round(x / this.xStep) * this.xStep;
            x += this.startXY[0];
        }

        if (this.yStep > 1) {
            y -= this.startXY[1];
            y = Math.round(y / this.yStep) * this.yStep;
            y += this.startXY[1];
        }

        var snapping = this.xStep > 1 || this.yStep > 1;

        if (!snapping || x !== xy[0] || y !== xy[1]) {
            this.lastXY = [x, y];

            if (this.fireEvent('mousemove', this, e) === false) {
                this.onMouseUp(e);
            } else {
                this.onDrag(e);
                this.fireEvent('drag', this, e);
            }
        }
    }
});

/**
 * @class 
 * @static
 * @private
 * Private utility class for dealing with scroll triggering based on various mousemove events in the UI
 */
Ext.define('Sch.util.ScrollManager', {
    singleton      : true,

    vthresh        : 25,
    hthresh        : 25,
    increment      : 100,
    frequency      : 500,
    animate        : true,
    animDuration   : 200,
    activeCmp      : null,
    activeEl       : null,
    targetScroller : null,
    scrollElRegion : null,
    scrollProcess  : {},
    pt             : null,
    scrollWidth    : null,
    scrollHeight   : null,

    // "horizontal", "vertical" or "both"
    direction		: 'both',

    constructor : function () {
        this.doScroll = Ext.Function.bind(this.doScroll, this);
    },

    triggerRefresh : function () {

        if (this.activeEl) {

            this.refreshElRegion();

            this.clearScrollInterval();
            this.onMouseMove();
        }
    },

    doScroll : function () {
        var scrollProcess   = this.scrollProcess,
            scrollProcessCmp = scrollProcess.cmp,
            dir              = scrollProcess.dir[0],
            increment        = this.increment,
            scrollLeft       = this.activeCmp.getScrollX(),
            scrollTop        = this.activeCmp.getScrollY();

        // Make sure we don't scroll too far
        if (dir === 'r') {
            increment = Math.min(increment, this.scrollWidth - scrollLeft - this.activeEl.dom.clientWidth);
        } else if (dir === 'd') {
            increment = Math.min(increment, this.scrollHeight - scrollTop - this.activeEl.dom.clientHeight);
        }

        increment = Math.max(increment, 0);
        var deltaX = 0, deltaY = 0;

        if (dir === 'r') deltaX = increment;
        if (dir === 'l') deltaX = -increment;
        if (dir === 'u') deltaY = -increment;
        if (dir === 'd') deltaY = increment;

        scrollProcessCmp.scrollBy(deltaX, deltaY, {
            duration : this.animDuration,
            callback : this.triggerRefresh,
            scope    : this
        });
    },

    clearScrollInterval : function () {
        var scrollProcess = this.scrollProcess;

        if (scrollProcess.id) {
            clearTimeout(scrollProcess.id);
        }

        scrollProcess.id = 0;
        scrollProcess.cmp = null;
        scrollProcess.dir = "";
    },

	isScrollAllowed : function(dir){
		
		switch(this.direction){
			case 'both':
				return true;
				
			case 'horizontal':
				return dir === 'right' || dir === 'left';	
		
			case 'vertical':
				return dir === 'up' || dir === 'down';
				
			default:
				throw 'Invalid direction: ' + this.direction;
		
		}
		
	},

    startScrollInterval : function (cmp, dir) {

       if(!this.isScrollAllowed(dir)){
			return;
       }
        
        this.clearScrollInterval();
        this.scrollProcess.cmp = cmp;
        this.scrollProcess.dir = dir;

        this.scrollProcess.id = setTimeout(this.doScroll, this.frequency);
    },

    onMouseMove : function (e) {

        var pt = e ? e.getPoint() : this.pt,
            x = pt.x,
            y = pt.y,
            scrollProcess = this.scrollProcess,
            scrollLeft    = this.activeCmp.getScrollX(),
            scrollTop     = this.activeCmp.getScrollY(),
            id,
            cmp = this.activeCmp,
            el = this.activeEl,
            region = this.scrollElRegion,
            elDom = el.dom,
            me = this;

        this.pt = pt;

        if (region && region.contains(pt) && el.isScrollable()) {
            if (region.bottom - y <= me.vthresh && (this.scrollHeight - scrollTop - elDom.clientHeight > 0)) {

                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(this.activeCmp, "down");
                }
                return;
            } else if (region.right - x <= me.hthresh && (this.scrollWidth - scrollLeft - elDom.clientWidth > 0) ) {

                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(this.activeCmp, "right");
                }
                return;
            } else if (y - region.top <= me.vthresh && scrollTop > 0) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(this.activeCmp, "up");
                }
                return;
            } else if (x - region.left <= me.hthresh && scrollLeft > 0) {
                if (scrollProcess.cmp != cmp) {
                    this.startScrollInterval(this.activeCmp, "left");
                }
                return;
            }
        }

        this.clearScrollInterval();
    },

    refreshElRegion : function () {
        this.scrollElRegion = this.activeEl.getRegion();
    },

    // Pass an element, and optionally a direction ("horizontal", "vertical" or "both")
    activate : function (cmp, direction) {
        
        this.direction = direction || 'both';

        this.activeCmp = cmp;
        this.activeEl  = cmp.getEl();

        if (cmp.scrollManager) {
            this.targetScroller = cmp.scrollManager.scroller;

            this.scrollWidth  = this.targetScroller.getMaxPosition().x;
            this.scrollHeight = this.targetScroller.getMaxPosition().y;
        } else {
            this.scrollWidth  = this.activeEl.dom.scrollWidth;
            this.scrollHeight = this.activeEl.dom.scrollHeight;
        }

        this.refreshElRegion();
        this.activeEl.on('mousemove', this.onMouseMove, this);
    },

    deactivate : function () {
        this.clearScrollInterval();

        this.activeEl.un('mousemove', this.onMouseMove, this);
        this.targetScroller = this.activeEl = this.activeCmp = this.scrollElRegion = this.scrollWidth = this.scrollHeight = null;

        this.direction = 'both';
    }
});

/**
 * Simple caching utility.
 *
 * Internaly obtains a key value suitable to be used as object property name via {@link Sch.util.Cache#key key()}
 * method and caches a value provided under the key obtained, values with the same key are groupped
 * into single array. Cached values are obtained via {@link Sch.util.Cache#get get()} method and are managed via
 * {@link Sch.util.Cache#add add()}, {@link Sch.util.Cache#remove remove()}, {@link Sch.util.Cache#move move()},
 * {@link Sch.util.Cache#clear clear()}
 * methods.
 */
Ext.define('Sch.util.Cache', {

    cache : null,

    /**
     * @constructor
     */
    constructor : function() {
        this.cache = {};
    },

    /**
     * A function returning a key for given value.
     *
     * @param  {Mixed} v
     * @return {String}
     * @template
     */
    key : function(v) {
        var result;

        if (v instanceof Ext.data.Model) {
            result = v.getId().toString();
        }
        else if (v === undefined || v === null) {
            result = "[ undefined / null ]";
        }
        else {
            result = (v).toString();
        }

        return result;
    },

    /**
     * Returns all values cached with a given key, or if key isn't present executes a given function, caches
     * it's result (which should be array) after it's mapped over {@link #map} and returns it.
     *
     * *Warning*: the array returned must not be modified otherwise cache integrity will be violated.
     *
     * @param {Mixed} k
     * @param {Function} [fn]
     * @param {[Mixed]}  [fn.return]
     * @return {[Mixed]}
     */
    get : function(k, fn) {
        var me = this,
            result;

        k = me.key(k);

        result = me.cache.hasOwnProperty(k) && me.cache[k];

        if (!result && fn) {
            result = fn();
        }
        else if (!result) {
            result = [];
        }

        me.cache[k] = result;

        return result;
    },

    /**
     * Caches a value using either a key provided or a key obtained from {@link #key key()} method.
     *
     * @param {Mixed} k
     * @param {Mixed} v
     * @chainable
     */
    add : function(k, v) {
        var me = this,
            kAdopted = me.key(k);

        if (!me.cache.hasOwnProperty(kAdopted)) {
            me.cache[kAdopted] = me.get(k); // initial key cache filling
        }

        Ext.Array.include(me.cache[kAdopted], v);

        return me;
    },

    /**
     * Removes cached value from cache under a given key or under a key obtained from {@link #key key()} method.
     *
     * @param {Mixed} k
     * @param {Mixed} v
     * @chainable
     */
    remove : function(k, v) {
        var me = this;

        k = me.key(k);

        if (me.cache.hasOwnProperty(k)) {
            Ext.Array.remove(me.cache[k], v);
        }

        return me;
    },

    /**
     * Moves all items or a single item under old key to new key
     *
     * @param {Mixed} oldKey
     * @param {Mixed} newKey
     */
    move : function(oldKey, newKey, v) {
        var me = this;

        oldKey = me.key(oldKey);
        newKey = me.key(newKey);

        if (oldKey != newKey && arguments.length >= 3) {
            me.remove(oldKey, v);
            me.add(newKey, v);
        }
        else if (oldKey != newKey && me.cache.hasOwnProperty(oldKey) && me.cache.hasOwnProperty(newKey)) {
            me.cache[newKey] = Ext.Array.union(me.cache[newKey], me.cache[oldKey]);
            me.cache[oldKey] = [];
        }
        else if (oldKey != newKey && me.cache.hasOwnProperty(oldKey)) {
            me.cache[newKey] = me.cache[oldKey];
            me.cache[oldKey] = [];
        }
    },

    /**
     * Clears entire cache, or clears cache for a given key.
     *
     * @param {Mixed} [k]
     * @chainable
     */
    clear : function(k) {
        var me = this;

        if (!arguments.length) {
            me.cache = {};
        }
        else {
            k = me.key(k);
            if (me.cache.hasOwnProperty(k)) {
                delete me.cache[k];
            }
        }

        return me;
    },

    /**
     * Removes value from entire cache (from every key it exists under).
     *
     * @param {Mixed} v
     * @chanable
     */
    uncache : function(v) {
        var me = this,
            k;

        for (k in me.cache) {
            if (me.cache.hasOwnProperty(k)) {
                me.cache[k] = Ext.Array.remove(me.cache[k], v);
            }
        }

        return me;
    }
});

/**
@class Sch.preset.ViewPreset
Not used directly, but the properties below are rather provided inline as seen in the source of {@link Sch.preset.Manager}. This class is just provided for documentation purposes.

A sample preset looks like:

    hourAndDay : {
        timeColumnWidth         : 60,       // Time column width (used for rowHeight in vertical mode)
        rowHeight               : 24,       // Only used in horizontal orientation
        resourceColumnWidth     : 100,      // Only used in vertical orientation

        displayDateFormat       : 'G:i',    // Controls how dates will be displayed in tooltips etc

        shiftIncrement          : 1,        // Controls how much time to skip when calling shiftNext and shiftPrevious.
        shiftUnit               : "DAY",    // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
        defaultSpan             : 12,       // By default, if no end date is supplied to a view it will show 12 hours

        timeResolution          : {         // Dates will be snapped to this resolution
            unit        : "MINUTE",         // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            increment   : 15
        },

        headerConfig            : {         // This defines your header, you must include a "middle" object, and top/bottom are optional.
            middle      : {                 // For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                unit        : "HOUR",
                dateFormat  : 'G:i'
            },
            top         : {
                unit        : "DAY",
                dateFormat  : 'D d/m'
            }
        },

        linesFor                : 'middle'  // Defines header level column lines will be drawn for
    },

See the {@link Sch.preset.Manager} for the list of available presets.

*/
Ext.define("Sch.preset.ViewPreset", {
    name                : null,

    /**
     * @cfg {Number} rowHeight The height of the row in horizontal orientation
     */
    rowHeight           : null,

    /**
     * @cfg {Number} timeColumnWidth The width of the time tick column in horizontal orientation. Also used as height of time tick row
     * in vertical orientation, unless {@link #timeRowHeight} is provided.
     */
    timeColumnWidth     : 50,

    /**
     * @cfg {Number} timeRowHeight The height of the time tick row in vertical orientation. If omitted, a value of {@link #timeColumnWidth}
     * is used.
     */
    timeRowHeight       : null,

    /**
     * @cfg {Number} timeAxisColumnWidth The width of the time axis column in the vertical orientation
     */
    timeAxisColumnWidth : null,

    /**
    * @cfg {String} displayDateFormat Defines how dates will be formatted in tooltips etc
    */
    displayDateFormat   : 'G:i',

    /**
     * @cfg {String} shiftUnit The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.
     * Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
     */
    shiftUnit           : "HOUR",

    /**
     * @cfg {Number} shiftIncrement The amount to shift (in shiftUnits)
     */
    shiftIncrement      : 1,

    /**
     * @cfg {Number} defaultSpan The amount of time to show by default in a view (in the unit defined by the middle header)
     */
    defaultSpan         : 12,

    /**
     * @cfg {Object} timeResolution An object containing a unit identifier and an increment variable. Example:
     *
        timeResolution : {
            unit        : "HOUR",  //Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            increment   : 1
        }
     *
     */
    timeResolution      : null,

    /**
     * @cfg {Object} headerConfig An object containing one or more {@link Sch.preset.ViewPresetHeaderRow} rows defining how your headers shall be composed.
     * Your 'main' unit should be the middle header unit. This object can contain "bottom", "middle" and "top" header definitions. The 'middle' header is mandatory.
     */
    headerConfig        : null,

    /**
     * @cfg {String} columnLinesFor Defines the header level that the column lines will be drawn for. See {@link Sch.mixin.AbstractTimelinePanel#columnLines}
     */
    columnLinesFor            : 'middle',

    // internal properties
    headers             : null,
    mainHeader          : 0,


    constructor : function (config) {
        Ext.apply(this, config);
    },

    getHeaders : function () {
        if (this.headers) return this.headers;

        var headerConfig        = this.headerConfig;

        this.mainHeader         = headerConfig.top ? 1 : 0;

        return this.headers     = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
    },


    getMainHeader : function () {
        return this.getHeaders()[ this.mainHeader ];
    },


    getBottomHeader : function () {
        var headers     = this.getHeaders();

        return headers[ headers.length - 1 ];
    },


    clone : function () {
        var config      = {};
        var me          = this;

        Ext.each([
            'rowHeight',
            'timeColumnWidth',
            'timeRowHeight',
            'timeAxisColumnWidth',
            'displayDateFormat',
            'shiftUnit',
            'shiftIncrement',
            'defaultSpan',
            'timeResolution',
            'headerConfig'
        ], function (name) {
            config[ name ] = me[ name ];
        });

        return new this.self(Ext.clone(config));
    }
});

/**
@class Sch.preset.Manager
@singleton

Provides a registry of the possible view presets that any instance of a Panel with {@link Sch.mixin.SchedulerPanel} mixin can use.

See the {@link Sch.preset.ViewPreset} and {@link Sch.preset.ViewPresetHeaderRow} classes for a description of the view preset properties.

Available presets are:

- `minuteAndHour` - creates 2 level headers - hour and minutes within it
- `hourAndDay` - creates 2 level headers - day and hours within it: {@img scheduler/images/hourAndDay.png}
- `dayAndWeek` - creates 2 level headers - week and days within it: {@img scheduler/images/dayAndWeek.png}
- `weekAndDay` - just like `dayAndWeek` but with different formatting: {@img scheduler/images/weekAndDay.png}
- `weekAndMonth` - creates 2 level headers - month and weeks within it: {@img scheduler/images/weekAndMonth.png}

- `monthAndYear` - creates 2 level headers - year and months within it: {@img scheduler/images/monthAndYear.png}
- `year` - creates 2 level headers - year and quarters within it: {@img scheduler/images/year-preset.png}
- `weekAndDayLetter` - creates a 2 level header - with weeks and day letters within it.
- `weekDateAndMonth` - creates 2 level headers - month and weeks within it (weeks shown by first day only): {@img scheduler/images/weekDateAndMonth.png}

You can register your own preset with the {@link #registerPreset} call

*/
Ext.define('Sch.preset.Manager', {
    extend: 'Ext.util.MixedCollection',
    requires: [
        'Sch.util.Date',
        'Sch.preset.ViewPreset'
    ],
    mixins: ['Sch.mixin.Localizable'],

    singleton: true,

    defaultPresets : {
        secondAndMinute : {
            timeColumnWidth     : 30,   // Time column width (used for rowHeight in vertical mode)
            rowHeight           : 24,    // Only used in horizontal orientation
            resourceColumnWidth : 100,   // Only used in vertical orientation
            displayDateFormat   : 'G:i:s', // Controls how dates will be displayed in tooltips etc
            shiftIncrement      : 10,     // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit           : 'MINUTE',// Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan         : 24,    // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution      : {      // Dates will be snapped to this resolution
                unit        : 'SECOND',  // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment   : 5
            },
            headerConfig        : {      // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle  : {
                    unit        : 'SECOND',
                    increment   : 10,
                    align       : 'center',
                    dateFormat  : 's'
                },
                top     : {
                    unit        : 'MINUTE',
                    align       : 'center',
                    dateFormat  : 'D, d g:iA'
                }
            }
        },
        minuteAndHour : {
            timeColumnWidth     : 100,   // Time column width (used for rowHeight in vertical mode)
            rowHeight           : 24,    // Only used in horizontal orientation
            resourceColumnWidth : 100,   // Only used in vertical orientation
            displayDateFormat   : 'G:i', // Controls how dates will be displayed in tooltips etc
            shiftIncrement      : 1,     // Controls how much time to skip when calling shiftNext and shiftPrevious.
            shiftUnit           : 'HOUR',// Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
            defaultSpan         : 24,    // By default, if no end date is supplied to a view it will show 24 hours
            timeResolution      : {      // Dates will be snapped to this resolution
                unit        : 'MINUTE',  // Valid values are "MILLI", "SECOND", "MINUTE", "HOUR", "DAY", "WEEK", "MONTH", "QUARTER", "YEAR".
                increment   : 30
            },
            headerConfig        : {      // This defines your header, you must include a "middle" object, top/bottom are optional. For each row you can define "unit", "increment", "dateFormat", "renderer", "align", and "scope"
                middle  : {
                    unit        : 'MINUTE',
                    increment   : '30',
                    align       : 'center',
                    dateFormat  : 'i'
                },
                top     : {
                    unit        : 'HOUR',
                    align       : 'center',
                    dateFormat  : 'D, gA/d'
                }
            }
        },
        hourAndDay : {
            timeColumnWidth     : 60,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'G:i',
            shiftIncrement      : 1,
            shiftUnit           : 'DAY',
            defaultSpan         : 24,
            timeResolution      : {
                unit        : 'MINUTE',
                increment   : 30
            },
            headerConfig        : {
                middle      : {
                    unit        : 'HOUR',
                    align       : 'center',
                    dateFormat  : 'G:i'
                },
                top         : {
                    unit        : 'DAY',
                    align       : 'center',
                    dateFormat  : 'D d/m'
                }
            }
        },
        dayAndWeek : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d G:i',
            shiftUnit           : 'DAY',
            shiftIncrement      : 1,
            defaultSpan         : 5,
            timeResolution      : {
                unit        : 'HOUR',
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : 'DAY',
                    align       : 'center',
                    dateFormat  : 'D d M'
                },
                top : {
                    unit        : 'WEEK',
                    align       : 'center',
                    renderer    : function(start, end, cfg) {
                        return Sch.util.Date.getShortNameOfUnit('WEEK') + '.' + Ext.Date.format(start, 'W M Y');
                    }
                }
            }
        },

        weekAndDay : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : 'WEEK',
            shiftIncrement      : 1,
            defaultSpan         : 1,
            timeResolution      : {
                unit        : 'DAY',
                increment   : 1
            },
            headerConfig        : {
                bottom : {
                    unit        : 'DAY',
                    align       : 'center',
                    increment   : 1,
                    dateFormat  : 'd/m'
                },
                middle : {
                    unit        : 'WEEK',
                    dateFormat  : 'D d M'
                }
            }
        },

        weekAndMonth : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : 'WEEK',
            shiftIncrement      : 5,
            defaultSpan         : 6,
            timeResolution      : {
                unit        : 'DAY',
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit    : 'WEEK',
                    renderer: function(start, end, cfg) {
                        return Ext.Date.format(start, 'd M');
                    }
                },
                top         : {
                    unit        : 'MONTH',
                    align       : 'center',
                    dateFormat  : 'M Y'
                }
            }
        },

        monthAndYear : {
            timeColumnWidth     : 110,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftIncrement      : 3,
            shiftUnit           : 'MONTH',
            defaultSpan         : 12,
            timeResolution      : {
                unit        : 'DAY',
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : 'MONTH',
                    align       : 'center',
                    dateFormat  : 'M Y'
                },
                top         : {
                    unit        : 'YEAR',
                    align       : 'center',
                    dateFormat  : 'Y'
                }
            }
        },
        year : {
            timeColumnWidth     : 100,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : 'YEAR',
            shiftIncrement      : 1,
            defaultSpan         : 1,
            timeResolution      : {
                unit        : 'MONTH',
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : 'QUARTER',
                    align       : 'center',
                    renderer    : function(start, end, cfg) {
                        return Ext.String.format(Sch.util.Date.getShortNameOfUnit('QUARTER').toUpperCase() + '{0}', Math.floor(start.getMonth() / 3) + 1);
                    }
                },
                top         : {
                    unit        : 'YEAR',
                    align       : 'center',
                    dateFormat  : 'Y'
                }
            }
        },
        manyYears : {
            timeColumnWidth     : 50,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : 'YEAR',
            shiftIncrement      : 1,
            defaultSpan         : 1,
            timeResolution      : {
                unit        : 'YEAR',
                increment   : 1
            },
            headerConfig        : {
                middle      : {
                    unit        : 'YEAR',
                    align       : 'center',
                    dateFormat  : 'Y',
                    increment   : 5
                },
                // smallest zoom level looked back
                // we have to specify increments here since 'increment' in zoomLevel affects only bottom header
                bottom      : {
                    unit        : 'YEAR',
                    align       : 'center',
                    dateFormat  : 'y',
                    increment   : 1
                }
            }
        },
        weekAndDayLetter : {
            timeColumnWidth     : 20,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : 'WEEK',
            shiftIncrement      : 1,
            defaultSpan         : 10,
            timeResolution      : {
                unit        : 'DAY',
                increment   : 1
            },
            headerConfig        : {
                bottom  : {
                    unit        : 'DAY',
                    align       : 'center',
                    renderer    : function(start) {
                        return Ext.Date.dayNames[start.getDay()].substring(0, 1);
                    }
                },
                middle          : {
                    unit        : 'WEEK',
                    dateFormat  : 'D d M Y'
                }
            }
        },
        weekDateAndMonth : {
            timeColumnWidth     : 30,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'Y-m-d',
            shiftUnit           : 'WEEK',
            shiftIncrement      : 1,
            defaultSpan         : 10,
            timeResolution      : {
                unit        : 'DAY',
                increment   : 1
            },
            headerConfig : {
                middle      : {
                    unit        : 'WEEK',
                    align       : 'center',
                    dateFormat  : 'd'
                },
                top         : {
                    unit        : 'MONTH',
                    dateFormat  : 'Y F'
                }
            }
        },

        day : {
            timeRowHeight       : 40,
            calendarColumnWidth : 200,
            displayDateFormat   : 'G:i',
            shiftIncrement      : 1,
            shiftUnit           : 'DAY',
            defaultSpan         : 24,
            timeResolution      : {
                unit        : 'MINUTE',
                increment   : 30
            },
            headerConfig        : {
                bottom  : {
                    unit        : 'HOUR',
                    align       : 'center',
                    renderer    : function (value) {
                        return Ext.String.format(
                            '<div class="sch-calendarcolumn-ct"><span class="sch-calendarcolumn-hours">{0}</span>' +
                            '<span class="sch-calendarcolumn-minutes">{1}</span></div>',
                            Ext.Date.format(value, 'H'),
                            Ext.Date.format(value, 'i')
                        );
                    }
                },
                middle  : {
                    unit        : 'DAY',
                    align       : 'center',
                    dateFormat  : 'D d/m',
                    splitUnit   : 'DAY'
                }
            }
        },

        week : {
            timeRowHeight       : 40,
            calendarColumnWidth : 164,
            displayDateFormat   : 'G:i',
            shiftIncrement      : 1,
            shiftUnit           : 'WEEK',
            defaultSpan         : 24,
            timeResolution      : {
                unit        : 'MINUTE',
                increment   : 30
            },
            headerConfig        : {
                bottom  : {
                    unit        : 'HOUR',
                    align       : 'center',
                    dateFormat  : 'H:i',    // will be overridden by renderer
                    renderer    : function (value) {
                        return Ext.String.format(
                            '<div class="sch-calendarcolumn-ct">' +
                                '<span class="sch-calendarcolumn-hours">{0}</span>' +
                                '<span class="sch-calendarcolumn-minutes">{1}</span>' +
                            '</div>',

                            Ext.Date.format(value, 'H'),
                            Ext.Date.format(value, 'i')
                        );
                    }
                },
                middle  : {
                    unit        : 'WEEK',
                    align       : 'center',
                    dateFormat  : 'D d',
                    splitUnit   : 'DAY'
                }
            }
        },

        month : {
            timeColumnWidth     : 60,
            rowHeight           : 24,
            resourceColumnWidth : 100,
            displayDateFormat   : 'G:i',
            shiftIncrement      : 1,
            shiftUnit           : 'MONTH',
            defaultSpan         : 4,
            timeResolution      : {
                unit        : 'HOUR',
                increment   : 12
            },
            headerConfig        : {
                bottom  : {
                    unit        : 'DAY',
                    align       : 'center',
                    dateFormat  : 'D',
                    splitUnit   : 'WEEK'
                },
                middle  : {
                    unit        : 'WEEK',
                    align       : 'center',
                    dateFormat  : 'D d/m'
                },
                top     : {
                    unit        : 'MONTH',
                    align       : 'center',
                    renderer    : function(start, end, cfg) {
                        return Ext.Date.format(start, 'd/m') + ' - ' + Ext.Date.format(end, 'd/m, Y');
                    },
                    splitUnit   : 'WEEK'
                }
            }
        }
    },

    constructor : function() {
        this.callParent(arguments);
        this.registerDefaults();
    },

    onLocalized : function () {
        var me = this;

        this.eachKey(function (name, preset) {
            if (me.l10n[name]) {
                var locale  = me.L(name);

                locale.displayDateFormat && (preset.displayDateFormat = locale.displayDateFormat);
                locale.middleDateFormat && (preset.headerConfig.middle.dateFormat = locale.middleDateFormat);
                locale.topDateFormat && (preset.headerConfig.top.dateFormat = locale.topDateFormat);
                locale.bottomDateFormat && (preset.headerConfig.bottom.dateFormat = locale.bottomDateFormat);
            }
        });
    },

    /**
    * Registers a new view preset to be used by any scheduler grid or tree on the page.
    * @param {String} name The unique name identifying this preset
    * @param {Object} config The configuration properties of the view preset (see {@link Sch.preset.ViewPreset} for more information)
    */
    registerPreset : function(name, cfg) {
        if (cfg) {
            var headerConfig    = cfg.headerConfig;
            var DATE            = Sch.util.Date;

            // Make sure date "unit" constant specified in the preset are resolved
            for (var o in headerConfig) {
                if (headerConfig.hasOwnProperty(o)) {
                    if (DATE[headerConfig[o].unit]) {
                        headerConfig[o].unit = DATE[headerConfig[o].unit.toUpperCase()];
                    }

                    if (DATE[headerConfig[o].splitUnit]) {
                        headerConfig[o].splitUnit = DATE[headerConfig[o].splitUnit.toUpperCase()];
                    }
                }
            }

            if (!cfg.timeColumnWidth) cfg.timeColumnWidth = 50;
            if (!cfg.rowHeight) cfg.rowHeight = 24;

            var timeResolution  = cfg.timeResolution;

            // Resolve date units
            if (timeResolution && DATE[ timeResolution.unit ]) {
                timeResolution.unit = DATE[ timeResolution.unit.toUpperCase() ];
            }

            var shiftUnit       = cfg.shiftUnit;

            // Resolve date units
            if (shiftUnit && DATE[ shiftUnit ]) {
                cfg.shiftUnit = DATE[ shiftUnit.toUpperCase() ];
            }
        }

        if (this.isValidPreset(cfg)) {
            if (this.containsKey(name)) this.removeAtKey(name);

            cfg.name        = name;

            this.add(name, new Sch.preset.ViewPreset(cfg));
        } else {
            throw 'Invalid preset, please check your configuration';
        }
    },

    isValidPreset : function(cfg) {
        var D = Sch.util.Date,
            valid = true,
            validUnits = Sch.util.Date.units,
            ownKeys = {};

        // Make sure all date "unit" constants are valid
        for (var o in cfg.headerConfig) {
            if (cfg.headerConfig.hasOwnProperty(o)) {
                ownKeys[o] = true;
                valid = valid && Ext.Array.indexOf(validUnits, cfg.headerConfig[o].unit) >= 0;
            }
        }

        if (!(cfg.columnLinesFor in ownKeys)) {
            cfg.columnLinesFor = 'middle';
        }

        if (cfg.timeResolution) {
            valid = valid && Ext.Array.indexOf(validUnits, cfg.timeResolution.unit) >= 0;
        }

        if (cfg.shiftUnit) {
            valid = valid && Ext.Array.indexOf(validUnits, cfg.shiftUnit) >= 0;
        }

        return valid;
    },

    /**
    * Fetches a view preset from the global cache
    * @param {String} name The name of the preset
    * @return {Object} The view preset, see {@link Sch.preset.ViewPreset} for more information
    */
    getPreset : function(name) {
        return this.get(name);
    },

    /**
    * Deletes a view preset
    * @param {String} name The name of the preset
    */
    deletePreset : function(name) {
        this.removeAtKey(name);
    },

    registerDefaults : function() {
        var pm = this,
            vp = this.defaultPresets;

        for (var p in vp) {
            pm.registerPreset(p, vp[p]);
        }
    }
});
/**
@class Sch.feature.AbstractTimeSpan
@extends Ext.AbstractPlugin

Plugin for visualizing "global" time span in the scheduler grid, these can by styled easily using just CSS. This is an abstract class not intended for direct use.

*/

if (!Ext.ClassManager.get("Sch.feature.AbstractTimeSpan")) {

Ext.define("Sch.feature.AbstractTimeSpan", {
    extend              : 'Ext.AbstractPlugin',
    
    mixins              : {
        observable      : 'Ext.util.Observable'
    },
    
    lockableScope       : 'top',
    
    schedulerView       : null,
    timeAxis            : null,
    containerEl         : null,
    
    // If lines/zones should stretch to fill the whole view container element in case the table does not fill it
    expandToFitView     : false,
    
    disabled            : false,
    
    /**
     * @property {String} cls An internal css class which is added to each rendered timespan element
     * @private
     */
    cls                 : null,
    
    /**
     * @cfg {String} clsField Name of field  
     */
    clsField            : 'Cls',
    
    /**
     * @cfg {Ext.XTemplate} template Template to render the timespan elements  
     */
    template            : null,
    
    /**
     * @cfg {Ext.data.Store/String} store A store with timespan data, or a string identifying a store.
     */
    store               : null,
    
    renderElementsBuffered      : false,
    
    /**
     * @cfg {Number} renderDelay Delay the zones rendering by this amount (in ms) to speed up the default rendering of rows and events.
     */
    renderDelay                 : 15,

    // true to refresh the sizes of the rendered elements when an item in the bound view changes
    // false to do a full refresh instead
    refreshSizeOnItemUpdate     : true,

    _resizeTimer                : null,
    _renderTimer                : null,
    
    /**
     * @cfg {Boolean} showHeaderElements Set this to `true` to show indicators in the timeline header area.
     * 
     * Header indicators are placed right above the corresponding element of the scheduling view. You can customize the HTML markup
     * for these indicators with the {@link #headerTemplate} config. Note that the indicators are rendered as a regular div element,
     * which will be styled differently in modern vs legacy browsers.
     *
     */
    showHeaderElements          : false,
    
    /**
     * @private
     * @cfg {Ext.XTemplate} headerTemplate Template used to render the header elements
     */
    headerTemplate              : null,
    
    
    /**
     * @cfg {String/Ext.XTemplate} innerHeaderTpl A template providing additional markup to render into each timespan header element
     */
    innerHeaderTpl              : null,
    
    headerContainerCls          : 'sch-header-secondary-canvas',
    headerContainerEl           : null,
    
    // event to be fired, when rendering has completed (only fired when all elements are rendered, not single)
    renderingDoneEvent          : null,
    

    constructor : function(cfg) {
        // unique css class to be able to identify only the zones belonging to this plugin instance
        this.uniqueCls = this.uniqueCls || ('sch-timespangroup-' + Ext.id());
        
        Ext.apply(this, cfg);
        
        this.mixins.observable.constructor.call(this);

        this.callParent(arguments);
    },

    
    /**
     * @param {Boolean} disabled Pass `true` to disable the plugin and remove all rendered elements.
     */
    setDisabled : function(disabled) {
        if (disabled) {
            this.removeElements();
        }
        
        this.disabled = disabled;
    },

    
    removeElements : function () {
        this.removeBodyElements();
        
        if (this.showHeaderElements) {
            this.removeHeaderElements();
        }
    },
    
    //Returns the currently rendered DOM elements of this plugin (if any), as a {@link Ext.CompositeElementLite} collection.
    getBodyElements : function() {
        if (this.containerEl) {
            return this.containerEl.select('.' + this.uniqueCls);
        }

        return null;
    },
    
    /**
     * Returns container to render header elements.
     * 
     * @return {Ext.dom.Element}
     */
    getHeaderContainerEl : function() {
        var containerEl = this.headerContainerEl,
            prefix = Ext.baseCSSPrefix,
            parent;
            
        if (!containerEl || !containerEl.dom) {
            if (this.schedulerView.isHorizontal()) {
                parent = this.panel.getHorizontalTimeAxisColumn().headerView.containerEl;
            } else {
                parent = this.panel.el.down('.' + prefix + 'grid-inner-locked' +
                    ' .' + prefix + 'panel-body' +
                    ' .' + prefix + 'grid-view');
            }
            
            if (parent) {
                containerEl = parent.down('.' + this.headerContainerCls);
                
                if (!containerEl) {
                    containerEl = parent.appendChild({
                        cls : this.headerContainerCls
                    });
                }
                
                this.headerContainerEl = containerEl;
            }
        }

        return containerEl;
    },
    
    
    getHeaderElements : function() {
        var containerEl = this.getHeaderContainerEl();
        
        if (containerEl) {
            return containerEl.select('.' + this.uniqueCls);
        }

        return null;
    },
    
    
    // private
    removeBodyElements : function() {
        var els = this.getBodyElements();
        
        if (els) {
            els.each(function(el) { el.destroy(); });
        }
    },
    
    
    removeHeaderElements : function() {
        var els = this.getHeaderElements();
        
        if (els) {
            els.each(function(el) { el.destroy(); });
        }
    },
    
    /**
     * Returns id of element for data record.
     * 
     * @param {Ext.data.Model} record
     * 
     * @return {String}
     */
    getElementId : function(record) {
        return this.uniqueCls + '-' + record.internalId;
    },
    
    /**
     * Returns id of header element for data record.
     * 
     * @param {Ext.data.Model} record
     * 
     * @return {String}
     */
    getHeaderElementId : function(record) {
        return this.uniqueCls + '-header-' + record.internalId;
    },
    
    /**
     * Returns template data to render elements.
     * 
     * @param {Ext.data.Model} record
     * 
     * @return {Object}
     */
    getTemplateData : function(record) {
        return this.prepareTemplateData ? this.prepareTemplateData(record) : record.data;
    },
    
    
    /**
     * Return element class for a record.
     * 
     * @param {Ext.data.Model} record Data record
     * @param {Object} data Template data
     * 
     * @return {String}
     */
    getElementCls : function(record, data) {
        var clsField = record.clsField || this.clsField;
            
        if (!data) {
            data = this.getTemplateData(record);
        }
        
        return this.cls + ' ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    
    
    /**
     * Return header element class for data record.
     * 
     * @param {Ext.data.Model} record Data record
     * @param {Object} data
     * 
     * @return {String}
     */
    getHeaderElementCls : function(record, data) {
        var clsField = record.clsField || this.clsField;
            
        if (!data) {
            data = this.getTemplateData(record);
        }

        return 'sch-header-indicator ' + this.uniqueCls + ' ' + (data[clsField] || '');
    },
    
    
    init:function(scheduler) {
        // TODO COMMENT
        if (Ext.versions.touch && !scheduler.isReady()) {
            scheduler.on('viewready', function() { this.init(scheduler); }, this);
            return;
        }
        
        if (Ext.isString(this.innerHeaderTpl)) {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        
        var innerHeaderTpl = this.innerHeaderTpl;
        
        if (!this.headerTemplate) {
            this.headerTemplate = new Ext.XTemplate(
                '<tpl for=".">',
                    '<div id="{id}" class="{cls}" style="{side}:{position}px;">' +
                    (innerHeaderTpl ? '{[this.renderInner(values)]}' : '') +
                    '</div>',
                '</tpl>',
                {
                    renderInner : function(values) {
                        return innerHeaderTpl.apply(values);
                    }
                }
            );
        }

        this.schedulerView = scheduler.getSchedulingView(); 
        this.panel = scheduler;
        this.timeAxis = scheduler.getTimeAxis();

        this.store = Ext.StoreManager.lookup(this.store);

        if (!this.store) {
            Ext.Error.raise("Error: You must define a store for this plugin");
        }

        if (!this.schedulerView.getEl()) {
            this.schedulerView.on({
                afterrender : this.onAfterRender, 
                scope       : this
            });
        } else {
            this.onAfterRender();
        }
    },
    
    
    onAfterRender : function (scheduler) {
        var view            = this.schedulerView;
        this.containerEl    = view.getSecondaryCanvasEl();

        this.storeListeners = {
            load            : this.renderElements,
            datachanged     : this.renderElements, 
            clear           : this.renderElements,
            
            // Ext JS
            add             : this.renderElements,
            remove          : this.renderElements, 
            update          : this.refreshSingle, 
            
            // Sencha Touch
            addrecords      : this.renderElements,
            removerecords   : this.renderElements,
            updaterecord    : this.refreshSingle,

            // Tree Store
            expand          : this.renderElements,
            collapse        : this.renderElements,

            scope           : this
        };

        this.store.on(this.storeListeners);

        view.on({
            bufferedrefresh     : this.renderElements,
            refresh             : this.renderElements,
            itemadd             : this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,
            itemremove          : this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,
            itemupdate          : this.refreshSizeOnItemUpdate ? this.refreshSizes : this.renderElements,

            // start grouping events
            groupexpand         : this.renderElements, 
            groupcollapse       : this.renderElements,
            
            columnwidthchange   : this.renderElements,
            resize              : this.renderElements,

            scope               : this
        });

        if (view.headerCt) {
            view.headerCt.on({
                add         : this.renderElements,
                remove      : this.renderElements,
                scope       : this
            });
        }

        this.panel.on({
            viewchange          : this.renderElements,
            show                : this.refreshSizes,
            modechange          : this.forceNewRenderingTimeout,
            
            scope               : this
        });
        
        var rowContainer = view.getRowContainerEl();

        if (rowContainer && rowContainer.down('.sch-timetd')) {
            this.renderElements();
        }
    },
    
    
    forceNewRenderingTimeout : function () {
        this.renderElementsBuffered = false;
        
        clearTimeout(this._renderTimer);
        clearTimeout(this._resizeTimer);

        this.renderElements();
    },

    
    refreshSizesInternal : function() {
        // This can only be called in Horizontal mode
        if (!this.schedulerView.isDestroyed && this.schedulerView.isHorizontal()) {
    
            // Date here is irrelevant, we just want a fresh height value
            var region = this.schedulerView.getTimeSpanRegion(new Date(), null, this.expandToFitView);
            this.getBodyElements().setHeight(region.bottom - region.top);
        }
    },
    
    refreshSizes : function() {
        clearTimeout(this._resizeTimer);

        this._resizeTimer = Ext.Function.defer(this.refreshSizesInternal, this.renderDelay, this);
    },

    
    renderElements : function() {
        if (this.renderElementsBuffered || this.disabled) return;

        this.renderElementsBuffered = true;

        clearTimeout(this._renderTimer);
        
        // Defer to make sure rendering is not delayed by this plugin
        // deferring on 15 because the cascade delay is 10 (cascading will trigger a view refresh)
        this._renderTimer = Ext.Function.defer(this.renderElementsInternal, this.renderDelay, this);
    },
    
    
    /**
     * Sets element X-coordinate relative direction (rtl or ltr).
     * 
     * @param {Ext.Element} el
     * @param {Number} x
     */
    setElementX : function(el, x) {
        if (this.panel.rtl) {
            el.setRight(x);
        } else {
            el.setLeft(x);
        }
    },

    /**
     * Returns position of header element by date.
     * 
     * @param {Date} date
     * 
     * @return {Number}
     */
    getHeaderElementPosition : function(date) {
        var viewModel = this.schedulerView.getTimeAxisViewModel();
        
        return Math.round(viewModel.getPositionFromDate(date));
    },
    
    
    renderBodyElementsInternal : function (records) {
        Ext.DomHelper.append(this.containerEl, this.generateMarkup(false, records));
    },
    
    
    getHeaderElementData : function(records, isPrint) {
        throw 'Abstract method call';
    },
    
    
    renderHeaderElementsInternal : function (records) {
        var containerEl = this.getHeaderContainerEl();
        
        if (containerEl) {
            Ext.DomHelper.append(containerEl, this.generateHeaderMarkup(false, records));
        }
    },
    
 
    renderElementsInternal : function() {
        this.renderElementsBuffered = false;

        // component could be destroyed during the buffering time frame
        if (this.disabled || this.schedulerView.isDestroyed) return;

        if (Ext.versions.extjs && !this.schedulerView.el.down('.' + Ext.baseCSSPrefix + 'grid-item-container')) return;

        this.removeElements();

        this.renderBodyElementsInternal();

        if (this.showHeaderElements) {
            this.headerContainerEl = null;
            this.renderHeaderElementsInternal();
        }
        
        if (this.renderingDoneEvent) this.fireEvent(this.renderingDoneEvent, this);
    },

    
    /**
     * Generates markup for elements.
     * 
     * @param {Boolean} isPrint
     * @param {Array} records
     *  
     * @return {String}
     */
    generateMarkup : function(isPrint, records) {
        var start       = this.timeAxis.getStart(),
            end         = this.timeAxis.getEnd(),
            data        = this.getElementData(start, end, records, isPrint);

        return this.template.apply(data);
    },
    
    
    /**
     * Generates markup for headers elements.
     * 
     * @param {Boolean} isPrint
     * @param {Array} records
     *  
     * @return {String}
     */
    generateHeaderMarkup : function (isPrint, records) {
        var data = this.getHeaderElementData(records, isPrint);

        return this.headerTemplate.apply(data);
    },


    getElementData : function (viewStart, viewEnd, records, isPrint) {
        throw 'Abstract method call';
    },
    
    
    updateBodyElement : function (record) {
        var el = Ext.get(this.getElementId(record));
        
        if (el) {
            var start       = this.timeAxis.getStart(), 
                end         = this.timeAxis.getEnd(),
                data        = this.getElementData(start, end, [record])[0];

            if (data) {
                // Reapply CSS classes
                el.dom.className = data.$cls;

                el.setTop(data.top);
                this.setElementX(el, data.left);
                
                el.setSize(data.width, data.height);
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderBodyElementsInternal` will only add markup for that record
            this.renderBodyElementsInternal([ record ]);
        }
    },
    
    
    updateHeaderElement : function (record) {
        var el = Ext.get(this.getHeaderElementId(record));
        
        if (el) {
            var data = this.getHeaderElementData([record])[0];

            if (data) {
                // Reapply CSS classes
                el.dom.className = data.cls;

                if (this.schedulerView.isHorizontal()) {
                    this.setElementX(el, data.position);
                    el.setWidth(data.size);
                } else {
                    el.setTop(data.position);
                    el.setHeight(data.size);
                }
            } else {
                Ext.destroy(el);
            }
        } else {
            // if element is not found, then its probably a newly added record in the store
            // in this case `renderHeaderElementsInternal` will only add markup for that record
            this.renderHeaderElementsInternal([record]);
        }
    },
    
    
    destroy : function() {
        clearTimeout(this._renderTimer);
        clearTimeout(this._resizeTimer);

        if (this.store.autoDestroy) {
            this.store.destroy();
        }

        this.store.un(this.storeListeners);
    },
    

    refreshSingle : function(store, records) {

        records = records instanceof Array ? records : [records];

        Ext.Array.forEach(records, function(record) {
            this.updateBodyElement(record);

            if (this.showHeaderElements) {
                this.updateHeaderElement(record);
            }
        }, this);
    }
}); 

}
/**
 * @private
 * @class Sch.feature.DragCreator
 * @constructor
 * An internal class which shows a drag proxy while clicking and dragging.
 * Create a new instance of this plugin
 * @param {Object} config The configuration options
 */
Ext.define("Sch.feature.DragCreator", {
    requires : [
        'Ext.XTemplate',
        'Ext.ToolTip',
        'Sch.util.Date',
        'Sch.util.ScrollManager',
        'Sch.util.DragTracker',
        'Sch.tooltip.Tooltip',
        'Sch.tooltip.HoverTip'
    ],

    /**
     * @cfg {Boolean} disabled true to start disabled
     */
    disabled            : false,

    /**
     * @cfg {Boolean} showHoverTip true to show a time tooltip when hovering over the time cells
     */
    showHoverTip        : true,

    /**
     * @cfg {Boolean} showDragTip true to show a time tooltip when dragging to create a new event
     */
    showDragTip         : true,

    /**
     * @cfg {Ext.tip.ToolTip/Object} dragTip
     * The tooltip instance to show while dragging to create a new event or a configuration object for the default instance of
     * {@link Sch.tooltip.ToolTip}
     */
    dragTip             : null,

    /**
     * @cfg {Number} dragTolerance Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.
     */
    dragTolerance       : 2,

    /**
     * @cfg {Ext.tip.ToolTip/Object} hoverTip
     * The tooltip instance to show when mouse pointer is over scheduling area or a configuration object
     */
    hoverTip            : null,

    /**
     * An empty function by default, but provided so that you can perform custom validation on the event being created.
     * Return true if the new event is valid, false to prevent an event being created.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Ext.EventObject} e The event object
     * @return {Boolean} isValid
     */
    validatorFn         : Ext.emptyFn,

    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope    : null,

    /**
     * @cfg {Object} trackerConfig A custom config object used to create the internal {@link Sch.util.DragTracker} instance
     */
    trackerConfig : null,

    schedulerView : null,

    /**
     * @cfg {Ext.Template/String} template The HTML template shown when dragging to create new items
     */
    template            : '<div class="sch-dragcreator-proxy">' +
                              '<div class="sch-event-inner">&#160;</div>' +
                          '</div>',

    constructor : function (config) {
        Ext.apply(this, config || {});

        this.lastTime = new Date();

        if (!(this.template instanceof Ext.Template)) {
            this.template = new Ext.Template(this.template);
        }

        this.schedulerView.on("destroy", this.onSchedulerDestroy, this);

        if (Ext.supports.Touch) {
            this.schedulerView.on('boxready', this.initDragTracker, this);
        } else {
            this.schedulerView.el.on('mousemove', this.initDragTracker, this, { single : true });
        }

        this.callParent([config]);
    },


    /**
     * Enable/disable the plugin
     * @param {Boolean} disabled True to disable this plugin
     */
    setDisabled : function (disabled) {
        this.disabled = disabled;

        if (this.hoverTip) {
            this.hoverTip.setDisabled(disabled);
        }

        if (this.dragTip) {
            this.dragTip.setDisabled(disabled);
        }
    },

    getProxy          : function () {
        if (!this.proxy) {
            this.proxy = this.template.append(this.schedulerView.getSecondaryCanvasEl(), {}, true);

            this.proxy.hide = function () {
                this.setStyle({
                    left : '-10000px',
                    top  : '-10000px'
                });
            };
        }
        return this.proxy;
    },

    // private
    onBeforeDragStart : function (tracker, e) {
        var s = this.schedulerView,
            t = e.getTarget('.' + s.timeCellCls, 5);

        if (t && this.isCreateAllowed(e) && (!e.event.touches || e.event.touches.length === 1)) {
            var resourceRecord = s.resolveResource(t);
            var dateTime = s.getDateFromDomEvent(e);

            if (!this.disabled && t && s.fireEvent('beforedragcreate', s, resourceRecord, dateTime, e) !== false) {

                // Save record if the user ends the drag outside the current row
                this.resourceRecord = resourceRecord;

                // Start time of the event to be created
                this.originalStart = dateTime;

                // Constrain the dragging within the current row schedule area
                this.resourceRegion = s.getScheduleRegion(this.resourceRecord, this.originalStart);

                // Save date constraints
                this.dateConstraints = s.getDateConstraints(this.resourceRecord, this.originalStart);

                // TODO apply xStep or yStep to drag tracker
                return true;
            }
        }
        return false;
    },

    isCreateAllowed : function (e) {
        return !e.getTarget(this.schedulerView.eventSelector);
    },

    // private
    onDragStart       : function () {
        var me = this,
            view = me.schedulerView,
            dragRegion = me.tracker.getRegion(),
            proxy = me.getProxy();

        this.dragging = true;

        if (this.hoverTip) {
            this.hoverTip.disable();
        }

        me.start = me.originalStart;
        me.end = me.start;
        me.originalScroll = view.getScroll();

        if (view.getMode() === 'horizontal') {
            me.rowBoundaries = {
                top    : me.resourceRegion.top,
                bottom : me.resourceRegion.bottom
            };

        } else {
            me.rowBoundaries = {
                left  : me.resourceRegion.left,
                right : me.resourceRegion.right
            };

        }

        Ext.apply(dragRegion, me.rowBoundaries);

        proxy.setBox(dragRegion);
        proxy.show();

        view.fireEvent('dragcreatestart', view, proxy);

        if (me.showDragTip) {
            me.dragTip.enable();
            me.dragTip.update(me.start, me.end, true);
            me.dragTip.show(proxy);

            // for some reason Ext set `visibility` to `hidden` after a couple of `.hide()` calls
            me.dragTip.setStyle('visibility', 'visible');
        }

        Sch.util.ScrollManager.activate(view, view.getMode() === 'horizontal' ? 'horizontal' : 'vertical');
    },


    // private
    onDrag            : function (tracker, e) {
        var me = this,
            view = me.schedulerView,
            dragRegion = me.tracker.getRegion(),
            dates = view.getStartEndDatesFromRegion(dragRegion, 'round'),
            message = '';

        if (!dates) {
            return;
        }

        me.start = dates.start || me.start;
        me.end = dates.end || me.end;

        var dc = me.dateConstraints;

        if (dc) {
            me.end = Sch.util.Date.constrain(me.end, dc.start, dc.end);
            me.start = Sch.util.Date.constrain(me.start, dc.start, dc.end);
        }

        me.valid = this.validatorFn.call(me.validatorFnScope || me, me.resourceRecord, me.start, me.end);

        if (me.valid && typeof me.valid !== 'boolean') {
            message = me.valid.message;
            me.valid = me.valid.valid;
        }

        // If users returns nothing, that's interpreted as valid
        me.valid = (me.valid !== false);

        if (me.showDragTip) {
            me.dragTip.update(me.start, me.end, me.valid, message);
        }

        Ext.apply(dragRegion, me.rowBoundaries);

        var scroll = view.getScroll();
        var proxy = this.getProxy();
        proxy.setBox(dragRegion);

        if (view.isHorizontal()) {
            proxy.setY(me.resourceRegion.top + me.originalScroll.top - scroll.top);
        }

    },

    eventSwallower : function (e) {
        e.stopPropagation();
        e.preventDefault();
    },

    // private
    onDragEnd         : function (tracker, e) {
        var me          = this,
            s           = me.schedulerView,
            doFinalize  = true,
            t           = e.getTarget(),
            el          = Ext.get(t);

        // When dragging, we don't want a regular scheduleclick to fire - swallow the coming "click" event
        el.on('click', this.eventSwallower);

        setTimeout(function () {
            el.un('click', me.eventSwallower);
        }, 100);

        me.dragging = false;

        if (me.showDragTip) {
            me.dragTip.disable();
        }

        if (!me.start || !me.end || (me.end - me.start <= 0)) {
            me.valid = false;
        }

        me.createContext = {
            start          : me.start,
            end            : me.end,
            resourceRecord : me.resourceRecord,
            e              : e,
            finalize       : function () {
                me.finalize.apply(me, arguments);
            }
        };

        if (me.valid) {
            doFinalize = s.fireEvent('beforedragcreatefinalize', me, me.createContext, e, this.getProxy()) !== false;
        }

        if (doFinalize) {
            me.finalize(me.valid);
        }

        Sch.util.ScrollManager.deactivate();
    },

    finalize : function (doCreate) {
        var context = this.createContext;
        var schedulerView = this.schedulerView;

        if (doCreate) {
            var ev = Ext.create(schedulerView.eventStore.model);

            // HACK, for the Gantt chart assignments to work properly - we need the task to be in the task store before assigning it
            // to the resource, same reasons apply if event store uses assignment store to store assignment relations
            // between events and resources.
            if (Ext.data.TreeStore && schedulerView.eventStore instanceof Ext.data.TreeStore) {
                ev.set('leaf', true);
                schedulerView.eventStore.append(ev);
            }
            else if (!!schedulerView.eventStore.getAssignmentStore()) {
                schedulerView.eventStore.append(ev);
            }

            ev.assign(context.resourceRecord);
            ev.setStartEndDate(context.start, context.end);
            schedulerView.fireEvent('dragcreateend', schedulerView, ev, context.resourceRecord, context.e, this.getProxy());
        } else {
            this.proxy.hide();
        }

        this.schedulerView.fireEvent('afterdragcreate', schedulerView, this.getProxy());

        if (this.hoverTip) {
            this.hoverTip.enable();
        }
    },

    dragging : false,

    // Lazy setup of additional functionality
    initDragTracker : function () {
        var me              = this,
            isTouch = Ext.supports.Touch,
            view = me.schedulerView;

        var config = Ext.apply({
            el                 : view.el,
            // defer drag create on touch devices since scrolling is the default action
            deferredActivation : isTouch ? 1000 : false,
            tolerance : me.dragTolerance,
            listeners : {
                mousedown       : me.verifyLeftButtonPressed,
                beforedragstart : me.onBeforeDragStart,
                dragstart       : me.onDragStart,
                drag            : me.onDrag,
                dragend         : me.onDragEnd,
                scope           : me
            }
        }, this.trackerConfig);

        // disable tips for touch mode
        if (isTouch) {
            this.showDragTip    = false;
            this.showHoverTip   = false;
            this.dragTip        = null;
            this.hoverTip       = null;
        } else {
            this.setupTooltips();
        }

        me.tracker = new Sch.util.DragTracker(config);
    },

    setupTooltips : function () {
        var me = this,
            sv = me.schedulerView;

        if (this.showDragTip) {
            var dragTip     = this.dragTip;

            if (dragTip instanceof Ext.tip.ToolTip) {
                Ext.applyIf(dragTip, { schedulerView   : sv });

                dragTip.on('beforeshow', function () {
                    return me.dragging;
                });
            } else {
                this.dragTip = new Sch.tooltip.Tooltip(Ext.apply({
                    cls             : 'sch-dragcreate-tip',
                    schedulerView   : sv,
                    listeners       : {
                        beforeshow      : function () {
                            return me.dragging;
                        }
                    }
                }, dragTip));
            }
        }

        if (me.showHoverTip) {
            var hoverTip     = me.hoverTip;

            if (hoverTip instanceof Ext.tip.ToolTip) {
                Ext.applyIf(hoverTip, {
                    schedulerView   : sv
                });
            } else {
                me.hoverTip = Ext.ComponentManager.create(Ext.applyIf({
                    renderTo        : Ext.getBody(),
                    target          : sv.el,
                    schedulerView   : sv
                }, hoverTip), 'scheduler_hovertip');
            }
        }
    },

    verifyLeftButtonPressed : function (dragTracker, e) {
        return e.button === 0;
    },


    onSchedulerDestroy : function () {
        if (this.hoverTip) {
            this.hoverTip.destroy();
        }

        if (this.dragTip) {
            this.dragTip.destroy();
        }

        if (this.tracker) {
            this.tracker.destroy();
        }

        if (this.proxy) {
            Ext.destroy(this.proxy);
            this.proxy = null;
        }
    }
});

/**
 @class Sch.feature.SchedulerDragZone
 @extends Ext.dd.DragZone

 A custom scheduler dragzone that also acts as the dropzone, and optionally
 constrains the drag to the resource area that contains the dragged element.

 Generally it should not need to be used directly.
 To configure drag and drop use {@link Sch.mixin.SchedulerPanel#cfg-dragConfig SchedulerPanel} dragConfig instead.
 */
Ext.define("Sch.feature.SchedulerDragZone", {
    extend      : "Ext.dd.DragZone",

    requires    : [
        'Sch.tooltip.Tooltip',
        'Ext.dd.StatusProxy'
    ],

    repairHighlight     : false,
    repairHighlightColor : 'transparent',
    // this has to be set to `false` because we will manually register the view element in the ScrollManager
    // we don't need to register the dragged element in it
    containerScroll     : false,

    /**
     * @cfg {Boolean} showTooltip Specifies whether or not to show tooltip while dragging event
     */
    showTooltip         : true,

    /**
     * @cfg {Ext.tip.ToolTip/Object} tip
     *
     * The tooltip instance to show while dragging event or a configuration object
     */
    tip                 : null,

    tipIsProcessed      : false,


    schedulerView       : null,

    // The last 'good' coordinates received by mousemove events (needed when a scroll event happens, which doesn't contain XY info)
    lastXY              : null,

    /**
     * @type {Boolean} showExactDropPosition When enabled, the event being dragged always "snaps" to the exact start date that it will have after drop.
     */
    showExactDropPosition   : false,

    /**
     * @cfg {Boolean} enableCopy true to enable copy by pressing modifier key
     * (see {@link #enableCopyKey enableCopyKey}) during drag drop.
     */
    enableCopy          : false,

    /**
     *
     * @cfg {String} enableCopyKey
     * Modifier key that should be pressed during drag drop to copy item.
     * Available values are 'CTRL', 'ALT', 'SHIFT'
     */
    enableCopyKey       : 'SHIFT',

    /**
     * @cfg {Object} validatorFn
     *
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during the drag and drop process and also after the drop is made
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the current mouse position
     * @param {Number} duration The duration of the item being dragged
     * @param {Event} e The event object
     * @return {Boolean} true if the drop position is valid, else false to prevent a drop
     */
    validatorFn         : function (dragRecords, targetResourceRecord, date, duration, e) { return true; },

    /**
     * @cfg {Object} validatorFnScope
     * The scope for the {@link #validatorFn}
     */
    validatorFnScope    : null,

    copyKeyPressed      : false,


    /**
     * @constructor
     * @param {Object} config The object containing the configuration of this model.
     */
    constructor : function (el, config) {
        // Drag drop won't work in IE8 if running in an iframe
        // https://www.assembla.com/spaces/bryntum/tickets/712#/activity/ticket:
        if (Ext.isIE8m && window.top !== window) {
            Ext.dd.DragDropManager.notifyOccluded = true;
        }

        var proxy       = this.proxy = this.proxy || new Ext.dd.StatusProxy({
            shadow                  : false,
            dropAllowed             : this.dropAllowed,
            dropNotAllowed          : this.dropNotAllowed,

            // HACK, we want the proxy inside the scheduler, so that when user drags the event
            // out of the scheduler el, the event should be cropped by the scheduler edge
            ensureAttachedToBody    : Ext.emptyFn
        });

        this.callParent(arguments);
        this.isTarget   = true;
        this.scroll     = false;
        this.ignoreSelf = false;

        var schedulerView   = this.schedulerView;

        if (schedulerView.touchScroll) {
            // disable tooltips for touch devices
            this.showTooltip = false;
        }

        schedulerView.el.appendChild(proxy.el);

        if (schedulerView.rtl) {
            proxy.addCls('sch-rtl');
        }

        proxy.addCls('sch-dragproxy');

        // Activate the auto-scrolling behavior during the drag drop process
        schedulerView.on({
            eventdragstart : function () {
                Sch.util.ScrollManager.activate(schedulerView, schedulerView.constrainDragToResource && schedulerView.getMode());
            },

            aftereventdrop : function () {
                Sch.util.ScrollManager.deactivate();
            },

            scope          : this
        });
    },

    destroy : function () {
        this.callParent(arguments);

        Ext.destroyMembers(
            this,
            'tip'
        );
    },

    // @OVERRIDE
    autoOffset: function (x, y) {
        this.setDelta(0, 0);
    },

    // private
    setupConstraints : function (constrainRegion, elRegion, xOffset, yOffset, isHorizontal, tickSize, constrained) {
        this.clearTicks();

        var xTickSize       = isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;
        var yTickSize       = !isHorizontal && !this.showExactDropPosition && tickSize > 1 ? tickSize : 0;

        this.resetConstraints();

        this.initPageX      = constrainRegion.left + xOffset;
        this.initPageY      = constrainRegion.top + yOffset;

        var width           = elRegion.right - elRegion.left;
        var height          = elRegion.bottom - elRegion.top;

        // if `constrained` is false then we haven't specified getDateConstraint method and should constrain mouse position to scheduling area
        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.
        if (isHorizontal) {
            if (constrained) {
                this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
            } else {
                this.setXConstraint(constrainRegion.left, constrainRegion.right, xTickSize);
            }
            this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
        } else {
            this.setXConstraint(constrainRegion.left + xOffset, constrainRegion.right - width + xOffset, xTickSize);
            if (constrained) {
                this.setYConstraint(constrainRegion.top + yOffset, constrainRegion.bottom - height + yOffset, yTickSize);
            } else {
                this.setYConstraint(constrainRegion.top, constrainRegion.bottom, yTickSize);
            }
        }
    },

    // @OVERRIDE
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = iLeft;
        this.rightConstraint = iRight;

        this.minX = iLeft;
        this.maxX = iRight;
        if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }

        this.constrainX = true;
    },

    // @OVERRIDE
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = iUp;
        this.bottomConstraint = iDown;

        this.minY = iUp;
        this.maxY = iDown;
        if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }

        this.constrainY = true;
    },

    // These cause exceptions, and are not needed
    onDragEnter : Ext.emptyFn,
    onDragOut   : Ext.emptyFn,


    setVisibilityForSourceEvents : function (show) {
        Ext.each(this.dragData.getEventBarElements(), function (el) {
            el[ show ? 'show' : 'hide' ]();
        });
    },


    // private
    onDragOver: function(e){

        if(e.event.touches && e.event.touches.length > 1) {
            // Force a stop if multi touch is detected
            Ext.dd.DragDropManager.handleMouseUp(e);
            return;
        }

        var xy = e.type === 'scroll' ? this.lastXY : e.getXY();

        this.checkShiftChange();

        var dd          = this.dragData;

        if (!dd.originalHidden) {
            // Hide dragged event elements at this time
            this.setVisibilityForSourceEvents(false);

            dd.originalHidden   = true;
        }

        var start       = dd.startDate;
        var resource    = dd.newResource;
        var view        = this.schedulerView;

        this.updateDragContext(e);

        if (this.showExactDropPosition) {
            var isHorizontal    = view.isHorizontal();
            var timeDiff        = view.getDateFromCoordinate(isHorizontal ? xy[0] : xy[1]) - dd.sourceDate;
            var realStart       = new Date(dd.origStart - 0 + timeDiff);
            var offset         = view.timeAxisViewModel.getDistanceBetweenDates(realStart, dd.startDate);

            if (dd.startDate > view.timeAxis.getStart()) {
                var proxyEl     = this.proxy.el;
                if (offset) {
                    if (view.isHorizontal()) {
                        proxyEl.setX(xy[0] + (this.schedulerView.rtl ? -offset : offset));
                    } else {
                        proxyEl.setY(xy[1] + offset);
                    }
                }
            }
        }

        if (dd.startDate - start !== 0 || resource !== dd.newResource) {
            this.schedulerView.fireEvent('eventdrag', this.schedulerView, dd.draggedRecords, dd.startDate, dd.newResource, dd);
        }

        if (this.showTooltip) {
            this.tip.realign();
            this.tip.update(dd.startDate, dd.endDate, dd.valid, dd.message);
        }

        if (e.type !== 'scroll') {
            this.lastXY = e.getXY();
        }
    },

    getCoordinate   : function (coord) {
        switch (this.schedulerView.getMode()) {
            case 'horizontal'   : return coord[0];
            /* pass through */
            case 'vertical'     : return coord[1];
            /* pass through */
            case 'calendar'     : return coord;
            /* pass through */
        }
    },


    getDragData: function (e) {
        var s           = this.schedulerView,
            t           = e.getTarget(s.eventSelector);

        if (!t || e.event.touches && e.event.touches.length > 1) return;

        var eventRecord      = s.resolveEventRecord(t),
            resourceRecord   = s.resolveResource(t),
            assignmentRecord = s.resolveAssignmentRecord(t);

        // there will be no event record when trying to drag the drag creator proxy for example
        if (!eventRecord || eventRecord.isDraggable() === false || s.fireEvent('beforeeventdrag', s, eventRecord, e) === false) {
            return null;
        }

        var xy          = e.getXY(),
            eventEl     = Ext.get(t),
            eventXY     = eventEl.getXY(),
            offsets     = [ xy[0] - eventXY[0], xy[1] - eventXY[1] ],
            eventRegion = eventEl.getRegion();


        var isHorizontal    = s.getMode() == 'horizontal';

        s.constrainDragToResource && !resourceRecord &&
            Ext.Error.raise('Resource could not be resolved for event: ' + eventRecord.getId());

        var dateConstraints = s.getDateConstraints(s.constrainDragToResource ? resourceRecord : null, eventRecord);

        this.setupConstraints(
            s.getScheduleRegion(s.constrainDragToResource ? resourceRecord : null, eventRecord),
            eventRegion,
            offsets[0], offsets[1],
            isHorizontal,
            s.getSnapPixelAmount(),
            Boolean(dateConstraints)
        );

        var origStart           = eventRecord.getStartDate(),
            origEnd             = eventRecord.getEndDate(),
            timeAxis            = s.timeAxis,
            relatedRecords      = this.getRelatedRecords(assignmentRecord || eventRecord) || [],
            eventBarEls         = s.getElementsFromEventRecord(eventRecord, resourceRecord);

        // Collecting additional elements to drag
        Ext.Array.forEach(relatedRecords, function (r) {
            if (r instanceof Sch.model.Assignment) {
                eventBarEls = eventBarEls.concat(s.getElementsFromEventRecord(r.getEvent(), r.getResource()));
            }
            else {
                eventBarEls = eventBarEls.concat(s.getElementsFromEventRecord(r));
            }
        });
        eventBarEls = Ext.Array.unique(eventBarEls); // I'm not sure if it's required, but this way it seems safer

        var dragData = {
            offsets             : offsets,
            repairXY            : eventXY,

            prevScroll          : s.getScroll(),

            dateConstraints     : dateConstraints,

            eventBarEls         : eventBarEls,

            // During infinite scroll the scheduling view might be refreshed, due to time axis reconfiguration,
            // thus destroying previously stored DOM elements (and possibly new DOMs rendered),
            // by getting stored event elements via this method we make sure to always get fresh Elements
            // and ignore stale ones.
            getEventBarElements    : function() {
                return dragData.eventBarEls = Ext.Array.map(dragData.eventBarEls, function(el) {
                    return el.dom && el || Ext.get(el.id);
                });
            },

            draggedRecords      : [ assignmentRecord || eventRecord ].concat(relatedRecords),

            resourceRecord      : resourceRecord,

            sourceDate          : s.getDateFromCoordinate(this.getCoordinate(xy)),
            origStart           : origStart,
            origEnd             : origEnd,
            startDate           : origStart,
            endDate             : origEnd,
            timeDiff            : 0,

            startsOutsideView   : origStart < timeAxis.getStart(),
            endsOutsideView     : origEnd > timeAxis.getEnd(),

            duration            : origEnd - origStart,

            bodyScroll          : Ext.getBody().getScroll(),
            eventObj            : e // So we can know if SHIFT/CTRL was pressed
        };

        dragData.ddel = this.getDragElement(eventEl, dragData);

        return dragData;
    },

    onStartDrag : function (x, y) {
        var s       = this.schedulerView,
            dd      = this.dragData;

        // To make sure any elements made visible by hover are not visible when the original element is hidden (using visibility:hidden)
        Ext.Array.forEach(dd.getEventBarElements(), function(el) {
            el.removeCls('sch-event-hover');
        });

        s.fireEvent('eventdragstart', s, dd.draggedRecords);

        s.el.on('scroll', this.onViewElScroll, this);
    },

    alignElWithMouse: function(el, iPageX, iPageY) {
        this.callParent(arguments);

        var oCoord = this.getTargetCoord(iPageX, iPageY),
            fly = el.dom ? el : Ext.fly(el, '_dd');

        // original method limits task position by viewport dimensions
        // our drag proxy is located on secondary canvas and can have height larger than viewport
        // so we have to set position relative to bigger secondary canvas
        this.setLocalXY(
            fly,
                oCoord.x + this.deltaSetXY[0],
                oCoord.y + this.deltaSetXY[1]
        );
    },

    onViewElScroll  : function (event, target) {
        var proxy   = this.proxy,
            s       = this.schedulerView,
            dd      = this.dragData;

        this.setVisibilityForSourceEvents(false);

        var xy      = proxy.getXY();
        var scroll  = s.getScroll();
        var newXY   = [xy[0] + scroll.left - dd.prevScroll.left, xy[1] + scroll.top - dd.prevScroll.top];

        // this property is taking part in coordinates calculations in alignElWithMouse
        // these adjustments required for correct positioning of proxy on moving mouse after scroll
        var deltaSetXY = this.deltaSetXY;
        this.deltaSetXY = [deltaSetXY[0] + scroll.left - dd.prevScroll.left, deltaSetXY[1] + scroll.top - dd.prevScroll.top];
        dd.prevScroll = scroll;

        proxy.setXY(newXY);

        this.onDragOver(event);
    },


    getCopyKeyPressed : function() {
        return Boolean(this.enableCopy && this.dragData.eventObj[ this.enableCopyKey.toLowerCase() + 'Key' ]);
    },


    checkShiftChange : function() {
        var copyKeyPressed  = this.getCopyKeyPressed(),
            dd              = this.dragData;

        if (copyKeyPressed !== this.copyKeyPressed) {
            this.copyKeyPressed = copyKeyPressed;

            if (copyKeyPressed) {
                dd.refElements.addCls('sch-event-copy');
                this.setVisibilityForSourceEvents(true);
            } else {
                dd.refElements.removeCls('sch-event-copy');
                this.setVisibilityForSourceEvents(false);
            }
        }
    },


    onKey : function(e) {
        if (e.getKey() === e[ this.enableCopyKey ]) this.checkShiftChange();
    },


    // HACK, overriding private method, proxy needs to be shown before aligning to it
    startDrag : function() {
        if (this.enableCopy) {
            Ext.getDoc().on({
                keydown : this.onKey,
                keyup   : this.onKey,
                scope   : this
            });
        }

        var retVal              = this.callParent(arguments);
        var dragData            = this.dragData;

        // This is the representation of the original element inside the proxy
        dragData.refElement     = this.proxy.el.down('.sch-dd-ref');
        dragData.refElements    = this.proxy.el.select('.sch-event');

        // The dragged element should not be in hover state
        dragData.refElement.removeCls('sch-event-hover');

        if (this.showTooltip) {
            var s               = this.schedulerView,
                containerEl     = s.up('[lockable=true]').el;

            if (!this.tipIsProcessed) {
                this.tipIsProcessed = true;

                var tip         = this.tip;

                if (tip instanceof Ext.tip.ToolTip) {
                    Ext.applyIf(tip, {
                        schedulerView   : s
                    });
                } else {
                    this.tip        = new Sch.tooltip.Tooltip(Ext.apply({
                        schedulerView   : s,
                        cls             : 'sch-dragdrop-tip',
                        constrainTo     : containerEl
                    }, tip));
                }
            }

            this.tip.update(dragData.origStart, dragData.origEnd, true);
            // Seems required as of Ext 4.1.0, to clear the visibility:hidden style.
            this.tip.setStyle('visibility');
            this.tip.show(dragData.refElement, dragData.offsets[ 0 ]);
        }

        this.copyKeyPressed     = this.getCopyKeyPressed();

        if (this.copyKeyPressed) {
            dragData.refElements.addCls('sch-event-copy');
            dragData.originalHidden = true;
        }

        return retVal;
    },


    endDrag : function() {
        this.schedulerView.el.un('scroll', this.onViewElScroll, this);

        if (this.enableCopy) {
            Ext.getDoc().un({
                keydown : this.onKey,
                keyup   : this.onKey,
                scope   : this
            });
        }
        this.callParent(arguments);
    },

    onMouseUp : function() {
        if (!this.dragging) {
            // Reset drag proxy position on a simple mouse click (which triggers a change in the 'left' position of the proxy el)
            this.afterDragFinalized();
        }
    },

    afterDragFinalized : function() {

        // https://www.assembla.com/spaces/bryntum/tickets/1524#/activity/ticket:
        // If drag is done close to the edge to invoke scrolling, the proxy could be left there and interfere
        // with the view sizing if the columns are shrunk.
        this.proxy.el.setStyle({
            left : 0,
            top  : 0
        });
    },

    updateRecords : function (context) {
        var me                    = this,
            schedulerView         = me.schedulerView,
            eventStore            = schedulerView.eventStore,
            resourceStore         = schedulerView.resourceStore,
            assignmentStore       = eventStore.getAssignmentStore(),
            newResource           = context.newResource,
            draggedRecord         = context.draggedRecords[0],
            relatedDraggedRecords = context.draggedRecords.slice(1),
            resourceRecord        = context.resourceRecord,
            copyKeyPressed        = me.getCopyKeyPressed(),
            startDate             = context.startDate,
            timeDiff              = context.timeDiff,
            viewMode              = schedulerView.getMode();

        // Scheduler multiple assignment mode
        if (assignmentStore && eventStore instanceof Sch.data.EventStore) {
            me.updateRecordsMultipleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, assignmentStore, copyKeyPressed, viewMode);
        }
        // Gantt mode (and task store instead of event store)
        else if (assignmentStore) {
            me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord.getEvent(), Ext.Array.map(relatedDraggedRecords, function(r) { return r.getEvent(); }), resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, viewMode);
        }
        // Scheduler single assignment mode
        else {
            me.updateRecordsSingleAssignmentMode(startDate, timeDiff, draggedRecord, relatedDraggedRecords, resourceRecord, newResource, eventStore, resourceStore, copyKeyPressed, viewMode);
        }

        // Tell the world there was a successful drop
        schedulerView.fireEvent('eventdrop', schedulerView, context.draggedRecords, copyKeyPressed);
    },

    updateRecordsSingleAssignmentMode : function(startDate, timeDiff, draggedEvent, relatedEvents, fromResource, toResource, eventStore, resourceStore, copy, viewMode) {
        // The code is written to emit as little store events as possible
        var me = this,
            toAdd = [];

        if (copy) {
            draggedEvent = draggedEvent.fullCopy(null);
            toAdd.push(draggedEvent);
        }

        // Process original dragged record
        draggedEvent.beginEdit();

        // in calendar view resources are just time spans, so we have to skip this part
        if (!copy && toResource !== fromResource && fromResource instanceof Sch.model.Resource && toResource instanceof Sch.model.Resource) {
            draggedEvent.reassign(fromResource, toResource);
        }
        else if (toResource !== fromResource && fromResource instanceof Sch.model.Resource && toResource instanceof Sch.model.Resource) {
            draggedEvent.assign(toResource);
        }

        draggedEvent.setStartDate(startDate, true, eventStore.skipWeekendsDuringDragDrop);
        draggedEvent.endEdit();

        // in calendar view drag&drop doesn't change resource
        if (viewMode !== 'calendar') {
            // Process related records
            var indexDiff = resourceStore.indexOf(fromResource) - resourceStore.indexOf(toResource);

            Ext.Array.forEach(relatedEvents, function(related) {
                // grabbing resources early, since after ".copy()" the record won't belong to any store
                // and ".getResources()" won't work
                var relatedResources = related.getResources();

                if (copy) {
                    related = related.fullCopy(null);
                    toAdd.push(related);
                }

                related.beginEdit();

                // calculate new startDate (and round it) based on timeDiff
                related.setStartDate(me.adjustStartDate(related.getStartDate(), timeDiff), true, eventStore.skipWeekendsDuringDragDrop);

                indexDiff !== 0 && relatedResources.length && Ext.Array.forEach(relatedResources, function(r) {
                    var newIndex = resourceStore.indexOf(r) - indexDiff,
                        newResource;

                    if (newIndex < 0) {
                        newIndex = 0;
                    }
                    else if (newIndex >= resourceStore.getCount()) {
                        newIndex = resourceStore.getCount() - 1;
                    }

                    newResource = resourceStore.getAt(newIndex);
                    related.reassign(r, newResource);
                });

                related.endEdit();
            });
        }

        if (toAdd.length) {
            eventStore.append(toAdd);
        }
    },

    updateRecordsMultipleAssignmentMode : function(startDate, timeDiff, draggedAssignment, relatedAssignments, fromResource, toResource, eventStore, resourceStore, assignmentStore, copy, viewMode) {
        var me = this;

        Ext.Array.forEach([].concat(draggedAssignment, relatedAssignments), function(assignment) {
            var event    = assignment.getEvent();

            event.setStartDate(me.adjustStartDate(event.getStartDate(), timeDiff), true, eventStore.skipWeekendsDuringDragDrop);

            // if we dragged the event to a different resource
            if (viewMode != 'calendar' && fromResource !== toResource) {
                if (copy) {
                    event.assign(toResource);
                } else if (!event.isAssignedTo(toResource)) {
                    event.reassign(assignment.getResource(), toResource);
                } else {
                    event.unassign(assignment.getResource());
                }
            }
        });
    },

    isValidDrop : function (oldResource, newResource, sourceRecord) {
        // Not allowed to assign an event twice to the same resource -
        // which might happen when we deal with an assignment store
        if (oldResource !== newResource) {
            // if we operate assignments
            if (sourceRecord instanceof Sch.model.Assignment) {
                return !sourceRecord.getEvent().isAssignedTo(newResource);
            } else {
                return !sourceRecord.isAssignedTo(newResource);
            }
        }

        return true;
    },


    resolveResource : function (xy, e) {
        var proxyDom        = this.proxy.el.dom;
        var bodyScroll      = this.dragData.bodyScroll;

        proxyDom.style.display = 'none';
        var node    = document.elementFromPoint(xy[0] - bodyScroll.left, xy[1] - bodyScroll.top);

        // IE8 likes it twice, for simulated events..
        if (Ext.isIE8 && e && e.browserEvent.synthetic) {
            node    = document.elementFromPoint(xy[0] - bodyScroll.left, xy[1] - bodyScroll.top);
        }

        proxyDom.style.display = 'block';

        if (!node) {
            return null;
        }

        var view            = this.schedulerView;

        // If we hover a table row border we will match a row element here.
        // We then need to adjust the Y-pos to get a cell which gives us the correct cell index.
        if (node.className.match(Ext.baseCSSPrefix + 'grid-item')) {
            return this.resolveResource([xy[0], xy[1] + 3], e);
        }

        if (!node.className.match(view.timeCellCls)) {
            var parent = Ext.fly(node).up('.' + view.timeCellCls);

            if (parent) {
                node = parent.dom;
            } else {
                return null;
            }
        }
        return view.resolveResource(node);
    },

    adjustStartDate : function (startDate, timeDiff) {
        var s   = this.schedulerView;
        return s.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), s.snapRelativeToEventStartDate ? startDate : false);
    },

    // private
    updateDragContext : function (e) {
        var dd              = this.dragData,
            xy              = e.type === 'scroll' ? this.lastXY : e.getXY();

        if (!dd.refElement) {
            return;
        }

        var s               = this.schedulerView,
            proxyRegion     = dd.refElement.getRegion();

        if (s.timeAxis.isContinuous()) {
            if (
                (s.isHorizontal() && this.minX < xy[0] && xy[0] < this.maxX) ||
                (s.isVertical() && this.minY < xy[1] && xy[1] < this.maxY)
            ) {
                var newDate     = s.getDateFromCoordinate(this.getCoordinate(xy));

                dd.timeDiff     = newDate - dd.sourceDate;
                // calculate and round new startDate based on actual dd.timeDiff
                dd.startDate    = this.adjustStartDate(dd.origStart, dd.timeDiff);
                dd.endDate      = new Date(dd.startDate - 0 + dd.duration);
            }

        } else {
            var range       = this.resolveStartEndDates(proxyRegion);

            dd.startDate    = range.startDate;
            dd.endDate      = range.endDate;

            dd.timeDiff     = dd.startDate - dd.origStart;
        }

        dd.newResource      = s.constrainDragToResource ?
            dd.resourceRecord
            :
            this.resolveResource([ proxyRegion.left + dd.offsets[ 0 ], proxyRegion.top + dd.offsets[ 1 ] ], e);

        if (dd.newResource) {
            var result        = this.validatorFn.call(this.validatorFnScope || this, dd.draggedRecords, dd.newResource, dd.startDate, dd.duration, e);

            if (!result || typeof result === 'boolean') {
                dd.valid = result !== false;
                dd.message = '';
            } else {
                dd.valid = result.valid !== false;
                dd.message = result.message;
            }
        } else {
            dd.valid        = false;
        }
    },

    /**
     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.
     * @param {Ext.data.Model} eventRecord The eventRecord about to be dragged
     * @return {[Ext.data.Model]} An array of event records to drag together with the original event
     */
    getRelatedRecords : function(sourceRecord) {
        var view = this.schedulerView,
            sm = view.getEventSelectionModel(),
            result = sm.getDraggableSelections();

        return Ext.Array.filter(result, function(selectedRecord) {
            return sourceRecord !== selectedRecord;
        });
    },

    /**
     * This function should return a DOM node representing the markup to be dragged. By default it just returns the selected element(s) that are to be dragged.
     * If dragging multiple events, the clone of the original item should be assigned the special CSS class 'sch-dd-ref'
     * @param {Ext.Element} sourceEl The event element that is the source drag element
     * @param {Object} dragData The drag drop context object
     * @return {HTMLElement} The DOM node to drag
     */
    getDragElement : function(sourceEl, dragData) {
        var eventBarEls         = dragData.getEventBarElements();
        var copy;
        var retVal;
        var offsetX             = dragData.offsets[ 0 ];
        var offsetY             = dragData.offsets[ 1 ];

        if (eventBarEls.length > 1) {
            var ctEl            = Ext.core.DomHelper.createDom({
                tag     : 'div',
                cls     : 'sch-dd-wrap',
                style   : { overflow : 'visible' }
            });

            Ext.Array.forEach(eventBarEls, function (el) {
                copy            = el.dom.cloneNode(true);

                copy.id         = Ext.id();

                if (el.dom === sourceEl.dom) {
                    // Using Ext fly here seems buggy in Ext 5.0.1
                    copy.className += " sch-dd-ref";

                    // removing this will fail 012_dragdrop tests in IE8
                    if (Ext.isIE8) {
                        Ext.fly(copy).addCls('sch-dd-ref');
                    }
                }

                ctEl.appendChild(copy);

                var elOffsets   = el.getOffsetsTo(sourceEl);

                // Adjust each element offset to the source event element
                Ext.fly(copy).setStyle({
                    left    : elOffsets[ 0 ] - offsetX + 'px',
                    top     : elOffsets[ 1 ] - offsetY + 'px'
                });
            });

            retVal = ctEl;
        } else {
            copy                = sourceEl.dom.cloneNode(true);
            copy.id             = Ext.id();

            copy.style.left     = -offsetX + 'px';
            copy.style.top      = -offsetY + 'px';

            // Using Ext fly here seems buggy in Ext 5.0.1
            // removing this will fail 061_dragdrop_sanity test in IE8
            copy.className += " sch-dd-ref";

            // removing this will fail 012_dragdrop tests in IE8
            if (Ext.isIE8) {
                Ext.fly(copy).addCls('sch-dd-ref');
            }

            retVal = copy;
        }

        // TODO: fix this, it's written as if we will always have 1 element being dragged.
        // If event rendering is not using px values (could be overriden to % values in CSS) we need to
        // put a height in place for the proxy element to look correctly
        if (!sourceEl.dom.style.height) {
            Ext.fly(retVal).setHeight(sourceEl.getHeight());
        }

        return retVal;
    },


    onDragDrop: function (e, id) {

        this.updateDragContext(e);

        var me          = this,
            s           = me.schedulerView,
            target      = me.cachedTarget || Ext.dd.DragDropMgr.getDDById(id),
            dragData    = me.dragData,
            modified    = false,
            doFinalize  = true;

        // Used later in finalizeDrop
        dragData.ddCallbackArgs = [ target, e, id ];

        if (dragData.valid && dragData.startDate && dragData.endDate) {
            dragData.finalize   = function () { me.finalize.apply(me, arguments); };

            // Allow implementer to take control of the flow, by returning false from this listener,
            // to show a confirmation popup etc.
            doFinalize          = s.fireEvent('beforeeventdropfinalize', me, dragData, e) !== false;

            // Internal validation, making sure all dragged records fit inside the view
            if (doFinalize && me.isValidDrop(dragData.resourceRecord, dragData.newResource, dragData.draggedRecords[ 0 ])) {
                modified        = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;
            }
        }

        if (doFinalize) {
            me.finalize(dragData.valid && modified);
        } else {
            // In case Ext JS sets a very high Z-index, lower it temporarily so it doesn't interfere with popups etc
            me.proxy.el.addCls('sch-before-drag-finalized');
        }
    },

    finalize : function (updateRecords) {
        var me          = this,
            view        = me.schedulerView,
            eventStore  = view.eventStore,
            dragData    = me.dragData;

        me.proxy.el.removeCls('sch-before-drag-finalized');

        if (me.tip) {
            me.tip.hide();
        }

        if (updateRecords){
            // Catch one more edge case, if a taskStore with calendars is used - there is a possible scenario where the UI isn't
            // repainted. In gantt+scheduler demo, move an event in the scheduler a few px and it disappears since Calendar adjusts its start date and scheduler is unaware of this.
            var updated,
                checkerFn = function() {updated = true;};

            eventStore.on('update', checkerFn, null, { single : true });
            me.updateRecords(dragData);
            eventStore.un('update', checkerFn, null, { single : true });

            if (!updated) {
                me.onInvalidDrop.apply(me, dragData.ddCallbackArgs);
            } else {
                // For our good friend IE9, the pointer cursor gets stuck without the defer
                if (Ext.isIE9) {
                    me.proxy.el.setStyle('visibility', 'hidden');
                    Ext.Function.defer(me.onValidDrop, 10, me, dragData.ddCallbackArgs);
                } else {
                    me.onValidDrop.apply(me, dragData.ddCallbackArgs);
                }
                view.fireEvent('aftereventdrop', view, dragData.draggedRecords);
            }
            me.afterDragFinalized();
        } else {
            me.onInvalidDrop.apply(me, dragData.ddCallbackArgs);
        }

    },


    // HACK: Override for IE, if you drag the task bar outside the window or iframe it crashes (missing e.target)
    // https://www.assembla.com/spaces/bryntum/tickets/716
    onInvalidDrop : function (target, e, id) {
        if (Ext.isIE && !e) {
            e       = target;
            target  = target.getTarget() || document.body;
        }

        if (this.tip) {
            this.tip.hide();
        }

        this.setVisibilityForSourceEvents(true);

        var s       = this.schedulerView,
            retVal  = this.callParent([ target, e, id ]);

        s.fireEvent('aftereventdrop', s, this.dragData.draggedRecords);

        this.afterDragFinalized();

        return retVal;
    },


    resolveStartEndDates : function(proxyRegion) {
        var dd          = this.dragData,
            startEnd,
            start       = dd.origStart,
            end         = dd.origEnd;

        var DATE        = Sch.util.Date;

        if (!dd.startsOutsideView) {
            startEnd    = this.schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
            if (startEnd) {
                start   = startEnd.start || dd.startDate;
                end     = DATE.add(start, DATE.MILLI, dd.duration);
            }
        } else if (!dd.endsOutsideView) {
            startEnd    = this.schedulerView.getStartEndDatesFromRegion(proxyRegion, 'round');
            if (startEnd) {
                end     = startEnd.end || dd.endDate;
                start   = DATE.add(end, DATE.MILLI, -dd.duration);
            }
        }

        return {
            startDate   : start,
            endDate     : end
        };
    }

});

/**
 * @class Sch.feature.DragDrop
 * @private
 * Internal class enabling drag and drop for event nodes and creating drag proxy (classic or simplified).
 * Type of proxy can be configured with {@link Sch.mixin.SchedulerPanel#cfg-dragConfig SchedulerPanel} dragConfig property.
 */
Ext.define("Sch.feature.DragDrop", {

    requires : [
        'Ext.XTemplate',
        'Sch.feature.SchedulerDragZone'
    ],

    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during the drag and drop process and also after the drop is made.
     * Return true if the new position is valid, false to prevent the drag.
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the current mouse position
     * @param {Number} duration The duration of the item being dragged
     * @param {Event} e The event object
     * @return {Boolean}
     */
    validatorFn : function(dragRecords, targetResourceRecord, date, duration, e) {
        return true;
    },


    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope        : null,

    /**
     * @cfg {Object} dragConfig
     *
     * The config object which will be passed to the `Sch.feature.SchedulerDragZone` instance
     */
    dragConfig              : null,

    /**
     * @constructor
     * @param {Sch.panel.SchedulerGrid} scheduler The scheduler instance
     * @param {Object} config The object containing the configuration of this model.
     */
    constructor : function(schedulerView, config) {
        Ext.apply(this, config);

        this.schedulerView = schedulerView;

        // The drag zone behaviour, can't attach to the view el (crash in IE), using panel el instead.
        schedulerView.eventDragZone = new Sch.feature.SchedulerDragZone(schedulerView.ownerCt.el, Ext.apply({
            ddGroup             : schedulerView.id,
            schedulerView       : schedulerView,
            validatorFn         : this.validatorFn,
            validatorFnScope    : this.validatorFnScope
        }, this.dragConfig));

        this.schedulerView.on("destroy", this.cleanUp, this);

        this.callParent([config]);
    },


    cleanUp : function() {
        var schedulerView       = this.schedulerView;

        if (schedulerView.eventDragZone) {
            schedulerView.eventDragZone.destroy();
        }
    }
});

/**
 * @class Sch.feature.ResizeZone
 * @extends Ext.util.Observable
 * @private
 * Internal classing enabling resizing of rendered events
 * @constructor
 * @param {Sch.panel.SchedulerGrid} scheduler The scheduler instance
 * @param {Object} config The object containing the configuration of this model.
 */

Ext.define("Sch.feature.ResizeZone" , {
    extend      : "Ext.util.Observable",
    requires    : [
        'Ext.resizer.Resizer',
        'Sch.tooltip.Tooltip',
        'Sch.util.ScrollManager'
    ],

    /**
      * @cfg {Boolean} showTooltip `false` to not show a tooltip while resizing
      */
    showTooltip         : true,

    /**
     * @type {Boolean} showExactResizePosition true to see exact event length during resizing
     */
    showExactResizePosition : false,

    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being resized. Return true if the new duration is valid, false to signal that it is not.
     * @param {Sch.model.Resource} resourceRecord the resource to which the event belongs
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Ext.EventObject} e The event object
     * @return {Boolean}
     */
    validatorFn         : Ext.emptyFn,

    /**
     * @cfg {Object} validatorFnScope
     * The scope for the validatorFn
     */
    validatorFnScope    : null,

    schedulerView       : null,

    origEl              : null,
    handlePos           : null,
    eventRec            : null,

    /**
     * @cfg {Ext.tip.ToolTip/Object} tip
     *
     * The tooltip instance to show while resizing an event or a configuration object for the {@link Sch.tooltip.Tooltip}.
     */
    tip                 : null,
    // cached reference to the created tooltip instance
    tipInstance         : null,


    startScroll         : null,

    constructor : function(config) {
        Ext.apply(this, config);
        var s = this.schedulerView;

        s.on({
            destroy : this.cleanUp,
            scope   : this
        });

        s.mon(s.el, {
            mousedown       : this.onMouseDown,
            mouseup         : this.onMouseUp,
            scope           : this,
            delegate        : '.sch-resizable-handle'
        });
        this.callParent(arguments);
    },

    onMouseDown : function(e, t) {
        var s               = this.schedulerView;
        var eventRec        = this.eventRec = s.resolveEventRecord(t);
        var isResizable     = eventRec.isResizable();

        if (e.button !== 0 || (isResizable === false || typeof isResizable === 'string' && !t.className.match(isResizable))) {
            return;
        }

        this.eventRec       = eventRec;
        this.handlePos      = this.getHandlePosition(t);
        this.origEl         = Ext.get(e.getTarget('.sch-event'));

        s.el.on({
            mousemove   : this.onMouseMove,
            scope       : this,
            single      : true
        });
    },

    onMouseUp : function(e, t) {
        var s = this.schedulerView;

        s.el.un({
            mousemove   : this.onMouseMove,
            scope       : this,
            single      : true
        });
    },


    getTipInstance : function () {
        if (this.tipInstance) return this.tipInstance;

        var s               = this.schedulerView;
        var tip             = this.tip;
        var containerEl     = s.up('[lockable=true]').el;

        if (tip instanceof Ext.tip.ToolTip) {
            Ext.applyIf(tip, { schedulerView : s });
        } else {
            tip     = new Sch.tooltip.Tooltip(Ext.apply({
                rtl             : this.rtl,
                schedulerView   : s,
                constrainTo     : containerEl,
                cls             : 'sch-resize-tip',
                onMyMouseMove   : function (ev) {
                    this.el.alignTo(this.target, 'bl-tl', [ ev.getX() - this.target.getX(), -5 ]);
                }
            }, tip));
        }

        return this.tipInstance = tip;
    },


    onMouseMove : function(e, t) {
        var s           = this.schedulerView,
            eventRec    = this.eventRec,
            handlePos   = this.handlePos;

        if (!eventRec || s.fireEvent('beforeeventresize', s, eventRec, e) === false) {
            return;
        }

        delete this.eventRec;
        e.stopEvent();

        this.origEl.addCls('sch-event-resizing');

        this.resizer    = this.createResizer(this.origEl, eventRec, handlePos);

        var tracker     = this.resizer.resizeTracker;

        if (this.showTooltip) {
            var tip     = this.getTipInstance();

            // update requires target that was removed after previous resize
            tip.setTarget(this.origEl);
            tip.update(eventRec.getStartDate(), eventRec.getEndDate(), true);
            tip.show(this.origEl);
        }

        // HACK, fake the start of the resizing right away
        tracker.onMouseDown(e, this.resizer[ handlePos ].dom);
        tracker.onMouseMove(e, this.resizer[ handlePos ].dom);

        s.fireEvent('eventresizestart', s, eventRec);

        // Handle inifinite scroll case
        s.el.on('scroll', this.onViewElScroll, this);
    },

    getHandlePosition : function(node) {
        var isStart = node.className.match('start');

        if (this.schedulerView.getMode() === 'horizontal') {
            if (this.schedulerView.rtl) {
                return isStart ? 'east' : 'west';
            }
            return isStart ? 'west' : 'east';
        } else {
             return isStart ? 'north' : 'south';
        }
    },

    // private
    createResizer : function (eventEl, eventRecord, handlePos) {
        var s                   = this.schedulerView,
            me                  = this,
            resourceRecord      = s.resolveResource(eventEl),
            increment           = s.getSnapPixelAmount(),
            constrainRegion     = s.getScheduleRegion(resourceRecord, eventRecord),
            dateConstraints     = s.getDateConstraints(resourceRecord, eventRecord),
            height              = eventEl.getHeight(),
            isStart             = (s.rtl && handlePos[0] === 'e') || (!s.rtl && handlePos[0] === 'w') || handlePos[0] === 'n',
            isVertical          = s.getMode() !== 'horizontal',

            resizerCfg          = {
                otherEdgeX      : isStart ? eventEl.getRight() : eventEl.getLeft(),
                otherEdgeY      : isStart ? eventEl.getBottom() : eventEl.getTop(),
                target          : eventEl,
                isStart         : isStart,
                // calculate event's position relative to cell
                startYOffset    : eventEl.getY() - eventEl.parent().getY(),
                startXOffset    : eventEl.getX() - eventEl.parent().getX(),
                dateConstraints : dateConstraints,
                resourceRecord  : resourceRecord,
                eventRecord     : eventRecord,
                handles         : handlePos[0],
                minHeight       : height,
                constrainTo     : constrainRegion,

                listeners       : {
                    resizedrag  : this.partialResize,
                    resize      : this.afterResize,
                    scope       : this
                }
            };



        // HACK, make it unique to prevent Ext JS from getting the wrong one if multiple events with same Id exist.
        // Remove this when scheduler has assignment store awareness
        var prevId          = eventEl.id;
        var newId           = '_' + prevId;

        eventEl.id               = eventEl.dom.id = newId;

        // duplicate the cache entry for this element, so Ext.get(newId) or Ext.get(el) will reference the same entry
        Ext.cache[ newId ]  = Ext.cache[ prevId ];
        // EOF HACK

        // Apply orientation specific configs
        if (isVertical) {
            if (increment > 0) {
                var w = eventEl.getWidth();

                Ext.apply(resizerCfg, {
                    minHeight       : increment,
                    // To avoid SHIFT causing a ratio preserve
                    minWidth        : w,
                    maxWidth        : w,
                    heightIncrement : increment
                });
            }
        } else {
            if (increment > 0) {

                Ext.apply(resizerCfg, {
                    minWidth        : increment,
                    // To avoid SHIFT causing a ratio preserve
                    maxHeight       : height,
                    widthIncrement  : increment
                });
            }
        }

        var resizer = new Ext.resizer.Resizer(resizerCfg);

        resizer.prevId  = prevId;

        if (resizer.resizeTracker) {

            // Force tracker to start tracking even with just 1px movement, defaults to 3.
            resizer.resizeTracker.tolerance = -1;

            // Ignore resizing action if dragging outside the scheduler
            // Fixes WebKit issue https://www.assembla.com/spaces/bryntum/tickets/994#/activity/ticket:
            var old = resizer.resizeTracker.updateDimensions;

            resizer.resizeTracker.updateDimensions = function(e) {
                if (!Ext.isWebKit || e.getTarget('.sch-timelineview')) {
                    var scrollDelta;

                    // minWidth needs to be adjusted to take a new scroll position into account
                    if (isVertical) {
                        scrollDelta = s.el.getScroll().top - me.startScroll.top;
                        resizer.resizeTracker.minHeight = resizerCfg.minHeight - Math.abs(scrollDelta);
                    } else {
                        scrollDelta = s.el.getScroll().left - me.startScroll.left;
                        resizer.resizeTracker.minWidth = resizerCfg.minWidth - Math.abs(scrollDelta);
                    }

                    old.apply(this, arguments);
                }
            };

            // Patched to handle changes in containing scheduler view el scroll position
            resizer.resizeTracker.resize = function(box) {
                var scrollDelta;

                if (isVertical) {
                    scrollDelta = s.el.getScroll().top - me.startScroll.top;

                    if (handlePos[0] === 's') {
                        box.y -= scrollDelta;
                    }

                    box.height += Math.abs(scrollDelta);
                } else {
                    scrollDelta = s.el.getScroll().left - me.startScroll.left;

                    if (handlePos[0] === 'e') {
                        box.x -= scrollDelta;
                    }

                    box.width += Math.abs(scrollDelta);
                }

                Ext.resizer.ResizeTracker.prototype.resize.apply(this, arguments);
            };
        }

        // Make sure the resizing event is on top of other events
        eventEl.setStyle('z-index', parseInt(eventEl.getStyle('z-index'), 10)+1);

        Sch.util.ScrollManager.activate(s, s.getMode() === 'horizontal' ? 'horizontal' : 'vertical');

        this.startScroll = s.el.getScroll();

        return resizer;
    },

    getStartEndDates : function() {
        var r           = this.resizer,
            rEl         = r.el,
            s           = this.schedulerView,
            isStart     = r.isStart,
            start, end, xy;

        if (isStart) {
            if (s.getMode() === 'horizontal') {
                xy          = [s.rtl ? rEl.getRight() : rEl.getLeft() + 1, rEl.getTop()];
            } else {
                xy          = [(rEl.getRight() + rEl.getLeft()) / 2, rEl.getTop()];
            }
            end         = r.eventRecord.getEndDate();

            if (s.snapRelativeToEventStartDate) {
                start       = s.getDateFromXY(xy);
                start       = s.timeAxis.roundDate(start, r.eventRecord.getStartDate());
            } else {
                start       = s.getDateFromXY(xy, 'round');
            }
        } else {
            if (s.getMode() === 'horizontal') {
                xy          = [s.rtl ? rEl.getLeft() : rEl.getRight(), rEl.getBottom()];
            } else {
                xy          = [(rEl.getRight() + rEl.getLeft()) / 2, rEl.getBottom()];
            }

            start       = r.eventRecord.getStartDate();

            if (s.snapRelativeToEventStartDate) {
                end         = s.getDateFromXY(xy);
                end         = s.timeAxis.roundDate(end, r.eventRecord.getEndDate());
            } else {
                end         = s.getDateFromXY(xy, 'round');
            }
        }

        start   = start || r.start;
        end     = end   || r.end;

        if (r.dateConstraints) {
            start       = Sch.util.Date.constrain(start, r.dateConstraints.start, r.dateConstraints.end);
            end         = Sch.util.Date.constrain(end, r.dateConstraints.start, r.dateConstraints.end);
        }

        return {
            start   : start,
            end     : end
        };
    },

    // private
    partialResize : function (r, width, height, e) {
        var s               = this.schedulerView,
            xy              = e.type === 'scroll' ? this.resizer.resizeTracker.lastXY : e.getXY(),
            startEndDates   = this.getStartEndDates(xy),
            start           = startEndDates.start,
            end             = startEndDates.end,
            record          = r.eventRecord,
            mode            = s.getMode(),
            isHorizontal    = s.isHorizontal();


        if (isHorizontal) {
            r.target.el.setY(r.target.parent().getY() + r.startYOffset);
        } else {
            r.target.el.setX(r.target.parent().getX() + r.startXOffset);
        }

        if (this.showTooltip) {
            var valid = this.validatorFn.call(this.validatorFnScope || this, r.resourceRecord, record, start, end);
            var message = '';

            // Implementer could also return an object { valid : false, message : 'foo' }
            if (valid && typeof valid !== 'boolean') {
                message = valid.message;
                valid   = valid.valid;
            }

            this.getTipInstance().update(start, end, valid !== false, message);
        }

        if (this.showExactResizePosition) {
            var target          = r.target.el,
                exactWidth,
                cursorDate,
                offset;

            if (r.isStart) {
                if (s.getMode() === 'calendar') {
                    var column  = s.calendar.getEventColumns(record)[0];
                    exactWidth  = s.timeAxisViewModel.getDistanceBetweenDates(start, column.end);
                } else {
                    exactWidth  = s.timeAxisViewModel.getDistanceBetweenDates(start, record.getEndDate());
                }

                if (isHorizontal) {
                    cursorDate  = s.getDateFromCoordinate(r.otherEdgeX - Math.min(width, r.maxWidth)) || start;
                    offset      = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                    target.setWidth(exactWidth);
                    target.setX(target.getX() + offset);
                } else {
                    cursorDate  = s.getDateFromCoordinate(r.otherEdgeY - Math.min(width, r.maxHeight)) || start;
                    offset      = s.timeAxisViewModel.getDistanceBetweenDates(cursorDate, start);
                    target.setHeight(exactWidth);
                    target.setY(target.getY() + offset);
                }

            } else {
                exactWidth      = s.timeAxisViewModel.getDistanceBetweenDates(record.getStartDate(), end);
                if (isHorizontal) {
                    target.setWidth(exactWidth);
                } else {
                    target.setHeight(exactWidth);
                }
            }
        } else {
            if (!start || !end || ((r.start - start === 0) && (r.end - end === 0))) {
                return;
            }
        }

        r.end   = end;
        r.start = start;

        s.fireEvent('eventpartialresize', s, record, start, end, r.el);


    },

    onViewElScroll : function(e, t) {
        this.resizer.resizeTracker.onDrag.apply(this.resizer.resizeTracker, arguments);
        this.partialResize(this.resizer, 0, 0, e);
    },

    // private
    afterResize : function (r, w, h, e) {
        var me              = this,
            resourceRecord  = r.resourceRecord,
            eventRecord     = r.eventRecord,
            oldStart        = eventRecord.getStartDate(),
            oldEnd          = eventRecord.getEndDate(),
            start           = r.start || oldStart,
            end             = r.end || oldEnd,
            sv              = me.schedulerView,
            modified        = false,
            doFinalize      = true,
            valid           = me.validatorFn.call(me.validatorFnScope || me, resourceRecord, eventRecord, start, end, e);

        Sch.util.ScrollManager.deactivate();
        sv.el.un('scroll', this.onViewElScroll , this);

        if (this.showTooltip) {
            this.getTipInstance().hide();
        }

        sv.el.select('[id^=calendar-resizer-placeholder]').remove();

        // HACK, restore original id
        // removing extra cache entry for this element
        delete Ext.cache[ r.el.id ];

        r.el.id = r.el.dom.id = r.el.id.substr(1);
        // EOF HACK
        me.resizeContext    = {
            resourceRecord  : r.resourceRecord,
            eventRecord     : eventRecord,
            start           : start,
            end             : end,
            finalize        : function() { me.finalize.apply(me, arguments); }
        };

        // Implementer could also return an object { valid : false, message : 'foo' }
        if (valid && typeof valid !== 'boolean') {
            valid = valid.valid;
        }

        if (start && end && (end - start > 0) && // Input sanity check
            ((start - oldStart !== 0) || (end - oldEnd !== 0)) && // Make sure start OR end changed
            valid !== false) {

            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,
            // to show a confirm dialog prior to applying the new values.
            doFinalize = sv.fireEvent('beforeeventresizefinalize', me, me.resizeContext, e) !== false;
            modified = true;
        } else {
            sv.repaintEventsForResource(resourceRecord);
        }

        if (doFinalize) {
            me.finalize(modified);
        }
    },

    finalize : function(updateRecord) {
        var sv = this.schedulerView;
        var context = this.resizeContext;
        var wasChanged = false;
        var checker = function () { wasChanged = true; };

        sv.eventStore.on('update', checker);

        // Without manually destroying the target, Ext Element cache gets confused
        this.resizer.target.destroy();

        if (updateRecord) {
            if (this.resizer.isStart) {
                context.eventRecord.setStartDate(context.start, false, sv.eventStore.skipWeekendsDuringDragDrop);
            } else {
                context.eventRecord.setEndDate(context.end, false, sv.eventStore.skipWeekendsDuringDragDrop);
            }
            if (!wasChanged) sv.repaintEventsForResource(context.resourceRecord);
        } else {
            sv.repaintEventsForResource(context.resourceRecord);
        }

        // Destroy resizer
        this.resizer.destroy();

        sv.eventStore.un('update', checker);
        sv.fireEvent('eventresizeend', sv, context.eventRecord);

        this.resizeContext = null;
    },

    cleanUp : function() {
        if (this.tipInstance) {
            this.tipInstance.destroy();
        }
    }
});

/**
 @class Sch.feature.Grouping
 @extends Ext.grid.feature.Grouping

 A feature extending the native Ext JS grouping feature (ftype = 'scheduler_grouping'). This features provides a
 {@link #headerRenderer} hook that you can use to render custom HTML into the group header for
 every time interval in the {@link Sch.data.TimeAxis}. This header will be automatically refreshed when changes happen in the eventStore and
 resourceStore.

 To add this feature to the scheduler:

    var scheduler = Ext.create("Sch.panel.SchedulerGrid", {

        features      : [
            {
                id                 : 'group',
                ftype              : 'scheduler_grouping',
                hideGroupedHeader  : true,
                enableGroupingMenu : false,

                headerRenderer : function (intervalStartDate, intervalEndDate, groupResources, meta) {

                    meta.cellStyle = 'background : rgba(255, 0, 0, 0.5)';
                    meta.cellCls   = 'some-css-class';

                    return 'Any text here';
                }
            }
        ],

        ...
    });
 */
Ext.define('Sch.feature.Grouping', {
    extend : 'Ext.grid.feature.Grouping',
    alias  : 'feature.scheduler_grouping',

    /**
     * This renderer method is called once for each time interval in the {@link Sch.data.TimeAxis time axis} when the scheduler is rendered.
     * Additionally, it is also called when resources and events are updated, added and removed. You can return any
     * arbitrary HTML to be added to each 'cell' of the header.
     *
     * @param {Date} intervalStartDate Start date of the current time interval
     * @param {Date} intervalEndDate End date of the current time interval
     * @param {Sch.model.Resource[]} groupResources The resources in the current group
     * @param {Object} meta A special object containing rendering properties for the current cell
     * @param {Object} meta.cellCls A CSS class to add to the cell DIV
     * @param {Object} meta.cellStyle Any inline styles to add to the cell DIV
     * @return {String}
     */
    headerRenderer      : Ext.emptyFn,

    timeAxisViewModel   : null,

    headerCellTpl       : '<tpl for=".">' +
        '<div class="sch-grid-group-hd-cell {cellCls}" style="{cellStyle}; width: {width}px;">' +
        '<span>{value}</span>' +
        '</div>' +
        '</tpl>',

    renderCells         : function (data) {
        var tplData = [];
        var viewModel = this.timeAxisViewModel;
        var ticks = viewModel.columnConfig[this.timeAxisViewModel.columnLinesFor];

        for (var i = 0; i < ticks.length; i++) {
            var meta = {};
            var value = this.headerRenderer(ticks[i].start, ticks[i].end, data.children, meta);

            meta.value = value;
            meta.width = viewModel.getPositionFromDate(ticks[i].end) - viewModel.getPositionFromDate(ticks[i].start);

            tplData.push(meta);
        }

        return this.headerCellTpl.apply(tplData);
    },

    init : function () {
        var view = this.view;
        var me   = this;

        this.callParent(arguments);

        if (typeof this.headerCellTpl === 'string') {
            this.headerCellTpl = new Ext.XTemplate(this.headerCellTpl);
        }

        // The functionality of this class only applies to the scheduling view section
        if (view.eventStore) {

            this.timeAxisViewModel = view.timeAxisViewModel;

            view.mon(this.view.eventStore, {
                add    : this.onEventAddOrRemove,
                remove : this.onEventAddOrRemove,
                update : this.onEventUpdate,
                scope  : this
            });

            this.groupHeaderTpl = new Ext.XTemplate(this.schedulerGroupHeaderTpl, {
                renderCells : Ext.Function.bind(me.renderCells, me)
            });
        }
        
        if (view.resourceStore) {
            view.mon(this.view.resourceStore, {
                add     : function (store, records) {
                    me.refreshGroupHeader(records.length ? records[0] : records);
                }
            });
        }

        //HACK
        //http://www.sencha.com/forum/showthread.php?288604-Ext-5.0.0-view.getNode%28record%29-returns-record-and-groupheader&p=1054623#post1054623
        Ext.apply(view, {
             getRowNode: function (resourceRecord) {
                 return this.retrieveNode(this.getRowId(resourceRecord), true);
             }
        });
    },

    getGroupHeaderNodeIndex : function (view, resourceRecord) {
        var store = view.resourceStore;
        // in case this method is called after 'remove' event record.getResource() will return null
        // so we pass a custom eventStore to this method
        var groupString = store.getGrouper().getGroupString(resourceRecord);
        var group = this.getGroup(groupString);

        // first child in this group is the first node that holds the grouping header
        return view.store.indexOf(group.items[0]);
    },

    onEventUpdate : function (store, record) {
        var groupField = store.getResourceStore().getGroupField();
        var rowChanged = record.previous && record.resourceIdField in record.previous;
        var newResource = record.getResource();

        if (rowChanged) {
            var oldResource = store.getResourceStore().getById(record.previous[record.resourceIdField]);

            if (oldResource && oldResource.get(groupField) !== newResource.get(groupField)) {
                this.refreshGroupHeader(oldResource);
            }
        }

        if (newResource) {
            this.refreshGroupHeader(newResource);
        }
    },

    onEventAddOrRemove : function(store, eventRecords) {
        var me      = this;
        var view    = me.view;

        Ext.Array.forEach(eventRecords, function (event) {
            var resource = event.getResource(null, view.eventStore);

            if (resource) {
                me.refreshGroupHeader(resource);
            }
        });
    },

    refreshGroupHeader : function (resource) {
        var me      = this,
            view    = me.view;

        view.refreshNode(me.getGroupHeaderNodeIndex(view, resource));
    },

    schedulerGroupHeaderTpl : '{[this.renderCells(values)]}'
});
Ext.define("Sch.eventlayout.Horizontal", {

    nbrOfBandsByResource      : null,
    bandIndexToPxConvertFn    : null,
    bandIndexToPxConvertScope : null,

    constructor : function (config) {
        Ext.apply(this, config);

        this.nbrOfBandsByResource = {};
    },


    clearCache : function (resource) {
        if (resource)
            delete this.nbrOfBandsByResource[resource.internalId];
        else
            this.nbrOfBandsByResource = {};
    },


    // Input:
    // 1. Resource record
    // 2. Array of Event models, or a function to call to receive such event records lazily
    getNumberOfBands    : function (resource, resourceEventsOrFn) {

        var nbrOfBandsByResource = this.nbrOfBandsByResource;

        if (nbrOfBandsByResource.hasOwnProperty(resource.internalId)) {
            return nbrOfBandsByResource[resource.internalId];
        }

        var resourceEvents = Ext.isFunction(resourceEventsOrFn) ? resourceEventsOrFn() : resourceEventsOrFn;

        var eventsData = Ext.Array.map(resourceEvents, function (event) {
            return {
                start : event.getStartDate(),
                end   : event.getEndDate(),
                event : event
            };
        });

        return this.applyLayout(eventsData, resource);
    },


    // TODO DOC
    applyLayout         : function (events, resource) {
        var rowEvents = events.slice();

        // Sort events by start date, and text properties.
        var me = this;

        rowEvents.sort(function (a, b) {
            return me.sortEvents(a.event, b.event);
        });

        // return a number of bands required
        return this.nbrOfBandsByResource[resource.internalId] = this.layoutEventsInBands(rowEvents);
    },


    // Override this sorting method to control in what order events are laid out. By default they are sorted by start date, then end date.
    sortEvents          : function (a, b) {

        var startA = a.getStartDate();
        var startB = b.getStartDate();
        var sameStart = (startA - startB === 0);

        if (sameStart) {
            return a.getEndDate() > b.getEndDate() ? -1 : 1;
        } else {
            return (startA < startB) ? -1 : 1;
        }
    },

    // Input: Array of event layout data
    layoutEventsInBands : function (events) {
        var verticalPosition = 0;

        do {
            var event = events[0];

            while (event) {
                // Apply band height to the event cfg
                event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertScope || this, verticalPosition, event.event);

                // Remove it from the array and continue searching
                Ext.Array.remove(events, event);

                event = this.findClosestSuccessor(event, events);
            }

            verticalPosition++;
        } while (events.length > 0);

        // Done!
        return verticalPosition;
    },


    findClosestSuccessor : function (event, events) {
        var minGap = Infinity,
            closest,
            eventEnd = event.end,
            gap,
            isMilestone = event.end - event.start === 0;

        for (var i = 0, l = events.length; i < l; i++) {
            gap = events[i].start - eventEnd;

            if (gap >= 0 && gap < minGap &&
                    // Two milestones should not overlap
                (gap > 0 || events[i].end - events[i].start > 0 || !isMilestone)) {
                closest = events[i];
                minGap = gap;
            }
        }
        return closest;
    }
});
/*
 * @class Sch.eventlayout.Vertical
 * @private
 *
 */
Ext.define("Sch.eventlayout.Vertical", {
    requires : ['Sch.util.Date'],

    view : null,

    constructor : function(config) {
        Ext.apply(this, config);
    },

    // Try to pack the events to consume as little space as possible
    applyLayout: function (events, columnWidth) {

        if (events.length === 0) {
            return;
        }

        // Sort events by start date, and text properties.
       var me = this;
       events.sort(function(a, b) { return me.sortEvents(a.event, b.event); });

        var start, end,
            view = this.view,
            D = Sch.util.Date,
            band = 1,
            startFraction,
            slot,
            totalAvailableWidth = columnWidth - (2*view.barMargin),
            firstInCluster,
            j;

        for (var i = 0, l = events.length; i < l; i++) {
            firstInCluster = events[i];
            start = firstInCluster.start;
            end = firstInCluster.end;

            slot = this.findStartSlot(events, firstInCluster);

            var cluster = this.getCluster(events, i);

            if (cluster.length > 1) {
                firstInCluster.left = slot.start;
                firstInCluster.width = slot.end - slot.start;

                // If there are multiple slots and events in the cluster have multiple start dates, group all same-start events into first slot
                j = 1;

                while(j < (cluster.length-1) && cluster[j+1].start - firstInCluster.start === 0) {
                    j++;
                }

                // See if there's more than 1 slot available for this cluster, if so - first group in cluster consumes the entire first slot
                var nextSlot = this.findStartSlot(events, cluster[j]);
                if (nextSlot && nextSlot.start < 0.8) {
                    cluster = cluster.slice(0, j);
                }
            }

            var count = cluster.length,
                barWidth = (slot.end-slot.start)/count;

            // Apply fraction values
            for (j = 0; j < count; j++) {
                cluster[j].width = barWidth;
                cluster[j].left = slot.start + (j*barWidth);
            }

            i += count - 1;
        }

        for (i = 0, l = events.length; i < l; i++) {
            events[i].width = events[i].width*totalAvailableWidth;
            events[i].left = view.barMargin + (events[i].left*totalAvailableWidth);
        }
    },

    findStartSlot : function(events, event) {
        var priorOverlappers = this.getPriorOverlappingEvents(events, event),
            i;

        if (priorOverlappers.length === 0) {
            return {
                start : 0,
                end : 1
            };
        }

        for (i = 0; i < priorOverlappers.length ; i++) {
            if (i === 0 && priorOverlappers[0].left > 0) {
                return {
                    start : 0,
                    end : priorOverlappers[0].left
                };
            } else if (priorOverlappers[i].left + priorOverlappers[i].width < (i < priorOverlappers.length - 1 ? priorOverlappers[i+1].left : 1)) {
                return {
                    start : priorOverlappers[i].left + priorOverlappers[i].width,
                    end : i < priorOverlappers.length - 1 ? priorOverlappers[i+1].left : 1
                };
            }
        }

        return false;
    },

    getPriorOverlappingEvents : function(events, event) {
        var D = Sch.util.Date,
            start = event.start,
            end = event.end,
            overlappers = [];

        for (var i = 0, l = Ext.Array.indexOf(events, event); i < l ; i++) {
            if (D.intersectSpans(start, end, events[i].start, events[i].end)) {
                overlappers.push(events[i]);
            }
        }

        overlappers.sort(this.sortOverlappers);

        return overlappers;
    },

    sortOverlappers : function(e1, e2) {
        return e1.left < e2.left ? -1 : 1;
    },

    getCluster : function(events, startIndex) {
        if (startIndex >= events.length-1) {
            return [events[startIndex]];
        }

        var evts    = [events[startIndex]],
            start   = events[startIndex].start,
            end     = events[startIndex].end,
            l       = events.length,
            D       = Sch.util.Date,
            i       = startIndex+1;

        while(i < l && D.intersectSpans(start, end, events[i].start, events[i].end)) {
            evts.push(events[i]);
            start = D.max(start, events[i].start);
            end = D.min(events[i].end, end);
            i++;
        }

        return evts;
    },

    sortEvents : function (a, b) {

        var startA = a.getStartDate(), endA = a.getEndDate();
        var startB = b.getStartDate(), endB = b.getEndDate();

        var sameStart = (startA - startB === 0);

        if (sameStart) {
            return endA > endB ? -1 : 1;
        } else {
            return (startA < startB) ? -1 : 1;
        }

    }
});

Ext.define('Sch.eventlayout.Table', {
    extend  : 'Sch.eventlayout.Horizontal',
    
    timeAxisViewModel : null,
    
    layoutEventsInBands : function (events) {
        var timeAxisViewModel   = this.timeAxisViewModel;
        var timeAxis            = timeAxisViewModel.timeAxis;
        
        var verticalPosition = 0;

        do {
            var event = events[0];

            while (event) {
                // Apply band height to the event cfg
                event.top = this.bandIndexToPxConvertFn.call(this.bandIndexToPxConvertScope || this, verticalPosition, event.event);

                var tick    = Math.floor(timeAxis.getTickFromDate(event.start));
                var left    = this.timeAxisViewModel.getPositionFromDate(timeAxis.getAt(tick).getStartDate());
                var width   = this.timeAxisViewModel.getTickWidth();
                
                event.left = left;
                event.width = width;
                
                // Remove it from the array and continue searching
                Ext.Array.remove(events, event);

                event = this.findClosestSuccessor(event, events);
            }

            verticalPosition++;
        } while (events.length > 0);

        // Done!
        return verticalPosition;
    },
    
    findClosestSuccessor    : function(event, events) {
        var minGap = Infinity,
            closest,
            eventEnd = event.end,
            gap;
            
        var timeAxis    = this.timeAxisViewModel.timeAxis;
        var tickIndex   = Math.floor(timeAxis.getTickFromDate(event.start));
        var tick        = timeAxis.getAt(tickIndex);

        for (var i = 0, l = events.length; i < l; i++) {
            gap = events[i].start - eventEnd;

            if (gap >= 0 && gap < minGap && events[i].start >= tick.getEndDate()) {
                closest = events[i];
                minGap = gap;
            }
        }
        return closest;
    }
});
/**
@class Sch.column.Summary
@extends Ext.grid.column.Column

A Column showing the currently allocated time for the resources in the grid. It will simply summarize the durations **of the events that are in the current view**.
The information can be displayed as either a time unit or a percentage of the available time.

To add this column to the scheduler:

        var summaryCol = Ext.create("Sch.column.Summary", {
            header      : 'Time allocated',
            width       : 80,
            showPercent : false 
        });

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            resourceStore   : resourceStore,
            eventStore      : eventStore,
            
            columns         : [
                ...
                summaryCol,
                ...
            ]
        });

*/
Ext.define('Sch.column.Summary', {
    extend          : "Ext.grid.column.Column",
    alias           : [
        "widget.summarycolumn",
        "plugin.scheduler_summarycolumn" /*TODO REMOVE for 3.0 */
    ],

    // TODO REMOVE THESE FOR 3.0 (BREAKING)
    mixins          : ['Ext.AbstractPlugin'],
    alternateClassName : 'Sch.plugin.SummaryColumn',
    init            : Ext.emptyFn,
    // -------- EOF TODO

    lockableScope   : 'top',

    /**
     * @cfg {Boolean} showPercent True to show percentage values, false to show summarized time. Default value is `false`.
     */
    showPercent     : false,

    /**
     * @cfg {Number} nbrDecimals The number of decimals to show, only applicable when `showPercent` is set to false
     */
    nbrDecimals     : 1,

    sortable        : false,
    fixed           : true,
    menuDisabled    : true,

    width           : 80,
    dataIndex       : '_sch_not_used',

    timeAxis        : null,
    eventStore      : null,

    constructor     : function(config){
        this.scope = this;

        this.callParent(arguments);

        this.on('beforerender', this.onMyBeforeRender, this);
    },

    onMyBeforeRender    : function() {

        var pnl = this.up('tablepanel[lockable=true]');

        this.timeAxis = pnl.getTimeAxis();
        this.eventStore = pnl.getEventStore();
    },


    renderer : function(v, p, record){
        var timeAxis        = this.timeAxis,
            eventStore      = this.eventStore,
            viewStart       = timeAxis.getStart(),
            viewEnd         = timeAxis.getEnd(),
            retVal          = 0,
            totalAllocatedMinutesInView = this.calculate(eventStore.getEventsForResource(record), viewStart, viewEnd);

        if (totalAllocatedMinutesInView <= 0) {
            return '';
        }

        if (this.showPercent) {
            var timeInView = Sch.util.Date.getDurationInMinutes(viewStart, viewEnd);

            return (Math.round((totalAllocatedMinutesInView * 100)/ timeInView)) + ' %';
        } else {
            if (totalAllocatedMinutesInView > 1440) {
                return (totalAllocatedMinutesInView / 1440).toFixed(this.nbrDecimals) + ' ' + Sch.util.Date.getShortNameOfUnit("DAY");
            }
            if (totalAllocatedMinutesInView >= 30) {
                return (totalAllocatedMinutesInView / 60).toFixed(this.nbrDecimals) + ' ' + Sch.util.Date.getShortNameOfUnit("HOUR");
            }
            return totalAllocatedMinutesInView + ' ' + Sch.util.Date.getShortNameOfUnit("MINUTE");
        }
    },

    calculate : function(eventRecords, viewStart, viewEnd){
        var totalTime = 0,
            eventStart,
            eventEnd,
            D = Sch.util.Date;

        Ext.each(eventRecords, function(eRec) {
            eventStart = eRec.getStartDate();
            eventEnd = eRec.getEndDate();

            if (D.intersectSpans(viewStart, viewEnd, eventStart, eventEnd)) {
               totalTime += D.getDurationInMinutes(D.max(eventStart, viewStart), D.min(eventEnd, viewEnd));
            }
        });

        return totalTime;
    }
});
/*
@class Sch.column.Resource
@extends Ext.grid.Column
@private

A Column representing a resource, used only in vertical orientation. By default this column will use the resource
name as the header text. To get complete control over the rendering, you can use your own custom Column class by
using the {@link Sch.mixin.SchedulerPanel#resourceColumnClass resourceColumnClass} config on your SchedulerPanel.

*/
Ext.define("Sch.column.Resource", {
    extend          : "Ext.grid.Column",
    
    alias           : "widget.resourcecolumn",

    /*
     * Default resource column properties
     */
    align           : 'center',
    menuDisabled    : true,
    hideable        : false,
    sortable        : false,
    locked          : false,
    lockable        : false,
    draggable       : false,
    enableLocking   : false,

    /*
     * @property {Sch.model.Resource} model The resource model associated with this column
     * Default resource column properties
     */
    model           : null,

    initComponent     : function() {
        this.tdCls = (this.tdCls || '') + ' sch-timetd';
        this.cls = (this.cls || '') + ' sch-resourcecolumn-header';

        this.callParent(arguments);
    }
});
/*
 * @class Sch.column.timeAxis.Vertical
 * @private
 * @extends Ext.grid.column.Column
 * A Column representing the time axis in vertical orientation
 * @constructor
 * @param {Object} config The configuration options
 */
Ext.define('Sch.column.Day', {

    extend : 'Ext.grid.column.Column',
    alias  : 'widget.weekview-day',
    align  : 'center',

    // date range for this Day column
    start  : null,
    end    : null,

    draggable       : false,
    groupable       : false,
    hideable        : false,
    sortable        : false,
    menuDisabled    : true,
    enableLocking   : false,
    flex            : 1,
    resizable       : false,
    
    tdCls  : 'sch-timetd',

    initComponent : function () {

        var now = new Date();

        this.addCls('sch-daycolumn-header');

        if (this.isWeekend()) {
            this.addCls('sch-daycolumn-header-weekend');

            this.tdCls  = (this.tdCls || '') + ' sch-daycolumn-weekend';
        }

        if (this.start.getDate()    === now.getDate() &&
            this.start.getMonth()   === now.getMonth() &&
            this.start.getYear()    === now.getYear())
        {
            this.addCls('sch-daycolumn-header-today');
            this.tdCls  = (this.tdCls || '') + ' sch-daycolumn-today';
        }

        this.callParent(arguments);
    },

    isWeekend : function() {
        var day = this.start.getDay();

        return day === 6 || day === 0;
    }
});


/**
@class Sch.view.model.TimeAxis
@extends Ext.util.Observable
@private

This class is an internal view model class, describing the visual representation of a {@link Sch.data.TimeAxis timeaxis}.
The config for the header rows is described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}.
To calculate the widths of each cell in the time axis, this class requires:

- availableWidth  - The total width available for the rendering
- tickWidth     - The fixed width of each cell in the lowest header row. This value is normally read from the 
{@link Sch.preset.ViewPreset viewPreset} but this can also be updated programmatically using {@link #setTickWidth}

Normally you should not interact with this class directly.

*/

if (!Ext.ClassManager.get("Sch.view.model.TimeAxis")) {

Ext.define("Sch.view.model.TimeAxis", {
    extend: 'Ext.util.Observable',

    requires: [
        'Ext.Date',
        'Sch.util.Date',
        'Sch.preset.Manager'
    ],

    /**
     * @cfg {Sch.data.TimeAxis} timeAxis
     * The time axis providing the underlying data to be visualized
     */
    timeAxis            : null,

    /**
     * @cfg {Number} availableWidth
     * The available width, this is normally not known by the consuming UI component using this model class until it has been fully rendered.
     * The consumer of this model should call {@link #setAvailableWidth} when its width has changed.
     */
    availableWidth      : 0,

    /**
     * @cfg {Number} tickWidth
     * The "tick width" to use for the cells in the bottom most header row.
     * This value is normally read from the {@link Sch.preset.ViewPreset viewPreset}
     */
    tickWidth           : 100,

    /**
     * @cfg {Boolean} snapToIncrement
     * true if there is a requirement to be able to snap events to a certain view resolution.
     * This has implications of the {@link #tickWidth} that can be used, since all widths must be in even pixels.
     */
    snapToIncrement     : false,
    
    /**
     * @cfg {Boolean} forceFit
     * true if cells in the bottom-most row should be fitted to the {@link #availableWidth available width}.
     */
    forceFit            : false,
    
    headerConfig        : null,

    // cached linear version of `headerConfig` - array of levels, starting from top 
    headers             : null,
    mainHeader          : 0,
    
    
    // the width of time axis column in vertical 
    timeAxisColumnWidth : null,
    // the width of resource column in vertical
    resourceColumnWidth : null,
    
    // width of the columns in calendar view
    calendarColumnWidth : null,
    
    // aka tickWidth in horizontal
    timeColumnWidth     : null,
    
    rowHeightHorizontal : null,
    rowHeightVertical   : null,
    
    mode                : 'horizontal', // or 'vertical'
    

    //used for Exporting. Make sure the tick columns are not recalculated when resizing.
    suppressFit         : false,

    // Since this model may be shared by multiple synced timelinePanels, we need to keep count of usage to know when we can destroy the view model.
    refCount            : 0,

    // cache of the config currently used.
    columnConfig        : {},
    
    // the view preset name to apply initially
    viewPreset          : null,
    
    // The default header level to draw column lines for
    columnLinesFor      : 'middle',

    eventStore          : null,

    originalTickWidth   : null,

    constructor: function (config) {
        var me = this;
        Ext.apply(this, config);

        if (this.viewPreset) {
            if (this.viewPreset instanceof Sch.preset.ViewPreset) {
                this.consumeViewPreset(this.viewPreset);
            } else {
                var preset      = Sch.preset.Manager.getPreset(this.viewPreset);
                
                preset && this.consumeViewPreset(preset);
            }
        }

        /**
        * @event update
        * Fires after the model has been updated.
        * @param {Sch.view.model.TimeAxis} model The model instance
        */

        // When time axis is changed, reconfigure the model
        me.timeAxis.on('reconfigure', me.onTimeAxisReconfigure, me);

        this.callParent(arguments);
    },

    destroy : function() {
        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);
    },

    
    onTimeAxisReconfigure: function (timeAxis, suppressRefresh) {
        if (!suppressRefresh) {
            this.update();
        }
    },
    
    reconfigure : function (config) {
        // clear the cached headers
        this.headers        = null;

        Ext.apply(this, config);

        switch (this.mode) {
            case 'horizontal'   :
                this.setTickWidth(this.timeColumnWidth);
                break;
            case 'vertical'     : 
                this.setTickWidth(this.rowHeightVertical);
                break;
            case 'calendar'     :
                this.setTickWidth(this.rowHeightVertical);
                break;
        }
        
        this.fireEvent('reconfigure', this);
    },

    /**
    *  Returns a model object of the current timeAxis, containing an array representing the cells for each level in the header. 
    *  This object will always contain a 'middle' array, and depending on the {@link Sch.preset.ViewPreset#headerConfig} it can also contain a 'top' and 'bottom' property.
    *  @return {Object} The model representing each cell (with start date and end date) in the timeline representation.
    */
    getColumnConfig : function() {
        return this.columnConfig;
    },

    /**
    *  Updates the view model current timeAxis configuration and available width.
    *  @param {Number} availableWidth The available width for the rendering of the axis (used in forceFit mode)
    */
    update: function (availableWidth, suppressEvent) {
        var timeAxis        = this.timeAxis,
            headerConfig    = this.headerConfig;

        this.availableWidth = Math.max(availableWidth || this.availableWidth, 0);

        if (!Ext.isNumber(this.availableWidth)) {
            throw 'Invalid available width provided to Sch.view.model.TimeAxis';
        }
        
        if (this.forceFit && this.availableWidth <= 0) {
            // No point in continuing
            return;
        }

        this.columnConfig   = {};
        
        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering
        for (var pos in headerConfig) {
            if (headerConfig[pos].cellGenerator) {
                this.columnConfig[pos] = headerConfig[pos].cellGenerator.call(this, timeAxis.getStart(), timeAxis.getEnd());
            } else {
                this.columnConfig[pos] = this.createHeaderRow(pos, headerConfig[pos]);
            }
        }
        
        // The "column width" is considered to be the width of each tick in the lowest header row and this width 
        // has to be same for all cells in the lowest row.
        var tickWidth       = this.calculateTickWidth(this.originalTickWidth);

        if (!Ext.isNumber(tickWidth) || tickWidth <= 0) {
            throw 'Invalid column width calculated in Sch.view.model.TimeAxis';
        }

        this.updateTickWidth(tickWidth);
        
        if (!suppressEvent) this.fireEvent('update', this);
    },

    // private
    createHeaderRow: function (position, headerConfig) {
        var cells   = [],
            me      = this,
            align   = headerConfig.align,
            today   = Ext.Date.clearTime(new Date());

        me.forEachInterval(position, function (start, end, i) {
            var colConfig   = {
                align       : align,
                start       : start,
                end         : end,
                headerCls   : ''
            };

            if (headerConfig.renderer) {
                colConfig.header = headerConfig.renderer.call(headerConfig.scope || me, start, end, colConfig, i, me.eventStore);
            } else {
                colConfig.header = Ext.Date.format(start, headerConfig.dateFormat);
            }

            // To be able to style individual day cells, weekends or other important days
            if (headerConfig.unit === Sch.util.Date.DAY && (!headerConfig.increment || headerConfig.increment === 1)) {
                colConfig.headerCls += ' sch-dayheadercell-' + start.getDay();

                if (Ext.Date.clearTime(start, true) - today === 0) {
                    colConfig.headerCls += ' sch-dayheadercell-today';
                }
            }

            cells.push(colConfig);
        });

        return cells;
    },

    /**
     *  Returns the distance for a timespan with the given start and end date.
     *  @return {Number} The width of the time span
     */
    getDistanceBetweenDates: function (start, end) {
        return Math.round(this.getPositionFromDate(end, true) - this.getPositionFromDate(start));
    },

    /**
     *  Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.
     *  @param {Date} date, the date to query for.
     *  @param {Boolean} [isEnd] true to return bottom coordinate for calendar view 
     *  @returns {Number} the coordinate representing the date
     */
    getPositionFromDate: function (date, isEnd) {
        if (this.mode === 'calendar') {
            var rowHeight       = this.rowHeightCalendar || this.rowHeightVertical;
            var headers         = this.getHeaders();
            var startDate       = this.timeAxis.getStart();
            var UD              = Sch.util.Date;

            // calendar view inherits vertical view so this method should only return vertical coordinate
            var verticalDate    = UD.mergeDates(startDate, date, headers[1].unit);
            var verticalStart   = UD.getDurationInUnit(startDate, verticalDate, headers[1].unit, true) * rowHeight;
            var result          = Math.round(verticalStart);
            
            if (result === 0 && isEnd) {
                return this.calendarRowsAmount * rowHeight;
            }
            
            return result;
        } else {
            var pos     = -1,
                tick    = this.timeAxis.getTickFromDate(date);
    
            if (tick >= 0) {
                pos     = Math.round(this.tickWidth * (tick - this.timeAxis.visibleTickStart));
            }
    
            return pos;
        }
    },

    /**
     * Gets the date for a position on the time axis
     * @param {Number} position The page X or Y coordinate
     * @param {String} roundingMethod The rounding method to use
     * @returns {Date} the Date corresponding to the xy coordinate
     */
    getDateFromPosition: function (position, roundingMethod) {
        if (this.mode === 'calendar') {
            var rowHeight   = this.rowHeightCalendar || this.rowHeightVertical;
            var UD          = Sch.util.Date;
            var startDate   = this.timeAxis.getStart();
            var headers     = this.getHeaders();
            
            var horizontalDate  = UD.add(startDate, headers[0].splitUnit, Math.floor(position[0] / this.calendarColumnWidth));
            
            var first = this.timeAxis.first();
            var millisecondsPerPixel = (first.get('end') - first.get('start')) / rowHeight;

            var result      = UD.add(horizontalDate, UD.MILLI, Math.round(position[1] * millisecondsPerPixel));
            if (roundingMethod) {
                result  = this.timeAxis[roundingMethod + 'Date'](result);
            }
            
            return result;
            
        } else {
            var tick        = position / this.getTickWidth() + this.timeAxis.visibleTickStart,
                nbrTicks    = this.timeAxis.getCount();
    
            if (tick < 0 || tick > nbrTicks) {
                return null;
            }
    
            return this.timeAxis.getDateFromTick(tick, roundingMethod);
        }
    },

    /**
    * Returns the amount of pixels for a single unit
    * @private
    * @return {String} The unit in pixel
    */
    getSingleUnitInPixels: function (unit) {
        return Sch.util.Date.getUnitToBaseUnitRatio(this.timeAxis.getUnit(), unit) * this.tickWidth / this.timeAxis.increment;
    },

    /**
     * [Experimental] Returns the pixel increment for the current view resolution.
     * @return {Number} The width increment
     */
    getSnapPixelAmount: function () {
        if (this.snapToIncrement) {
            var resolution = this.timeAxis.getResolution();
            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);
        } else {
            return 1;
        }
    },

    /**
    * Returns the current time column width (the width of a cell in the lowest header row)
    * @return {Number} The width
    */
    getTickWidth: function () {
        return this.tickWidth;
    },

    /**
    * Sets a new tick width (the width of a time cell in the bottom-most time axis row)
    * @param {Number} width The width
    */
    setTickWidth: function (width, suppressEvent) {
        this.originalTickWidth = width;

        this.updateTickWidth(width);

        this.update(null, suppressEvent);
    },
    
    
    updateTickWidth : function (value) {
        this.tickWidth = value;
        
        switch (this.mode) {
            case 'horizontal'   : this.timeColumnWidth = value; break;
            case 'vertical'     : this.rowHeightVertical = value; break;
            case 'calendar'     : this.rowHeightVertical = value; break;
        }
    },
    

    /**
    * Returns the total width of the time axis representation.
    * @return {Number} The width
    */
    getTotalWidth: function () {
        return Math.round(this.tickWidth * this.timeAxis.getVisibleTickTimeSpan());
    },

    // Calculates the time column width based on the value defined viewPreset "timeColumnWidth". It also checks for the forceFit view option
    // and the snapToIncrement, both of which impose constraints on the time column width configuration.
    calculateTickWidth: function (proposedWidth) {
        var forceFit        = this.forceFit;
        var timeAxis        = this.timeAxis;
        
        var width           = 0,
            timelineUnit    = timeAxis.getUnit(),
            ratio           = Number.MAX_VALUE,
            DATE            = Sch.util.Date;

        if (this.snapToIncrement) {
            var resolution  = timeAxis.getResolution();

            ratio           = DATE.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;
        } else {
            var measuringUnit = DATE.getMeasuringUnit(timelineUnit);
    
            ratio           = Math.min(ratio, DATE.getUnitToBaseUnitRatio(timelineUnit, measuringUnit));
        }
            
        if (!this.suppressFit){
            var fittingWidth    = Math[ forceFit ? 'floor' : 'round' ](this.getAvailableWidth() / timeAxis.getVisibleTickTimeSpan());

            width           = (forceFit || proposedWidth < fittingWidth) ? fittingWidth : proposedWidth;
            
            if (ratio > 0 && (!forceFit || ratio < 1)) {
                // For touch, make sure we always fill the available space with forceFit (to not show edges of side-time-pickers)
                var method  = Ext.versions.touch && forceFit? 'ceil' : (forceFit ? 'floor' : 'round');

                width       = Math.round(Math.max(1, Math[method](ratio * width)) / ratio);
            }
        } else {
            width           = proposedWidth;
        }

        return width;
    },

    /**
    * Returns the available width for the time axis representation.
    * @return {Number} The available width
    */
    getAvailableWidth: function () {
        return this.availableWidth;
    },

    /**
    * Sets the available width for the model, which (if changed) will cause it to update its contents and fire the {@link #event-update} event.
    * @param {Number} width The width
    */
    setAvailableWidth: function (width) {
//        if (width && width != this.availableWidth) this.update(width);

        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't
        // occupy the available space - and gets stretched
        this.availableWidth = Math.max(0, width);

        var newTickWidth = this.calculateTickWidth(this.originalTickWidth);

        if (newTickWidth !== this.tickWidth) {
            this.update();
        }
    },

    /**
     * This function fits the time columns into the available space in the time axis column.
     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.
     */
    fitToAvailableWidth: function (suppressEvent) {
        var proposedWidth   = Math.floor(this.availableWidth / this.timeAxis.getVisibleTickTimeSpan());

        this.setTickWidth(proposedWidth, suppressEvent);
    },

    /**
    * Sets the forceFit value for the model, which will cause it to update its contents and fire the {@link #event-update} event.
    * @param {Boolean} value 
    */
    setForceFit: function (value) {
        if (value !== this.forceFit) {
            this.forceFit = value;
            this.update();
        }
    },

    /**
    * Sets the snapToIncrement value for the model, which will cause it to update its contents and fire the {@link #event-update} event.
    * @param {Boolean} value 
    */
    setSnapToIncrement: function (value) {
        if (value !== this.snapToIncrement) {
            this.snapToIncrement = value;
            this.update();
        }
    },
    
    
    getViewRowHeight : function () {
        var val = this.mode == 'horizontal' ? this.rowHeightHorizontal : this.rowHeightVertical;

        // Sanity check
        if (!val) throw 'rowHeight info not available';

        return val;
    },
    
    
    setViewRowHeight : function (value, suppressEvent) {
        var isHorizontal    = this.mode === 'horizontal';

        var property        = 'rowHeight' + Ext.String.capitalize(this.mode);
        
        if (this[ property ] != value) {
            this[ property ]    = value;
            
            if (isHorizontal) {
                if (!suppressEvent) this.fireEvent('update', this);
            } else {
                this.setTickWidth(value, suppressEvent);
            }
        }
    },

    setViewColumnWidth : function (value, suppressEvent) {
        switch (this.mode) {
            case 'horizontal'   : this.setTickWidth(value, suppressEvent); break;
            case 'vertical'     : this.resourceColumnWidth = value; break;
            case 'calendar'     : this.calendarColumnWidth = value; break;
        }

        if (!suppressEvent) {
            this.fireEvent('columnwidthchange', this, value);
        }
    },
    

    getHeaders : function () {
        if (this.headers) return this.headers;
        
        var headerConfig        = this.headerConfig;
        
        // main header is always `middle` (which is always requires to present in `headerConfig`)
        // `top` may absent, in this case `middle` will be on 0-th index
        this.mainHeader         = headerConfig.top ? 1 : 0;
        
        return this.headers     = [].concat(headerConfig.top || [], headerConfig.middle || [], headerConfig.bottom || []);
    },
    
    
    getMainHeader : function () {
        return this.getHeaders()[ this.mainHeader ];
    },
    
    
    getBottomHeader : function () {
        var headers     = this.getHeaders();
        
        return headers[ headers.length - 1 ];
    },
    
    
    /**
    * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
    * Return false to break the iteration.
    * @param {String} position 'main' (middle), 'top' or 'bottom'
    * @param {Function} iteratorFn The function to call, will be called with start date, end date and "tick index"
    * @param {Object} scope (optional) The "this" object to use for the function call
    */
    forEachInterval : function (position, iteratorFn, scope) {
        scope               = scope || this;

        var headerConfig    = this.headerConfig;
        
        if (!headerConfig) return;     // Not initialized

        if (position === 'top' || (position === 'middle' && headerConfig.bottom)) {
            var header      = headerConfig[ position ];
            
            this.timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, scope);
        } else {
            // This is the lowest header row, which should be fed the data in the tickStore
            this.timeAxis.each(function(r, index) { 
                return iteratorFn.call(scope, r.data.start, r.data.end, index);
            });
        }
    },

    /**
    * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
    * Return false to break the iteration.
    * @protected
    * @param {Function} iteratorFn The function to call
    * @param {Object} scope (optional) The "this" object to use for the function call
    */
    forEachMainInterval : function (iteratorFn, scope) {
        this.forEachInterval('middle', iteratorFn, scope);
    },
    
    
    consumeViewPreset : function (preset) {
        // clear the cached headers
        this.headers        = null;
        
        var isHorizontal    = this.mode == 'horizontal';

        Ext.apply(this, {
            headerConfig        : preset.headerConfig,
            columnLinesFor      : preset.columnLinesFor || 'middle', 
            rowHeightHorizontal : preset.rowHeight,
            tickWidth           : isHorizontal ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60,
            timeColumnWidth     : preset.timeColumnWidth,
            
            // timeColumnWidth is also used for row height in vertical mode
            rowHeightVertical   : preset.timeRowHeight || preset.timeColumnWidth || 60,
            timeAxisColumnWidth : preset.timeAxisColumnWidth,
            resourceColumnWidth : preset.resourceColumnWidth || 100
        });

        this.originalTickWidth = this.tickWidth;
    }
});


}
/**
* @class Sch.view.HorizontalTimeAxis
* @extends Ext.util.Observable
* @private
*
* A visual representation of the time axis described in the {@link Sch.preset.ViewPreset#headerConfig headerConfig}. 
* Normally you should not interact with this class directly.
*/
Ext.define("Sch.view.HorizontalTimeAxis", {
    extend: 'Ext.util.Observable',

    requires: [
        'Ext.XTemplate'
    ],

    /**
    * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it. 
    */
    trackHeaderOver: true,

    /**
    * @cfg {Number} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class to the row (for special styling). 
    *            Defaults to 15px.
    */
    compactCellWidthThreshold: 15,

    baseCls : 'sch-column-header',
    tableCls : 'sch-header-row',

    // a 2nd template for the 2nd mode, w/o `containerEl`
    headerHtmlRowTpl:
        '<table border="0" cellspacing="0" cellpadding="0" style="width: {totalWidth}px; {tstyle}" class="{{tableCls}} sch-header-row-{position} {cls}">' +
            '<thead>' +
                '<tr>' +
                    '<tpl for="cells">' +
                        '<td class="{{baseCls}} {headerCls}" style="position : static; text-align: {align}; width: {width}px; {style}" tabIndex="0"' +
                            'headerPosition="{parent.position}" headerIndex="{[xindex-1]}">' +
                                '<div class="sch-simple-timeheader">{header}</div>' +
                        '</td>' +
                    '</tpl>' +
                '</tr>' +
            '</thead>' +
        '</table>',
        
    // TODO DOCS
    model           : null,

    // TODO DOCS
    hoverCls        : '',
    
    // optional
    // this view class will work in 2 modes - one with provided `containerEl` and one w/o it
    containerEl     : null,

    // Only used for IE10 in Touch Scheduler since display:box is too buggy in IE.
    height : null,

    /**
     * @event timeheaderclick
     * Fires after a click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event timeheaderdblclick
     * Fires after a double click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The end date of the header cell
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event timeheadercontextmenu
     * Fires after a right click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event refresh
     * Fires after the view has been updated, (after the time axis has been reconfigured,
     * or as a result of time column width change or available schedule width change).
     * @param {Sch.view.HorizontalTimeAxis} timeAxisView The time axis view
     */

    constructor: function (config) {
        var me = this;
        var isTouch = !!Ext.versions.touch;
        var clickEventName = isTouch ? 'tap' : 'click';

        Ext.apply(this, config);
        me.callParent(arguments);

        me.model.on('update', me.onModelUpdate, this, { priority : 5 });

        me.containerEl = Ext.get(me.containerEl);

        if (!(me.headerHtmlRowTpl instanceof Ext.Template)) {
            me.headerHtmlRowTpl = me.headerHtmlRowTpl.replace('{{baseCls}}', this.baseCls).replace('{{tableCls}}', this.tableCls);
            me.headerHtmlRowTpl = new Ext.XTemplate(me.headerHtmlRowTpl);
        }

        if (me.trackHeaderOver && me.hoverCls) {
            me.containerEl.on({
                mousemove   : me.highlightCell,
                delegate    : '.sch-column-header',
                scope       : me
            });

            me.containerEl.on({
                mouseleave  : me.clearHighlight,
                scope       : me
            });
        }

        var listenerCfg = {
            scope       : this, 
            delegate    : '.sch-column-header'
        };

        if (isTouch) {
            listenerCfg.tap = this.onElClick('tap');
            listenerCfg.doubletap = this.onElClick('doubletap');

        } else {
            listenerCfg.click = this.onElClick('click');
            listenerCfg.dblclick = this.onElClick('dblclick');
            listenerCfg.contextmenu = this.onElClick('contextmenu');
        }

        me._listenerCfg = listenerCfg;
        if (me.containerEl) me.containerEl.on(listenerCfg);
    },

    destroy : function() {
        var me = this;
        
        if (me.containerEl) { 
            me.containerEl.un(me._listenerCfg);
            
            me.containerEl.un({
                mousemove   : me.highlightCell,
                delegate    : '.sch-simple-timeheader',
                scope       : me
            });
    
            me.containerEl.un({
                mouseleave: me.clearHighlight,
                scope: me
            });
        }

        me.model.un({
            update  : me.onModelUpdate,
            scope   : me
        });
    },

    onModelUpdate: function () {
        this.render();
    },
    
    
    getHTML : function (header, meta, column) {
        var columnConfig        = this.model.getColumnConfig();
        var totalWidth          = this.model.getTotalWidth();
        var nbrRows             = Ext.Object.getKeys(columnConfig).length;
        var rowHeight           = this.height ? this.height / nbrRows : 0;
        var html                = '';
        
        var currentCellWidth;
        
        if (columnConfig.top) {
            this.embedCellWidths(columnConfig.top);
            
            html                += this.headerHtmlRowTpl.apply({
                totalWidth      : totalWidth,
                cells           : columnConfig.top,
                position        : 'top',
                tstyle          : 'border-top : 0;' + (rowHeight ?  'height:' + rowHeight + 'px' : '')
            });
        }
        
        if (columnConfig.middle) {
            this.embedCellWidths(columnConfig.middle);

            html                += this.headerHtmlRowTpl.apply({
                totalWidth      : totalWidth,
                cells           : columnConfig.middle,
                position        : 'middle',
                tstyle          : (columnConfig.top ? '' : 'border-top : 0;') + (rowHeight ?  'height:' + rowHeight + 'px' : ''),
                cls             : !columnConfig.bottom && this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }
        
        if (columnConfig.bottom) {
            this.embedCellWidths(columnConfig.bottom);
            
            html                += this.headerHtmlRowTpl.apply({
                totalWidth      : totalWidth,
                cells           : columnConfig.bottom,
                position        : 'bottom',
                tstyle          : (rowHeight ? 'height:' + rowHeight + 'px' : ''),
                cls             : this.model.getTickWidth() <= this.compactCellWidthThreshold ? 'sch-header-row-compact' : ''
            });
        }

        return html + '<div class="sch-header-secondary-canvas"></div>';
    },
    

    // Outputs the tables and cells based on the header row config in the active viewPreset
    render: function () {
        if (!this.containerEl) return;
        
        var innerCt     = this.containerEl,
            ctDom       = innerCt.dom,
            oldDisplay  = ctDom.style.display,
            columnConfig = this.model.getColumnConfig(),
            parent      = ctDom.parentNode;

        ctDom.style.display = 'none';
        parent.removeChild(ctDom);

        var renderData = this.getHTML();

        ctDom.innerHTML = renderData;

        if (!columnConfig.top && !columnConfig.middle) {
            this.containerEl.addCls('sch-header-single-row');
        } else {
            this.containerEl.removeCls('sch-header-single-row');
        }

        parent && parent.appendChild(ctDom);
        ctDom.style.display = oldDisplay;
        
        this.fireEvent('refresh', this);
    },

    embedCellWidths : function (cells) {
        // For desktop only, flags such as Ext.isSafari only exist in Ext JS (in touch it's set in Ext.os)
        var widthAdjust     = (Ext.isIE7 || (Ext.isSafari && !Ext.supports.Touch)) ? 1 : 0;

        for (var i = 0; i < cells.length; i++) {
            var cell        = cells[ i ];
            var width       = this.model.getDistanceBetweenDates(cell.start, cell.end);
            
            if (width) {
                cell.width  = width - (i ? widthAdjust : 0);
            } else {
                cell.width  = 0;
                cell.style  = 'display: none';
            }
        }
    },
    

    // private
    onElClick: function(eventName) {
        return function (event, target) { 
            // Normalize ST vs Ext JS (Ext passes the delegated target as the target argument, ST passes the clicked DOM node)
            target = event.delegatedTarget || target;
            
            var position        = Ext.fly(target).getAttribute('headerPosition'),
                index           = Ext.fly(target).getAttribute('headerIndex'),
                headerConfig    = this.model.getColumnConfig()[position][index];
        
            this.fireEvent('timeheader' + eventName, this, headerConfig.start, headerConfig.end, event);
        };
    },


    highlightCell: function (e, cell) {
        var me = this;

        if (cell !== me.highlightedCell) {
            me.clearHighlight();
            me.highlightedCell = cell;
            Ext.fly(cell).addCls(me.hoverCls);
        }
    },

    clearHighlight: function () {
        var me = this,
            highlighted = me.highlightedCell;

        if (highlighted) {
            Ext.fly(highlighted).removeCls(me.hoverCls);
            delete me.highlightedCell;
        }
    }
    /* EOF Proxied model methods */
});



/*
 * @class Sch.column.timeAxis.Horizontal
 * @extends Ext.grid.column.Column
 *
 *
 * A simple grid column providing a visual representation of the time axis. This class does not produce any real Ext JS grid columns, instead it just renders a Sch.view.HorizontalTimeAxis inside its element.
 * This class can represent up to three different axes, that are defined in the view preset config object.
 */
Ext.define("Sch.column.timeAxis.Horizontal", {
    extend : 'Ext.grid.column.Column',
    alias  : 'widget.timeaxiscolumn',

    draggable     : false,
    groupable     : false,
    hideable      : false,
    sortable      : false,
    fixed         : true,
    menuDisabled  : true,
    cls           : 'sch-simple-timeaxis',
    tdCls         : 'sch-timetd',
    enableLocking : false,

    requires : [
        'Sch.view.HorizontalTimeAxis'
    ],


    timeAxisViewModel         : null,
    headerView                : null,

    // Disable Ext JS default header hover highlight
    hoverCls                  : '',
    ownHoverCls               : 'sch-column-header-over',

    /*
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
     */
    trackHeaderOver           : true,

    /*
     * @cfg {Number} compactCellWidthThreshold The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class     *            to the row.
     * Defaults to 20px.
     */
    compactCellWidthThreshold : 20,

    afterRender : function () {
        var me = this;

        // HACK relying on private accessor 'titleEl'
        var ct = me.titleEl.createChild({
            cls : 'sch-horizontaltimeaxis-ct'
        });

        me.headerView = new Sch.view.HorizontalTimeAxis({
            model                     : me.timeAxisViewModel,
            containerEl               : ct,
            hoverCls                  : me.ownHoverCls,
            trackHeaderOver           : me.trackHeaderOver,
            compactCellWidthThreshold : me.compactCellWidthThreshold
        });

        me.headerView.on('refresh', me.onTimeAxisViewRefresh, me);

        me.ownerCt.on('afterlayout', function() {
            // column can be rendered after grid was reconfigured
            if (!me.ownerCt) {
                return;
            }
        // If the container of this column changes size, we need to re-evaluate the size for the
        // time axis view
        me.mon(me.ownerCt, "resize", me.onHeaderContainerResize, me);

        if (this.getWidth() > 0) {
            // In case the timeAxisViewModel is shared, no need to update it
            if (me.getAvailableWidthForSchedule() === me.timeAxisViewModel.getAvailableWidth()) {
                me.headerView.render();
            } else {
                me.timeAxisViewModel.update(me.getAvailableWidthForSchedule());
            }
            me.setWidth(me.timeAxisViewModel.getTotalWidth());
        }
        }, null, { single : true });

        this.enableBubble('timeheaderclick', 'timeheaderdblclick', 'timeheadercontextmenu');

        me.relayEvents(me.headerView, [
            'timeheaderclick',
            'timeheaderdblclick',
            'timeheadercontextmenu'
        ]);

        me.callParent(arguments);
        
        // we don't need timeline to be focusble, it messes 'timeheader*' events and looses scroll in IE
        me.focusable = false;
    },

    initRenderData : function () {
        var me = this;

        me.renderData.headerCls = me.renderData.headerCls || me.headerCls;
        return me.callParent(arguments);
    },

    destroy : function () {
        if (this.headerView) {
            this.headerView.destroy();
        }
        this.callParent(arguments);
    },

    onTimeAxisViewRefresh : function () {
        // Make sure we don't create an infinite loop
        this.headerView.un('refresh', this.onTimeAxisViewRefresh, this);

        this.setWidth(this.timeAxisViewModel.getTotalWidth());

        this.headerView.on('refresh', this.onTimeAxisViewRefresh, this);
    },

    getAvailableWidthForSchedule : function () {
        // In case owner container is hidden then it and it's items will return zero width, if so we fallback to
        // lastBox private property of Ext.AbstractComponent
        var available = this.ownerCt.isVisible(true) ? this.ownerCt.getWidth() : (this.ownerCt.lastBox && this.ownerCt.lastBox.width || 0),
            items = this.ownerCt.items,
            item;

        // substracting the widths of all columns starting from 2nd ("right" columns)
        for (var i = 1; i < items.length; i++) {
            item = items.get(i);
            if (!item.hidden) {
                available -= item.isVisible(true) ? item.getWidth() : (item.lastBox && item.lastBox.width || 0);
            }
        }

        return available - Ext.getScrollbarSize().width - 1;
    },

    onResize : function () {
        this.callParent(arguments);
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
    },

    onHeaderContainerResize : function () {
        this.timeAxisViewModel.setAvailableWidth(this.getAvailableWidthForSchedule());
        this.headerView.render();
    },

    /*
     * Refreshes the column header contents. Useful if you have some extra meta data in your timeline header that
     * depends on external data such as the EventStore or ResourceStore.
     */
    refresh                 : function () {
        // Update the model, but don't fire any events which will fully redraw view
        this.timeAxisViewModel.update(null, true);

        // Now the model state has been refreshed so headers can be rerendered
        this.headerView.render();
    }
});



/*
 * @class Sch.column.timeAxis.Vertical
 *
 * @extends Ext.grid.column.Column
 * A Column representing the time axis in vertical orientation
 * @constructor
 * @param {Object} config The configuration options
 */
Ext.define('Sch.column.timeAxis.Vertical', {

    extend : 'Ext.grid.column.Column',

    alias : 'widget.verticaltimeaxis',


    /*
     * Default timeaxis column properties
     */
    align : 'right',

    draggable             : false,
    groupable             : false,
    hideable              : false,
    sortable              : false,
    menuDisabled          : true,
    timeAxis              : null,
    timeAxisViewModel     : null,
    cellTopBorderWidth    : null,
    cellBottomBorderWidth : null,
    totalBorderWidth      : null,
    enableLocking         : false,
    locked                : true,

    initComponent : function () {
        this.callParent(arguments);
        this.tdCls = (this.tdCls || '') + ' sch-verticaltimeaxis-cell';
        this.scope = this;

        this.totalBorderWidth = this.cellTopBorderWidth + this.cellBottomBorderWidth;
    },

    // HACK, until we have a proper time axis view for vertical too (not relying on Ext column)
    afterRender   : function () {
        this.callParent(arguments);
        var panel = this.up('panel');
        panel.getView().on('resize', this.onContainerResize, this);
    },

    onContainerResize : function (cmp, width, height) {
        // Grab the full height of the view, minus the spacer el height and an extra buffer
        this.timeAxisViewModel.update(height - 21);
    },

    renderer : function (val, meta, record, rowIndex) {
        var hc          = this.timeAxisViewModel.getBottomHeader();

        meta.style      = 'height:' + (this.timeAxisViewModel.getTickWidth() - this.totalBorderWidth) + 'px';

        if (hc.renderer) {
            return hc.renderer.call(hc.scope || this, record.data.start, record.data.end, meta, rowIndex);
        } else {
            return Ext.Date.format(record.data.start, hc.dateFormat);
        }
    }
});


/**
@class Sch.model.Customizable
@extends Ext.data.Model

This class represent a model with customizable field names. Customizable fields are defined in separate
class config `customizableFields`. The format of definition is just the same as for usual fields:

        Ext.define('BaseModel', {
            extend      : 'Sch.model.Customizable',

            customizableFields  : [
                { name      : 'StartDate',  type    : 'date', dateFormat : 'c' },
                { name      : 'EndDate',    type    : 'date', dateFormat : 'c' }
            ],

            fields              : [
                'UsualField'
            ],

            getEndDate : function () {
                return "foo"
            }
        });

For each customizable field will be created getter and setter, using the camel-cased name of the field ("stable name"),
prepended with "get/set" respectively. They will not overwrite any existing methods:

        var baseModel   = new BaseModel({
            StartDate   : new Date(2012, 1, 1),
            EndDate     : new Date(2012, 2, 3)
        });

        // using getter for "StartDate" field
        // returns date for "2012/02/01"
        var startDate   = baseModel.getStartDate();

        // using custom getter for "EndDate" field
        // returns "foo"
        var endDate     = baseModel.getEndDate();

You can change the name of the customizable fields in the subclasses of the model or completely re-define them.
For that, add a special property to the class, name of this property should be formed as name of the field with lowercased first
letter, appended with "Field". The value of the property should contain the new name of the field.

        Ext.define('SubModel', {
            extend      : 'BaseModel',

            startDateField      : 'beginDate',
            endDateField        : 'finalizeDate',

            fields              : [
                { name      : 'beginDate',  type    : 'date', dateFormat : 'Y-m-d' },
            ]
        });

        var subModel       = new SubModel({
            beginDate       : new Date(2012, 1, 1),
            finalizeDate    : new Date(2012, 2, 3)
        });

        // name of getter is still the same
        var startDate   = subModel.getStartDate();

In the example above the `StartDate` field was completely re-defined to the `beginDate` field with different date format.
The `EndDate` has just changed its name to "finalizeDate". Note, that getters and setters are always named after "stable"
field name, not the customized one.
*/

// Don't redefine the class, which will screw up instanceof checks etc
if (!Ext.ClassManager.get("Sch.model.Customizable")) {

    Ext.define('Sch.model.Customizable', {
        extend      : 'Ext.data.Model',


        /**
         * @cfg {Array} customizableFields
         *
         * The array of customizale fields definitions.
         */
        customizableFields      : null,

        // @private
        // Keeps temporary state of the previous state for a model, but is only available
        // when a model has changed, e.g. after 'set' or 'reject'. After those operations are completed, this property is cleared.
        previous                : null,

        // temp flag to check if we're currently editing the model
        __editing               : null,

        // To support nested beginEdit calls (see 043_nested_beginedit.t.js in Gantt)
        __editCounter               : 0,

        constructor             : function() {
            // Sencha Touch requires the return value to be returned, hard crash without it
            var retVal = this.callParent(arguments);

            return retVal;
        },

        onClassExtended : function (cls, data, hooks) {
            var onBeforeCreated = hooks.onBeforeCreated;

            hooks.onBeforeCreated = function (cls, data) {
                onBeforeCreated.apply(this, arguments);

                var proto                   = cls.prototype;

                if (!proto.customizableFields) {
                    return;
                }

                // combining our customizable fields with ones from superclass
                // our fields goes after fields from superclass to overwrite them if some names match
                proto.customizableFields    = (cls.superclass.customizableFields || []).concat(proto.customizableFields);

                var customizableFields      = proto.customizableFields;

                // collect fields here, overwriting old ones with new
                var customizableFieldsByName    = {};
                // HACK, crashes without these in 5.1
                var me = this;
                var idField = Ext.Array.findBy(cls.fields, function(f) { return f.name === proto.idProperty; });

                me.idField = proto.idField = idField;

                if (!cls.fieldsMap[proto.idProperty]) {
                    cls.fieldsMap[proto.idProperty] = idField;
                }
                // EOF HACK, crashes without these in 5.1

                Ext.Array.forEach(customizableFields, function (field) {
                    // normalize to object
                    if (typeof field == 'string') field = { name : field };

                    customizableFieldsByName[ field.name ] = field;
                });

                // already processed by the Ext.data.Model `onBeforeCreated`
                var fields                  = proto.fields;
                var toAdd                   = [];
                var toRemove                = [];

                Ext.Array.forEach(fields, function (field) {
                    if (field.isCustomizableField) {
                        toRemove.push(field.getName());
                    }
                });

                if (proto.idProperty !== 'id' && proto.getField('id')) {

                    if (!proto.getField('id').hasOwnProperty('name')) {
                        toRemove.push('id');
                    }
                }

                if (proto.idProperty !== 'Id' && proto.getField('Id')) {

                    if (!proto.getField('Id').hasOwnProperty('name')) {
                        toRemove.push('Id');
                    }
                }

                cls.removeFields(toRemove);

                Ext.Object.each(customizableFieldsByName, function (name, customizableField) {
                    // mark all customizable fields with special property, to be able remove them later
                    customizableField.isCustomizableField     = true;

                    var stableFieldName     = customizableField.name || customizableField.getName();
                    var fieldProperty       = stableFieldName === 'Id' ? 'idProperty' : stableFieldName.charAt(0).toLowerCase() + stableFieldName.substr(1) + 'Field';
                    var overrideFieldName   = proto[ fieldProperty ];

                    var realFieldName       = overrideFieldName || stableFieldName;
                    var field;

                    if (proto.getField(realFieldName)) {
                        field = Ext.applyIf({ name : stableFieldName, isCustomizableField : true }, proto.getField(realFieldName));

                        // if user has re-defined some customizable field, mark it accordingly
                        // such fields weren't be inheritable though (won't replace the customizable field)
                        proto.getField(realFieldName).isCustomizableField = true;

                        // add it to our customizable fields list on the last position, so in the subclasses
                        // it will overwrite other fields with this name

                        field = Ext.create('data.field.' + (field.type || 'auto'), field);

                        customizableFields.push(field);
                    } else {
                        field = Ext.applyIf({ name : realFieldName, isCustomizableField : true }, customizableField);

                        field = Ext.create('data.field.' + (field.type || 'auto'), field);

                        // we create a new copy of the `customizableField` using possibly new name
                        toAdd.push(field);
                    }

                    var capitalizedStableName  = Ext.String.capitalize(stableFieldName);

                    // don't overwrite `getId` method
                    if (capitalizedStableName != 'Id') {
                        var getter              = 'get' + capitalizedStableName;
                        var setter              = 'set' + capitalizedStableName;

                        // overwrite old getters, pointing to a different field name
                        if (!proto[ getter ] || proto[ getter ].__getterFor__ && proto[ getter ].__getterFor__ != realFieldName) {
                            proto[ getter ] = function () {
                                return this.get(realFieldName);
                            };

                            proto[ getter ].__getterFor__   = realFieldName;
                        }

                        // same for setters
                        if (!proto[ setter ] || proto[ setter ].__setterFor__ && proto[ setter ].__setterFor__ != realFieldName) {
                            proto[ setter ] = function (value) {
                                return this.set(realFieldName, value);
                            };

                            proto[ setter ].__setterFor__   = realFieldName;
                        }
                    }
                });

                cls.addFields(toAdd);
            };
        },

        // Overridden to be able to track previous record field values
        set : function(fieldName, value) {
            var currentValue;
            var retVal;

            this.previous = this.previous || {};

            if (typeof fieldName === 'string') {
                currentValue = this.get(fieldName);

                // convert new value to Date if needed
                if (currentValue instanceof Date && !(value instanceof Date)) {
                    value   = this.getField(fieldName).convert(value, this);
                }

                // Store previous field value if it changed, if value didn't change - just return
                if ((currentValue instanceof Date && (currentValue - value)) || !(currentValue instanceof Date) && currentValue !== value) {
                    this.previous[fieldName] = currentValue;
                } else {
                    return [];
                }
            } else {
                for (var o in fieldName) {
                    currentValue    = this.get(o);

                    var newValue    = fieldName[o];

                    // convert new value to Date if needed
                    if (currentValue instanceof Date && !(newValue instanceof Date)) {
                        newValue    = this.getField(o).convert(newValue, this);
                    }

                    // Store previous field value
                    if ((currentValue instanceof Date && (currentValue - newValue)) || !(currentValue instanceof Date) && currentValue !== newValue) {
                        this.previous[o] = currentValue;
                    }
                }
            }
            retVal = this.callParent(arguments);

            if (!this.__editing) {
                delete this.previous;
            }

            return retVal;
        },

        // Overridden to be able to track previous record field values
        reject : function () {
            var me = this,
                modified = me.modified || {},
                field;

            // Ext could call 'set' during the callParent which should not reset the 'previous' object
            me.__editing = true;

            me.previous = me.previous || {};

            for (field in modified) {
                if (modified.hasOwnProperty(field)) {
                    if (typeof modified[field] != "function") {
                        me.previous[field] = me.get(field);
                    }
                }
            }
            me.callParent(arguments);

            // Reset the previous tracking object
            delete me.previous;
            me.__editing = false;
        },

        beginEdit: function () {
            this.__editCounter++;
            this.__editing = true;

            this.callParent(arguments);
        },

        cancelEdit: function () {
            this.__editCounter = 0;
            this.__editing = false;
            this.callParent(arguments);

            delete this.previous;
        },

        // Overridden to be able to clear the previous record field values. Must be done here to have access to the 'previous' object after
        // an endEdit call.
        endEdit: function (silent, modifiedFieldNames) {
            if (--this.__editCounter === 0) {

                // OVERRIDE HACK: If no fields were changed, make sure no events are fired by signaling 'silent'
                if (!silent && this.getModifiedFieldNames /* Touch doesn't have this method, skip optimization */ ) {
                    var editMemento = this.editMemento;
                    if (!modifiedFieldNames) {
                        modifiedFieldNames = this.getModifiedFieldNames(editMemento.data);
                    }

                    if (modifiedFieldNames && modifiedFieldNames.length === 0) {
                        silent = true;
                    }
                }

                this.callParent([silent].concat(Array.prototype.slice.call(arguments, 1)));

                this.__editing = false;
                delete this.previous;
            }
        }
        // -------------- EOF Supporting nested beginEdit calls - see test 043_nested_beginedit.t.js
    });
}

/**

 @class Sch.model.Range
 @extends Sch.model.Customizable

 This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.

 Its a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
 Please refer to documentation of those classes to become familar with the base interface of this class.

 A range has the following fields:

 - `StartDate`   - start date of the task in the ISO 8601 format
 - `EndDate`     - end date of the task in the ISO 8601 format (not inclusive)
 - `Name`        - an optional name of the range
 - `Cls`         - an optional CSS class to be associated with the range.

 The name of any field can be customized in the subclass. Please refer to {@link Sch.model.Customizable} for details.

 */

if (!Ext.ClassManager.get("Sch.model.Range")) {
    Ext.define('Sch.model.Range', {
        extend : 'Sch.model.Customizable',

        requires : [
            'Sch.util.Date'
        ],

        idProperty : 'Id',

        // For Sencha Touch
        config     : Ext.versions.touch ? { idProperty : 'Id' } : null,

        /**
         * @cfg {String} startDateField The name of the field that defines the range start date. Defaults to "StartDate".
         */
        startDateField : 'StartDate',

        /**
         * @cfg {String} endDateField The name of the field that defines the range end date. Defaults to "EndDate".
         */
        endDateField : 'EndDate',

        /**
         * @cfg {String} nameField The name of the field that defines the range name. Defaults to "Name".
         */
        nameField : 'Name',

        /**
         * @cfg {String} clsField The name of the field that holds the range "class" value (usually corresponds to a CSS class). Defaults to "Cls".
         */
        clsField : 'Cls',

        customizableFields : [
        /**
         * @method getStartDate
         *
         * Returns the range start date
         *
         * @return {Date} The start date
         */
            { name : 'StartDate', type : 'date', dateFormat : 'c' },

        /**
         * @method getEndDate
         *
         * Returns the range end date
         *
         * @return {Date} The end date
         */
            { name : 'EndDate', type : 'date', dateFormat : 'c' },

        /**
         * @method getCls
         *
         * Gets the "class" of the range
         *
         * @return {String} cls The "class" of the range
         */
        /**
         * @method setCls
         *
         * Sets the "class" of the range
         *
         * @param {String} cls The new class of the range
         */
            {
                name : 'Cls', type : 'string'
            },

        /**
         * @method getName
         *
         * Gets the name of the range
         *
         * @return {String} name The "name" of the range
         */
        /**
         * @method setName
         *
         * Sets the "name" of the range
         *
         * @param {String} name The new name of the range
         */
            {
                name : 'Name', type : 'string'
            }
        ],

        /**
         * @method setStartDate
         *
         * Sets the range start date
         *
         * @param {Date} date The new start date
         * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
         * Defaults to `false`
         */
        setStartDate : function (date, keepDuration) {
            var endDate = this.getEndDate();
            var oldStart = this.getStartDate();

            this.set(this.startDateField, date);

            if (keepDuration === true && endDate && oldStart) {
                this.setEndDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, endDate - oldStart));
            }
        },

        /**
         * @method setEndDate
         *
         * Sets the range end date
         *
         * @param {Date} date The new end date
         * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
         * Defaults to `false`
         */
        setEndDate : function (date, keepDuration) {
            var startDate = this.getStartDate();
            var oldEnd = this.getEndDate();

            this.set(this.endDateField, date);

            if (keepDuration === true && startDate && oldEnd) {
                this.setStartDate(Sch.util.Date.add(date, Sch.util.Date.MILLI, -(oldEnd - startDate)));
            }
        },

        /**
         * Sets the event start and end dates
         *
         * @param {Date} start The new start date
         * @param {Date} end The new end date
         */
        setStartEndDate : function (start, end) {
            this.beginEdit();

            this.set(this.startDateField, start);
            this.set(this.endDateField, end);

            this.endEdit();
        },

        /**
         * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.
         * @return {Date[]}
         */
        getDates : function () {
            var dates = [],
                endDate = this.getEndDate();

            for (var date = Ext.Date.clearTime(this.getStartDate(), true); date < endDate; date = Sch.util.Date.add(date, Sch.util.Date.DAY, 1)) {

                dates.push(date);
            }

            return dates;
        },


        /**
         * Iterates over the results from {@link #getDates}
         * @param {Function} func The function to call for each date
         * @param {Object} scope The scope to use for the function call
         */
        forEachDate : function (func, scope) {
            return Ext.each(this.getDates(), func, scope);
        },

        // Simple check if end date is greater than start date
        isValid     : function () {
            var valid = this.callParent(arguments);

            if (valid) {
                var start = this.getStartDate(),
                    end = this.getEndDate();

                valid = !start || !end || (end - start >= 0);
            }

            return valid;
        },

        /**
         * Shift the dates for the date range by the passed amount and unit
         * @param {String} unit The unit to shift by (e.g. range.shift(Sch.util.Date.DAY, 2); ) to bump the range 2 days forward
         * @param {Number} amount The amount to shift
         */
        shift : function (unit, amount) {
            this.setStartEndDate(
                Sch.util.Date.add(this.getStartDate(), unit, amount),
                Sch.util.Date.add(this.getEndDate(), unit, amount)
            );
        },

        fullCopy : function () {
            return this.copy.apply(this, arguments);
        }
    });
}
/*
 * @class Sch.model.TimeAxisTick
 * @extends Sch.model.Range
 *
 * A simple model with a start/end date interval defining a 'tick' on the time axis.
 */
if (!Ext.ClassManager.get("Sch.model.TimeAxisTick")) {
    Ext.define('Sch.model.TimeAxisTick', {
        extend : 'Sch.model.Range',

        startDateField : 'start',
        endDateField   : 'end'
    });
}

/**

@class Sch.model.Event
@extends Sch.model.Range

This class represent a single event in your schedule. Its a subclass of the {@link Sch.model.Range}, which is in turn subclass of {@link Sch.model.Customizable} and {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of the task.

The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for the existing fields,
you can do that by subclassing this class (see example below).

Fields
------

- `Id`          - (mandatory) unique identificator of task
- `Name`        - name of the event (task title)
- `StartDate`   - start date of the task in the ISO 8601 format
- `EndDate`     - end date of the task in the ISO 8601 format,
- `ResourceId`  - The id of the associated resource
- `Resizable`   - A field allowing you to easily control how an event can be resized. You can set it to: true, false, 'start' or 'end' as its value.
- `Draggable`   - A field allowing you to easily control if an event can be dragged. (true or false)
- `Cls`         - A field containing a CSS class to be added to the rendered event element.

Subclassing the Event model class
--------------------

    Ext.define('MyProject.model.Event', {
        extend      : 'Sch.model.Event',

        fields      : [
            // adding new field
            { name: 'MyField', type : 'number', defaultValue : 0 }
        ],

        myCheckMethod : function () {
            return this.get('MyField') > 0
        },
        ...
    });

If you want to use other names for the StartDate, EndDate, ResourceId and Name fields you can configure them as seen below:

    Ext.define('MyProject.model.Event', {
        extend      : 'Sch.model.Event',

        startDateField  : 'taskStart',
        endDateField    : 'taskEnd',

        // just rename the fields
        resourceIdField : 'userId',
        nameField       : 'taskTitle',

        fields      : [
            // completely change the definition of fields
            { name: 'taskStart', type: 'date', dateFormat : 'Y-m-d' },
            { name: 'taskEnd', type: 'date', dateFormat : 'Y-m-d' },
        ]
        ...
    });

Please refer to {@link Sch.model.Customizable} for additional details.

*/
!Ext.ClassManager.get("Sch.model.Event") && Ext.define('Sch.model.Event', {
    extend : 'Sch.model.Range',

    idProperty : 'Id',

    customizableFields : [
        { name : 'ResourceId' },
        { name : 'Draggable', type : 'boolean', persist : false, defaultValue : true },   // true or false
        { name : 'Resizable', persist : false, defaultValue : true }                     // true, false, 'start' or 'end'
    ],

    /**
     * @cfg {String} resourceIdField The name of the field identifying the resource to which an event belongs. Defaults to "ResourceId".
     */
    resourceIdField : 'ResourceId',

    /**
     * @cfg {String} draggableField The name of the field specifying if the event should be draggable in the timeline
     */
    draggableField : 'Draggable',

    /**
     * @cfg {String} resizableField The name of the field specifying if/how the event should be resizable.
     */
    resizableField : 'Resizable',

    getInternalId : function() {
        return this.internalId;
    },

    /**
     * Returns an event store this event is part of. Event must be part
     * of an event store to be able to retrieve event store.
     *
     * @return {Sch.data.EventStore|null}
     */
    getEventStore : function() {
        var me = this,
            result = me.joined && me.joined[ 0 ];

        if (result && !result.isEventStore) {
            Ext.Array.sort(me.joined, function(a, b) {
                return (a.isEventStore || false) > (b.isEventStore || false) && -1 || 1;
            });
            result = me.joined[ 0 ];
        }

        return result;
    },

    /**
     * Returns a resource store this event uses as default resource store. Event must be part
     * of an event store to be able to retrieve default resource store.
     *
     * @return {Sch.data.ResourceStore|null}
     */
    getResourceStore : function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getResourceStore();
    },

    /**
     * Returns an assigment store this event uses as default assignment store. Event must be part
     * of an event store to be able to retrieve default assignment store.
     *
     * @return {Sch.data.AssigmentStore|null}
     */
    getAssignmentStore : function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getAssignmentStore();
    },

    /**
     * Returns all resources assigned to an event.
     *
     * @return {[Sch.model.Resource]}
     */
    getResources : function() {
        var me = this,
            eventStore = me.getEventStore();

        return eventStore && eventStore.getResourcesForEvent(me) || [];
    },

    /**
     * @private
     */
    forEachResource : function (fn, scope) {
        var rs = this.getResources();

        for (var i = 0; i < rs.length; i++) {
            if (fn.call(scope || this, rs[i]) === false) {
                return;
            }
        }
    },

    /**
     * Returns either the resource associated with this event (when called w/o `resourceId`) or resource
     * with specified id.
     *
     * @param {String} resourceId (optional)
     * @return {Sch.model.Resource}
     */
    getResource : function (resourceId, eventStore) { // TODO: this signature sucks, eventStore WHY?
        var me              = this,
            result          = null,
            resourceStore;

        eventStore    = eventStore || me.getEventStore();
        resourceStore = eventStore && eventStore.getResourceStore();

        // Allow 0 as a valid resource id
        resourceId = resourceId == null ? me.getResourceId() : resourceId;

        if (eventStore && (resourceId === null || resourceId === undefined)) {
            result = eventStore.getResourcesForEvent(me);

            if (result.length == 1) {
                result = result[0];
            }
            else if (result.length > 1) {
                Ext.Error.raise("Event::getResource() is not applicable for events with multiple assignments, please use Event::getResources() instead.");
            }
            else {
                result = null;
            }
        }
        else if (resourceStore) {
            result = resourceStore.getModelById(resourceId);
        }

        return result;
    },

    /**
     * Sets the resource which the event should belong to.
     *
     * @param {Sch.model.Resource/Mixed} resource The new resource
     */
    setResource : function(resource) {
        var me = this,
            eventStore = me.getEventStore();

        eventStore && eventStore.removeAssignmentsForEvent(me);

        me.assign(resource);
    },

    /**
     * Assigns this event to the specified resource.
     *
     * @param {Sch.model.Resource|Mixed|Array} resource A new resource for this event, either as a full Resource record or an id (or an array of such).
     */
    assign : function(resource) {
        var me = this,
            eventStore = me.getEventStore();

        resource = resource instanceof Sch.model.Resource ? resource.getId() : resource; // resource id might be 0 thus we use ? operator

        if (eventStore) {
            eventStore.assignEventToResource(me, resource);
        }
        else {
            me.setResourceId(resource);
        }
    },

    /**
     * Unassigns this event from the specified resource
     *
     * @param {Sch.model.Resource/Mixed/Array} [resource] The resource to unassign from.
     */
    unassign : function(resource) {
        var me = this,
            eventStore = me.getEventStore();

        resource = resource instanceof Sch.model.Resource ? resource.getId() : resource; // resource id might be 0 thus we use ? operator

        if (eventStore) {
            eventStore.unassignEventFromResource(me, resource);
        }
        else if (me.getResourceId() == resource) {
            me.setResourceId(null);
        }
    },

    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Sch.model.Resource/Mixed} resource A resource to unassign from
     * @param {Sch.model.Resource/Mixed} resource A resource to assign to
     */
    reassign : function(oldResource, newResource) {
        var me = this,
            eventStore = me.getEventStore();

        oldResource = oldResource instanceof Sch.model.Resource ? oldResource.getId() : oldResource; // resource id might be 0 thus we use ? operator
        newResource = newResource instanceof Sch.model.Resource ? newResource.getId() : newResource; // resource id might be 0 thus we use ? operator

        if (eventStore) {
            eventStore.reassignEventFromResourceToResource(me, oldResource, newResource);
        }
        else {
            me.setResourceId(newResource);
        }
    },

    /**
     * @method isAssignedTo
     * Returns true if this event is assigned to a certain resource.
     *
     * @param {Sch.model.Resource|Mixed} resource The resource to query for
     * @return {Boolean}
     */
    isAssignedTo : function(resource) {
        var me = this,
            eventStore = me.getEventStore(),
            result = false;

        resource = resource instanceof Sch.model.Resource && resource.getId() || resource;

        if (eventStore) {
            result = eventStore.isEventAssignedToResource(me, resource);
        }
        else {
            result = me.getResourceId() == resource;
        }

        return result;
    },

    /**
     * Returns all assignments for the event. Event must be part of the store for this method to work.
     *
     * @return {[Sch.model.Assignment]}
     */
    getAssignments : function() {
        var me = this,
            eventStore = me.getEventStore();

        return eventStore && eventStore.getAssignmentsForEvent(me);
    },

    /**
     * @method setDraggable
     *
     * Sets the new draggable state for the event
     * @param {Boolean} draggable true if this event should be draggable
     */

    /**
     * @method isDraggable
     *
     * Returns true if event can be drag and dropped
     * @return {Mixed} The draggable state for the event.
     */
    isDraggable : function () {
        return this.getDraggable();
    },

    /**
     * @method setResizable
     *
     * Sets the new resizable state for the event. You can specify true/false, or 'start'/'end' to only allow resizing one end of an event.
     * @param {Boolean} resizable true if this event should be resizable
     */

    /**
     * @method getResourceId
     *
     * Returns the resource id of the resource that the event belongs to.
     * @return {Mixed} The resource Id
     */

    /**
     * @method isResizable
     *
     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can be resized.
     * @return {Mixed} The resource Id
     */
    isResizable : function () {
        return this.getResizable();
    },

    /**
     * @method setResourceId
     *
     * Sets the new resource id of the resource that the event belongs to.
     * @param {Mixed} resourceId The resource Id
     */

    /**
     * Returns false if a linked resource is a phantom record, i.e. it's not persisted in the database.
     *
     * @return {Boolean} valid
     */
    isPersistable : function () {
        var me = this,
            eventStore = me.getEventStore();
        return eventStore && eventStore.isEventPersistable(me);
    }
});

/**
@class Sch.model.Resource
@extends Sch.model.Customizable

This class represent a single Resource in the scheduler chart. It's a subclass of the {@link Sch.model.Customizable}, which is in turn subclass of {@link Ext.data.Model}.
Please refer to documentation of those classes to become familar with the base interface of the resource.

A Resource has only 2 mandatory fields - `Id` and `Name`. If you want to add more fields with meta data describing your resources then you should subclass this class:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',

        fields      : [
            // `Id` and `Name` fields are already provided by the superclass
            { name: 'Company',          type : 'string' }
        ],

        getCompany : function () {
            return this.get('Company');
        },
        ...
    });

If you want to use other names for the Id and Name fields you can configure them as seen below:

    Ext.define('MyProject.model.Resource', {
        extend      : 'Sch.model.Resource',

        nameField   : 'UserName',
        ...
    });

Please refer to {@link Sch.model.Customizable} for details.
*/

// Don't redefine the class, which will screw up instanceof checks etc
if (!Ext.ClassManager.get('Sch.model.Resource')) Ext.define('Sch.model.Resource', {
    extend : 'Sch.model.Customizable',

    idProperty : 'Id',
    config     : Ext.versions.touch ? { idProperty : 'Id' } : null,

    /**
     * @cfg {String} nameField The name of the field that holds the resource name. Defaults to "Name".
     */
    nameField : 'Name',

    customizableFields : [
        /**
         * @method getName
         *
         * Returns the resource name
         *
         * @return {String} The name of the resource
         */
        /**
         * @method setName
         *
         * Sets the resource name
         *
         * @param {String} The new name of the resource
         */
        { name : 'Name', type : 'string' }
    ],

    getInternalId : function() {
        return this.internalId;
    },

    /**
     * Returns a resource store this resource is part of. Resource must be part
     * of a resource store to be able to retrieve resource store.
     *
     * @return {Sch.data.ResourceStore|null}
     */
    getResourceStore : function() {
        return this.joined && this.joined[ 0 ];
    },

    /**
     * Returns an event store this resource uses as default. Resource must be part
     * of a resource store to be able to retrieve event store.
     *
     * @return {Sch.data.EventStore|null}
     */
    getEventStore : function () {
        var resourceStore = this.getResourceStore();
        return resourceStore && resourceStore.getEventStore() || this.parentNode && this.parentNode.getEventStore();
    },

    /**
     * Returns as assignment store this resources uses as default. Resource must be part
     * of a resource store to be able to retrieve default assignment store.
     *
     * @return {Sch.data.AssignmentStore|null}
     */
    getAssignmentStore : function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getAssignmentStore();
    },

    /**
     * Returns an array of events, associated with this resource
     *
     * @param {Sch.data.EventStore} eventStore (optional) The event store to get events for (if a resource is bound to multiple stores)
     * @return {Sch.model.Range[]}
     */
    getEvents : function (eventStore) {
        var me = this;
        eventStore = eventStore || me.getEventStore();
        return eventStore && eventStore.getEventsForResource(me) || [];
    },

    /**
     * Returns all assignments for the resource. Resource must be part of the store for this method to work.
     *
     * @return {[Sch.model.Assignment]}
     */
    getAssignments : function() {
        var me = this,
            eventStore = me.getEventStore();

        return eventStore && eventStore.getAssignmentsForResource(me);
    },

    /**
     * Returns true if the Resource can be persisted.
     * In a flat store resource is always considered to be persistable, in a tree store resource is considered to
     * be persitable if it's parent node is persistable.
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable : function() {
        var parent = this.parentNode;
        return !parent || !parent.phantom || (parent.isRoot && parent.isRoot());
    }
});

/**
 * @class Sch.model.Assignment
 * @extends Sch.model.Customizable
 *
 * This class represent a single assignment of a resource to an event in scheduler.
 * It is a subclass of the {@link Sch.model.Customizable} class, which in its turn subclasses {@link Ext.data.Model}.
 * Please refer to documentation of those classes to become familar with the base interface of this class.
 *
 * An Assignment has the following fields:
 * - `Id` - The id of the assignment
 * - `ResourceId` - The id of the resource assigned
 * - `EventId` - The id of the event to which the resource is assigned
 *
 * The names of these fields can be customized by subclassing this class.
 * Please refer to {@link Sch.model.Customizable} for details.
 */
if (!Ext.ClassManager.get("Sch.model.Assignment")) Ext.define('Sch.model.Assignment', {
    extend  : 'Sch.model.Customizable',

    idProperty : 'Id',

    customizableFields  : [
        { name : 'ResourceId' },
        { name : 'EventId' }
    ],

    /**
     * @cfg {String} resourceIdField The name of the field identifying the resource to which an assignment belongs.
     * Defaults to "ResourceId".
     */
    resourceIdField         : 'ResourceId',

    /**
     * @cfg {String} eventIdField The name of the field identifying an event to which an assignment belongs.
     * Defaults to "EventId".
     */
    eventIdField             : 'EventId',

    getInternalId : function() {
        return this.internalId;
    },

    /**
     * Returns an assigment store this assignment is part of. Assignment must be part of an assigment store
     * to be able to retrieve it.
     *
     * @return {Sch.data.AssignmentStore|null}
     */
    getAssignmentStore : function() {
        return this.joined && this.joined[ 0 ];
    },

    /**
     * Returns an event store this assignment uses as default event store. Assignment must be part
     * of an assignment store to be able to retrieve default event store.
     *
     * @return {Sch.data.EventStore|null}
     */
    getEventStore : function() {
        var assignmentStore = this.getAssignmentStore();
        return assignmentStore && assignmentStore.getEventStore();
    },

    /**
     * Returns a resource store this assignment uses as default resource store. Assignment must be part
     * of an assignment store to be able to retrieve default resource store.
     *
     * @return {Sch.data.ResourceStore|null}
     */
    getResourceStore : function() {
        var eventStore = this.getEventStore();
        return eventStore && eventStore.getResourceStore();
    },

    /**
     * Returns an event associated with this assignment.
     *
     * @privateparam  {Sch.data.EventStore} [eventStore]
     * @return {Sch.model.Range} Event instance
     */
    getEvent: function(eventStore) {
        var me = this;
        // removed assignment will not have "this.joined" so we are providing a way to get an event via provided
        // event store
        eventStore = eventStore || me.getEventStore();
        return eventStore && eventStore.getModelById(me.getEventId());
    },

    /**
     * Returns the resource associated with this assignment.
     *
     * @privateparam {Sch.data.ResourceStore} [resourceStore]
     * @return {Sch.model.Resource} Instance of resource
     */
    getResource: function(resourceStore) {
        var me = this;
        // removed assignment will not have "this.joined" so we are providing a way to get a resource via provided
        // resource store
        resourceStore = resourceStore || me.getResourceStore();
        return resourceStore && resourceStore.getModelById(me.getResourceId());
    },

    /**
     * Convenience method to get a name of the associated event.
     *
     * @privateparam  {Sch.data.EventStore} [eventStore]
     * @return {String} name
     */
    getEventName : function(eventStore) {
        var evnt = this.getEvent(eventStore);
        return evnt && evnt.getName() || '';
    },

    /**
     * Convenience method to get a name of the associated resource.
     *
     * @privateparam {Sch.data.ResourceStore} [resourceStore]
     * @return {String} name
     */
    getResourceName : function(resourceStore) {
        var resource = this.getResource(resourceStore);
        return resource && resource.getName() || '';
    },

    /**
     * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
     *
     * @return {Boolean} true if this model can be persisted to server.
     */
    isPersistable : function() {
        var me       = this,
            event    = me.getEvent(),
            resource = me.getResource();

        return event && !event.phantom && resource && !resource.phantom;
    },

    fullCopy : function() {
        return this.copy.apply(this, arguments);
    }
});

/**
 * Event store's resource->events cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.ResourceEventsCache', {
    extend   : 'Sch.util.Cache',
    requires : [
        'Ext.data.Model'
    ],

    eventStore            : null,
    eventStoreDetacher    : null,
    resourceStoreDetacher : null,

    constructor : function(eventStore) {
        var me = this,
            resourceStore = eventStore.getResourceStore();

        me.callParent();

        function onEventAdd(eventStore, events) {
            Ext.Array.forEach(events, function(event) {
                me.add(event.getResourceId(), event);
            });
        }

        function onEventRemove(eventStore, events) {
            Ext.Array.forEach(events, function(event) {
                me.remove(event.getResourceId(), event);
            });
        }

        function onEventUpdate(eventStore, event, operation, modifiedFieldNames) {
            var resourceIdField    = event.resourceIdField,
                resourceIdChanged  = event.previous && resourceIdField in event.previous,
                previousResourceId = resourceIdChanged && event.previous[resourceIdField];

            if (operation != Ext.data.Model.COMMIT && resourceIdChanged) {
                me.move(previousResourceId, event.getResourceId(), event);
            }
        }

        function onEventStoreClearOrReset() {
            me.clear();
        }

        function onEventStoreResourceStoreChange(eventStore, newResourceStore, oldResourceStore) {
            me.clear();
            attachToResourceStore(newResourceStore);
        }

        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }

        function onResourceRemove(resourceStore, resources) {
            Ext.Array.forEach(resources, function(resource) {
                me.clear(resource);
            });
        }

        function onResourceStoreClearOrReset() {
            me.clear();
        }

        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged      : onResourceIdChanged,
                remove         : onResourceRemove,
                clear          : onResourceStoreClearOrReset,
                cacheresethint : onResourceStoreClearOrReset,
                rootchange     : onResourceStoreClearOrReset,
                priority       : 100,
                destroyable    : true
            });
        }

        me.eventStoreDetacher = eventStore.on({
            add                 : onEventAdd,
            remove              : onEventRemove,
            update              : onEventUpdate,
            clear               : onEventStoreClearOrReset,
            cacheresethint      : onEventStoreClearOrReset,
            rootchange          : onEventStoreClearOrReset,
            resourcestorechange : onEventStoreResourceStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority    : 100,
            destroyable : true
        });

        attachToResourceStore(resourceStore);

        me.eventStore = eventStore;
    },

    destroy : function() {
        var me = this;
        Ext.destroyMembers(
            me,
            'eventStoreDetacher',
            'resourceStoreDetacher'
        );
        me.eventStore = null;
    },

    get : function(k, fn) {
        var me = this;

        k = me.key(k);

        fn = fn || function() {
            return Ext.Array.filter(me.eventStore.getRange(), function(event) {
                return event.getResourceId() == k;
            });
        };

        return me.callParent([k, fn]);
    }
});

/**
 * Assignment store event->assignments cache.
 * Uses event records or event record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.EventAssignmentsCache', {
    extend   : 'Sch.util.Cache',
    requires : [
        'Ext.data.Model'
    ],

    assignmentStore         : null,
    assignmentStoreDetacher : null,
    eventStoreDetacher      : null,

    constructor : function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore();

        me.callParent();

        function onAssignmentAdd(store, assignments) {
            Ext.Array.forEach(assignments, function(assignment) {
                me.add(assignment.getEventId(), assignment);
            });
        }

        function onAssignmentRemove(store, assignments) {
            Ext.Array.forEach(assignments, function(assignment) {
                me.remove(assignment.getEventId(), assignment);
            });
        }

        function onAssignmentUpdate(store, assignment, operation) {
            var eventIdField    = assignment.eventIdField,
                eventIdChanged  = assignment.previous && eventIdField in assignment.previous,
                previousEventId = eventIdChanged && assignment.previous[eventIdField];

            if (operation != Ext.data.Model.COMMIT && eventIdChanged) {
                me.move(previousEventId, assignment.getEventId(), assignment);
            }
        }

        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }

        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
        }

        function onEventIdChanged(eventStore, event, oldId, newId) {
            me.move(oldId, newId);
        }

        function onEventRemove(eventStore, events) {
            Ext.Array.forEach(events, function(event) {
                me.clear(event);
            });
        }

        function onEventStoreClearOrReset() {
            me.clear();
        }

        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                idchanged      : onEventIdChanged,
                remove         : onEventRemove,
                cacheresethint : onEventStoreClearOrReset,
                clear          : onEventStoreClearOrReset,
                rootchange     : onEventStoreClearOrReset,
                priority       : 100,
                destroyable    : true
            });
        }

        me.assignmentStoreDetacher = assignmentStore.on({
            add              : onAssignmentAdd,
            remove           : onAssignmentRemove,
            update           : onAssignmentUpdate,
            cacheresethint   : onAssignmentStoreClearOrReset,
            clear            : onAssignmentStoreClearOrReset,
            eventstorechange : onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority    : 100,
            destroyable : true
        });

        attachToEventStore(eventStore);

        me.assignmentStore = assignmentStore;
    },

    destroy : function() {
        var me = this;
        Ext.destroyMembers(
            me,
            'assignmentStoreDetacher',
            'eventStoreDetacher'
        );
        me.assignmentStore = null;
    },

    get : function(k, fn) {
        var me = this;

        k = me.key(k);

        fn = fn || function() {
            return Ext.Array.filter(me.assignmentStore.getRange(), function(assignment) {
                return assignment.getEventId() == k;
            });
        };

        return me.callParent([k, fn]);
    }
});

/**
 * Assignment store resource->assignments cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
Ext.define('Sch.data.util.ResourceAssignmentsCache', {
    extend   : 'Sch.util.Cache',
    requires : [
        'Ext.data.Model'
    ],

    assignmentStore         : null,
    assignmentStoreDetacher : null,
    eventStoreDetacher      : null,
    resourceStoreDetacher   : null,

    constructor : function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();

        me.callParent();

        function onAssignmentAdd(store, assignments) {
            Ext.Array.forEach(assignments, function(assignment) {
                me.add(assignment.getResourceId(), assignment);
            });
        }

        function onAssignmentRemove(store, assignments) {
            Ext.Array.forEach(assignments, function(assignment) {
                me.remove(assignment.getResourceId(), assignment);
            });
        }

        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField    = assignment.resourceIdField,
                resourceIdChanged  = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField];

            if (operation != Ext.data.Model.COMMIT && resourceIdChanged) {
                me.move(previousResourceId, assignment.getResourceId(), assignment);
            }
        }

        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }

        function onAssignmentStoreEventStoreChange(store, eventStore) {
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }

        function onEventStoreResourceStoreChange(eventStore, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }

        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }

        function onResourceRemove(resourceStore, resources) {
            Ext.Array.forEach(resources, function(resource) {
                me.clear(resource);
            });
        }

        function onResourceStoreClearOrReset() {
            me.clear();
        }

        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                resourcestorechange : onEventStoreResourceStoreChange,
                priority    : 100,
                destroyable : true
            });
        }

        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged      : onResourceIdChanged,
                remove         : onResourceRemove,
                clear          : onResourceStoreClearOrReset,
                cacheresethint : onResourceStoreClearOrReset,
                rootchange     : onResourceStoreClearOrReset,
                priority       : 100,
                destroyable    : true
            });
        }

        me.assignmentStoreDetacher = assignmentStore.on({
            add              : onAssignmentAdd,
            remove           : onAssignmentRemove,
            update           : onAssignmentUpdate,
            clear            : onAssignmentStoreClearOrReset,
            cacheresethint   : onAssignmentStoreClearOrReset,
            eventstorechange : onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority    : 100,
            destroyable : true
        });

        attachToEventStore(eventStore);
        attachToResourceStore(resourceStore);

        me.assignmentStore = assignmentStore;
    },

    destroy : function() {
        var me = this;
        Ext.destroyMembers(
            me,
            'assignmentStoreDetacher',
            'eventStoreDetacher',
            'resourceStoreDetacher'
        );
        me.assignmentStore = null;
    },

    get : function(k, fn) {
        var me = this;

        k = me.key(k);

        fn = fn || function() {
            return Ext.Array.filter(me.assignmentStore.getRange(), function(assignment) {
                return assignment.getResourceId() == k;
            });
        };

        return me.callParent([k, fn]);
    }
});

/**
 * Assignment store event->resources cache.
 * Uses event records or event record ids as keys.
 *
 * @private
 */
if (!Ext.ClassManager.get('Sch.data.util.AssignmentStoreEventResourcesCache')) Ext.define('Sch.data.util.AssignmentStoreEventResourcesCache', {
    extend   : 'Sch.util.Cache',
    requires : [
        'Ext.data.Model'
    ],

    assignmentStore         : null,
    assignmentStoreDetacher : null,
    eventStoreDetacher      : null,
    resourceStoreDetacher   : null,

    constructor : function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();

        me.callParent();

        function onAssignmentAdd(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore();

            Ext.Array.forEach(assignments, function(assignment) {
                var resource = resourceStore && resourceStore.getModelById(assignment.getResourceId());

                if (resource) {
                    me.add(assignment.getEventId(), resource);
                }
                // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the resource store
                else {
                    me.clear(assignment.getEventId());
                }
            });
        }

        function onAssignmentRemove(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore(),
                resourceStore = eventStore && eventStore.getResourceStore();

            Ext.Array.forEach(assignments, function(assignment) {
                var resource = resourceStore.getModelById(assignment.getResourceId());

                if (resource) {
                    me.remove(assignment.getEventId(), resource);
                }
                // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the resource store
                else {
                    me.clear(assignment.getEventId());
                }
            });
        }

        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField    = assignment.resourceIdField,
                resourceIdChanged  = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField],
                eventIdField       = assignment.eventIdField,
                eventIdChanged     = assignment.previous && eventIdField in assignment.previous,
                previousEventId    = eventIdChanged && assignment.previous[eventIdField],
                eventStore         = me.assignmentStore.getEventStore(),
                resourceStore      = eventStore && eventStore.getResourceStore(),
                resource;

            if (operation != Ext.data.Model.COMMIT && (resourceIdChanged || eventIdChanged)) {

                previousResourceId = resourceIdChanged ? previousResourceId : assignment.getResourceId();
                previousEventId    = eventIdChanged    ? previousEventId    : assignment.getEventId();

                resource = resourceStore.getModelById(previousResourceId);
                if (resource) {
                    me.remove(previousEventId, resource);
                }
                else {
                    me.clear(previousEventId);
                }

                resource = resourceStore.getModelById(assignment.getResourceId());
                if (resource) {
                    me.add(assignment.getEventId(), resource);
                }
                else {
                    me.clear(assignment.getEventId());
                }
            }
        }

        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }

        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }

        function onEventIdChanged(eventStore, event, oldId, newId) {
            me.move(oldId, newId);
        }

        function onEventRemove(eventStore, events) {
            Ext.Array.forEach(events, function(event) {
                me.clear(event);
            });
        }

        function onEventStoreClearOrReset() {
            me.clear();
        }

        function onEventStoreResourceStoreChange(eventStore, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }

        function onResourceRemove(resourceStore, resources) {
            Ext.Array.forEach(resources, function(resource) {
                me.uncache(resource);
            });
        }

        function onResourceStoreClearOrReset() {
            me.clear();
        }

        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                idchanged           : onEventIdChanged,
                remove              : onEventRemove,
                clear               : onEventStoreClearOrReset,
                cacheresethint      : onEventStoreClearOrReset,
                rootchange          : onEventStoreClearOrReset,
                resourcestorechange : onEventStoreResourceStoreChange,
                priority            : 100,
                destroyable         : true
            });
        }

        function attachToResourceStore(resourceStore) {
            Ext.destory(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                remove         : onResourceRemove,
                clear          : onResourceStoreClearOrReset,
                cacheresethint : onResourceStoreClearOrReset,
                rootchange     : onResourceStoreClearOrReset,
                priority       : 100,
                destroyable    : true
            });
        }

        me.assignmentStoreDetacher = assignmentStore.on({
            add            : onAssignmentAdd,
            remove         : onAssignmentRemove,
            update         : onAssignmentUpdate,
            clear          : onAssignmentStoreClearOrReset,
            cacheresethint : onAssignmentStoreClearOrReset,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority    : 100,
            destroyable : true
        });

        me.assignmentStore = assignmentStore;
    },

    destroy : function() {
        var me = this;
        Ext.destroyMembers(
            me,
            'assignmentStoreDetacher',
            'eventStoreDetacher',
            'resourceStoreDetacher'
        );
        me.assignmentStore = null;
    },

    get : function(k, fn) {
        var me = this;

        fn = fn || function() {
            return me.assignmentStore.mapAssignmentsForEvent(
                k,
                function mapper(assignment) {
                    return assignment.getResource();
                },
                function filter(resource) {
                    return !!resource;
                }
            );
        };

        return me.callParent([k, fn]);
    }
});

/**
 * Assignment store resource->events cache.
 * Uses resource records or resource record ids as keys.
 *
 * @private
 */
if (!Ext.ClassManager.get('Sch.data.util.AssignmentStoreResourceEventsCache')) Ext.define('Sch.data.util.AssignmentStoreResourceEventsCache', {
    extend   : 'Sch.util.Cache',
    requires : [
        'Ext.data.Model'
    ],

    assignmentStore         : null,
    assignmentStoreDetacher : null,
    eventStoreDetacher      : null,
    resourceStoreDetacher   : null,

    constructor : function(assignmentStore) {
        var me = this,
            eventStore = assignmentStore.getEventStore(),
            resourceStore = eventStore && eventStore.getResourceStore();

        me.callParent();

        function onAssignmentAdd(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore();

            Ext.Array.forEach(assignments, function(assignment) {
                var event = eventStore && eventStore.getModelById(assignment.getEventId());

                if (event) {
                    me.add(assignment.getResourceId(), event);
                }
                // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the event store
                else {
                    me.clear(assignment.getResourceId());
                }
            });
        }

        function onAssignmentRemove(store, assignments) {
            var eventStore = me.assignmentStore.getEventStore();

            Ext.Array.forEach(assignments, function(assignment) {
                var event = eventStore && eventStore.getModelById(assignment.getEventId());

                if (event) {
                    me.remove(assignment.getResourceId(), event);
                }
                // Cache can't be validly updated, so clearing key entirily hoping that upon next key get() operation
                // the event will be there in the event store
                else {
                    me.clear(assignment.getResourceId());
                }
            });
        }

        function onAssignmentUpdate(store, assignment, operation) {
            var resourceIdField    = assignment.resourceIdField,
                resourceIdChanged  = assignment.previous && resourceIdField in assignment.previous,
                previousResourceId = resourceIdChanged && assignment.previous[resourceIdField],
                eventIdField       = assignment.eventIdField,
                eventIdChanged     = assignment.previous && eventIdField in assignment.previous,
                previousEventId    = eventIdChanged && assignment.previous[eventIdField],
                eventStore         = me.assignmentStore.getEventStore(),
                event;

            if (operation != Ext.data.Model.COMMIT && (resourceIdChanged || eventIdChanged)) {

                previousResourceId = resourceIdChanged ? previousResourceId : assignment.getResourceId();
                previousEventId    = eventIdChanged    ? previousEventId    : assignment.getEventId();

                event = eventStore && eventStore.getModelById(previousEventId);
                if (event) {
                    me.remove(previousResourceId, event);
                }
                else {
                    me.clear(previousResourceId);
                }

                event = eventStore && eventStore.getModelById(assignment.getEventId());
                if (event) {
                    me.add(assignment.getResourceId(), event);
                }
                else {
                    me.clear(assignment.getResourceId());
                }
            }
        }

        function onAssignmentStoreClearOrReset(store) {
            me.clear();
        }

        function onAssignmentStoreEventStoreChange(store, eventStore) {
            me.clear();
            attachToEventStore(eventStore);
            attachToResourceStore(eventStore && eventStore.getResourceStore());
        }

        function onEventRemove(eventStore, events) {
            Ext.Array.forEach(events, function(event) {
                me.uncache(event);
            });
        }

        function onEventStoreClearOrReset() {
            me.clear();
        }

        function onEventStoreResourceStoreChange(store, resourceStore) {
            me.clear();
            attachToResourceStore(resourceStore);
        }

        function onResourceIdChanged(resourceStore, resource, oldId, newId) {
            me.move(oldId, newId);
        }

        function onResourceRemove(resourceStore, resources) {
            Ext.Array.forEach(resources, function(resource) {
                me.clear(resource);
            });
        }

        function onResourceStoreClearOrReset() {
            me.clear();
        }

        function attachToEventStore(eventStore) {
            Ext.destroy(me.eventStoreDetacher);
            me.eventStoreDetacher = eventStore && eventStore.on({
                remove              : onEventRemove,
                cacheresethint      : onEventStoreClearOrReset,
                clear               : onEventStoreClearOrReset,
                rootchange          : onEventStoreClearOrReset,
                resourcestorechange : onEventStoreResourceStoreChange,
                priority            : 100,
                destroyable         : true
            });
        }

        function attachToResourceStore(resourceStore) {
            Ext.destroy(me.resourceStoreDetacher);
            me.resourceStoreDetacher = resourceStore && resourceStore.on({
                idchanged      : onResourceIdChanged,
                remove         : onResourceRemove,
                cacheresethint : onResourceStoreClearOrReset,
                clear          : onResourceStoreClearOrReset,
                rootchange     : onResourceStoreClearOrReset,
                priority       : 100,
                destroyable    : true
            });
        }

        me.assignmentStoreDetacher = assignmentStore.on({
            add              : onAssignmentAdd,
            remove           : onAssignmentRemove,
            update           : onAssignmentUpdate,
            cacheresethint   : onAssignmentStoreClearOrReset,
            clear            : onAssignmentStoreClearOrReset,
            eventstorechange : onAssignmentStoreEventStoreChange,
            // subscribing to the CRUD using priority - should guarantee that our listeners
            // will be called first (before any other listeners, that could be provided in the "listeners" config)
            // and state in other listeners will be correct
            priority         : 100,
            destroyable      : true
        });

        attachToEventStore(eventStore);
        attachToResourceStore(resourceStore);

        me.assignmentStore = assignmentStore;
    },

    destroy : function() {
        var me = this;
        Ext.destroyMembers(
            me,
            'assignmentStoreDetacher',
            'eventStoreDetacher',
            'resourceStoreDetacher'
        );
        me.assignmentStore = null;
    },

    get : function(k, fn) {
        var me = this;

        fn = fn || function() {
            return me.assignmentStore.mapAssignmentsForResource(
                k,
                function mapper(assignment) {
                    return assignment.getEvent();
                },
                function filter(event) {
                    return !!event;
                }
            );
        };

        return me.callParent([k, fn]);
    }
});

/**
 * This class manages model persistency, it listens to model stores' beforesync event and removes all non persistable
 * records from sync operation. The logic has meaning only for CRUD-less sync operations.
 *
 * @private
 */
if (!Ext.ClassManager.get("Sch.data.util.ModelPersistencyManager")) Ext.define('Sch.data.util.ModelPersistencyManager', {

    config : {
        eventStore      : null,
        resourceStore   : null,
        assignmentStore : null
    },

    eventStoreDetacher      : null,
    resourceStoreDetacher   : null,
    assignmentStoreDetacher : null,

    constructor : function(config) {
        this.initConfig(config);
    },

    // {{{ Event attachers
    updateEventStore : function(newEventStore, oldEventStore) {
        var me = this;

        Ext.destroyMembers(me, 'eventStoreDetacher');

        if (newEventStore && newEventStore.autoSync) {
            me.eventStoreDetacher = newEventStore.on({
                beforesync  : me.onEventStoreBeforeSync,
                scope       : me,
                destroyable : true,
                // Just in case
                priority    : 100
            });
        }
    },

    updateResourceStore : function(newResourceStore, oldResourceStore) {
        var me = this;

        Ext.destroyMembers(me, 'resourceStoreDetacher');

        if (newResourceStore && newResourceStore.autoSync) {
            me.resourceStoreDetacher = newResourceStore.on({
                beforesync  : me.onResourceStoreBeforeSync,
                scope       : me,
                destroyable : true,
                // Just in case
                priority    : 100
            });
        }
    },

    updateAssignmentStore : function(newAssignmentStore, oldAssignmentStore) {
        var me = this;

        Ext.destroyMembers(me, 'assignmentStoreDetacher');

        if (newAssignmentStore && newAssignmentStore.autoSync) {
            me.assignmentStoreDetacher = newAssignmentStore.on({
                beforesync  : me.onAssignmentStoreBeforeSync,
                scope       : me,
                destroyable : true,
                // Just in case
                priority    : 100
            });
        }
    },
    // }}}

    // {{{ Event handlers
    onEventStoreBeforeSync : function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },

    onResourceStoreBeforeSync : function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },

    onAssignmentStoreBeforeSync : function(options) {
        var me = this;
        me.removeNonPersistableRecordsToCreate(options);
        return me.shallContinueSync(options);
    },
    // }}}

    // {{{ Management rules
    removeNonPersistableRecordsToCreate : function(options) {
        var recordsToCreate = options.create || [],
            r, i;

        // We remove from the array we iterate thus we iterate from end to start
        for (i = recordsToCreate.length - 1; i >= 0; --i) {
            r = recordsToCreate[i];
            if (!r.isPersistable()) {
                Ext.Array.remove(recordsToCreate, r);
            }
        }

        // Prevent empty create request
        if (recordsToCreate.length === 0) {
            delete options.create;
        }
    },

    shallContinueSync : function(options) {
        return Boolean((options.create  && options.create.length  > 0) ||
                       (options.update  && options.update.length  > 0) ||
                       (options.destroy && options.destroy.length > 0));
    }
    // }}}
});

/**
 * This class manages id consistency among model stores, it listens to 'idchanged' event on each store and updates
 * referential fields referencing records with changed ids in other model entities.
 *
 * Note on update process:
 *  at the time when 'idchanged' handler is called we can effectively query stores which are using caches for
 *  a data cached under old id, but we cannot update related models with the new id since at the time of
 *  'idchanged' handler is called a record which id has been updated is still marked as phantom, it's
 *  phantom flag will be reset only at 'update' event time (and 'idchanged' event is always followed by 'update'
 *  event) and it's important we start updating related records after primary records are not phantoms
 *  any more since we might rely on this flag (for example a related store sync operation might be blocked
 *  if primary store records it relies on are still phantom).
 *
 * @private
 */
if (!Ext.ClassManager.get("Sch.data.util.IdConsistencyManager")) Ext.define('Sch.data.util.IdConsistencyManager', {

    config : {
        eventStore      : null,
        resourceStore   : null,
        assignmentStore : null
    },

    eventStoreDetacher     : null,
    resourceStoreDetacher  : null,

    constructor : function(config) {
        this.initConfig(config);
    },

    // {{{ Event attachers
    updateEventStore : function(newEventStore, oldEventStore) {
        var me = this;

        Ext.destroyMembers(me, 'eventStoreDetacher');

        if (newEventStore) {
            me.eventStoreDetacher = newEventStore.on({
                idchanged   : me.onEventIdChanged,
                scope       : me,
                destroyable : true,
                // It's important that priority here was more then in assignment/event store caches
                // otherwise quering by old id won't return correct results, assignment will be moved
                // to new event id already if this priority is lower then the one used in cache
                priority    : 200
            });
        }
    },

    updateResourceStore : function(newResourceStore, oldResourceStore) {
        var me = this;

        Ext.destroyMembers(me, 'resourceStoreDetacher');

        if (newResourceStore) {
            me.resourceStoreDetacher = newResourceStore.on({
                idchanged   : me.onResourceIdChanged,
                scope       : me,
                destroyable : true,
                // It's important that priority here was more then in assignment/event store caches
                // otherwise quering by old id won't return correct results, assignment will be moved
                // to new resource id already if this priority is lower then the one used in cache
                priority    : 200
            });
        }
    },
    // }}}

    // {{{ Event handlers

    // Please see the note at the class description
    onEventIdChanged : function(eventStore, event, oldId, newId) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            assignmentsUpdater;

        if (assignmentStore) {
            assignmentsUpdater = me.getUpdateAssignmentEventIdFieldFn(assignmentStore, oldId, newId);
            eventStore.on(
                'update',
                assignmentsUpdater,
                null,
                { single : true, priority : 200 }
            );
        }
    },

    // Please see the note at the class description
    onResourceIdChanged : function(resourceStore, resource, oldId, newId) {
        var me = this,
            eventStore = me.getEventStore(),
            assignmentStore = me.getAssignmentStore(),
            eventsUpdater,
            assignmentsUpdater;

        if (eventStore && !assignmentStore) {
            eventsUpdater = me.getUpdateEventResourceIdFieldFn(eventStore, oldId, newId);
        }

        if (assignmentStore) {
            assignmentsUpdater = me.getUpdateAssignmentResourceIdFieldFn(assignmentStore, oldId, newId);
        }

        if (eventsUpdater || assignmentStore) {
            resourceStore.on(
                'update',
                function() {
                    eventsUpdater && eventsUpdater();
                    assignmentsUpdater && assignmentsUpdater();
                },
                null,
                { single : true, priority : 200 }
            );
        }
    },
    // }}}

    // {{{ Update rules
    getUpdateEventResourceIdFieldFn : function(eventStore, oldId, newId) {
        var events = eventStore.getRange();

        return function() {
            Ext.Array.forEach(events, function(event) {
                event.getResourceId() == oldId && event.setResourceId(newId);
            });
        };
    },

    getUpdateAssignmentEventIdFieldFn : function(assignmentStore, oldId, newId) {
        var assignments = assignmentStore.getAssignmentsForEvent(oldId);

        return function() {
            Ext.Array.forEach(assignments, function(assignment) {
                assignment.getEventId() == oldId && assignment.setEventId(newId);
            });
        };
    },

    getUpdateAssignmentResourceIdFieldFn : function(assignmentStore, oldId, newId) {
        var assignments = assignmentStore.getAssignmentsForResource(oldId);

        return function() {
            Ext.Array.forEach(assignments, function(assignment) {
                assignment.getResourceId() == oldId && assignment.setResourceId(newId);
            });
        };
    }
    // }}}
});

/**
 * This mixin eliminates differences between flat/tree store in get by [internal] id functionality and it should be
 * mixed into data model stores.
 *
 * It adds two methods {@link #getModelById getModelById()} and {@link #getModelByInternalId getModelByInternalId()}
 * which should be used everywhere in the code instead of native getById() / getByInternalId() methods.
 *
 * @private
 */
if (!Ext.ClassManager.get("Sch.data.mixin.UniversalModelGetter")) Ext.define('Sch.data.mixin.UniversalModelGetter', {

    getModelById : function(id) {
        var me = this;
        return me.getNodeById ? me.getNodeById(id) : me.getById(id);
    },

    getModelByInternalId : function(id) {
        var me = this;
        return me.byInternalIdMap ? me.byInternalIdMap[id] : me.getByInternalId(id);
    }

});

/**
 * This mixin intercepts a set of store methods and firing a set of events providing a cache with a better hint
 * when to update itself.
 *
 * @private
 */
if (!Ext.ClassManager.get('Sch.data.mixin.CacheHintHelper')) Ext.define('Sch.data.mixin.CacheHintHelper', {
    extend : 'Ext.Mixin',

    mixinConfig : {
        before : {
            loadRecords : 'loadRecords'
        }
    },

    // Call to loadRecords() results in 'datachanged' and 'refresh' events, but 'datachanged' is also fired upon
    // call to add/remove/write/filter/sort/removeAll so a cache cannot detect what method call results in 'datachanged'
    // in case of previosly mentioned methods a cache shouldn't handle 'datachanged' event it is not affected by
    // write/filter/sort at all, as for add/remove/removeAll it listens to preceding events like 'add'/'remove'/'clear'
    // and reflects updates correspondingly. But in case of loadRecords() the sequence of events fired 'datachanged' and
    // 'refresh' provides to little information to make right decision whether to reset a cache or not, moreover resetting
    // a cache on 'refresh' is to late since a lot of logic (rendering logic especially) start quering the store
    // upon 'datachanged' event and thus if cache wasn't reset it will provide that logic with outdated data.
    // Thus I have to override loadRecords() and make it fire private 'loadrecords' event to provide a cache with
    // a way to reset itself beforehand.
    loadRecords : function() {
        var me = this;
        me.fireEvent('cacheresethint', me);
    }
});

/**
@class Sch.data.mixin.EventStore

This is a mixin, containing functionality related to managing events.

It is consumed by the regular {@link Sch.data.EventStore} class and {@link Gnt.data.TaskStore} class
to allow data sharing between gantt chart and scheduler. Please note though, that datasharing is still
an experimental feature and not all methods of this mixin can be used yet on a TaskStore.

*/
if (!Ext.ClassManager.get("Sch.data.mixin.EventStore")) Ext.define("Sch.data.mixin.EventStore", {
    extend : 'Ext.Mixin',

    requires : [
        'Sch.util.Date',
        'Sch.data.util.IdConsistencyManager',
        'Sch.data.util.ModelPersistencyManager',
        'Sch.data.util.ResourceEventsCache'
    ],

    isEventStore : true,

    resourceStore         : null,
    resourceStoreDetacher : null,
    assignmentStore       : null,

    resourceEventsCache     : null,
    idConsistencyManager    : null,
    modelPersistencyManager : null,

    mixinConfig : {
        after : {
            constructor : 'constructor',
            destroy : 'destroy'
        }
    },

    /**
     * @constructor
     */
    constructor : function() {
        var me = this;
        me.resourceEventsCache     = me.createResourceEventsCache();
        me.idConsistencyManager    = me.createIdConsistencyManager();
        me.modelPersistencyManager = me.createModelPersistencyManager();
    },

    destroy : function() {
        var me = this;
        Ext.destroyMembers(
            me,
            'resourceEventsCache',
            'idConsistencyManager',
            'modelPersistencyManager'
        );
    },

    /**
     * Creates and returns Resource->Events cache.
     *
     * @return {Sch.data.util.ResourceEventsCache}
     * @template
     * @protected
     */
    createResourceEventsCache : function() {
        return new Sch.data.util.ResourceEventsCache(this);
    },

    /**
     * Creates and returns id consistency manager
     *
     * @return {Sch.data.util.IdConsistencyManager}
     * @tempalte
     * @protected
     */
    createIdConsistencyManager : function() {
        var me = this;
        return new Sch.data.util.IdConsistencyManager({
            eventStore      : me,
            resourceStore   : me.getResourceStore(),
            assignmentStore : me.getAssignmentStore()
        });
    },

    /**
     * Creates and returns model persistency manager
     *
     * @return {Sch.data.util.ModelPersistencyManager}
     * @tempalte
     * @protected
     */
    createModelPersistencyManager : function() {
        var me = this;
        return new Sch.data.util.ModelPersistencyManager({
            eventStore      : me,
            resourceStore   : me.getResourceStore(),
            assignmentStore : me.getAssignmentStore()
        });
    },

    /**
     * Gets the resource store for this store
     *
     * @return {Sch.data.ResourceStore} resourceStore
     */
    getResourceStore : function () {
        return this.resourceStore;
    },

    /**
     * Sets the resource store for this store
     *
     * @param {Sch.data.ResourceStore} resourceStore
     */
    setResourceStore : function (resourceStore) {
        var me = this,
            oldStore = me.resourceStore;

        if (me.resourceStore) {
            me.resourceStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(null);
        }

        me.resourceStore = resourceStore && Ext.StoreMgr.lookup(resourceStore) || null;

        if (me.resourceStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setResourceStore(me.resourceStore);
            me.idConsistencyManager && me.idConsistencyManager.setResourceStore(me.resourceStore);
            resourceStore.setEventStore(me);
        }

        if ((oldStore || resourceStore) && oldStore !== resourceStore) {
            /**
             * @event resourcestorechange
             * Fires when new resource store is set via {@link #setResourceStore} method.
             * @param {Sch.data.EventStore}         this
             * @param {Sch.data.ResourceStore|null} newResourceStore
             * @param {Sch.data.ResourceStore|null} oldResourceStore
             */
            me.fireEvent('resourcestorechange', me, resourceStore, oldStore);
        }
    },

    /**
     * Returns assignment store this event store is using by default.
     *
     * @return {Sch.data.AssignmentStore|null}
     */
    getAssignmentStore : function() {
        return this.assignmentStore;
    },

    /**
     * Sets assignment store instance this event store will be using by default.
     *
     * @param {Sch.data.AssignmentStore} store
     */
    setAssignmentStore : function(assignmentStore) {
        var me = this,
            oldStore = me.assignmentStore;

        if (me.assignmentStore) {
            me.assignmentStore.setEventStore(null);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(null);
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(null);
        }

        me.assignmentStore = assignmentStore && Ext.StoreMgr.lookup(assignmentStore) || null;

        if (me.assignmentStore) {
            me.modelPersistencyManager && me.modelPersistencyManager.setAssignmentStore(me.assignmentStore);
            me.idConsistencyManager && me.idConsistencyManager.setAssignmentStore(me.assignmentStore);
            me.assignmentStore.setEventStore(me);
            // If assignment store's set then caching now will be done by it
            // and event store doesn't need to maintain it's own resource-to-events cache.
            Ext.destroy(me.resourceEventsCache);
        }
        else {
            // If assignment store's reset then caching now should be done by
            // event store again.
            me.resourceEventsCache = me.createResourceEventsCache();
        }

        if ((oldStore || assignmentStore) && oldStore !== assignmentStore) {
            /**
             * @event assignmentstorechange
             * Fires when new assignment store is set via {@link #setAssignmentStore} method.
             * @param {Sch.data.EventStore}           this
             * @param {Sch.data.AssignmentStore|null} newAssignmentStore
             * @param {Sch.data.AssignmentStore|null} oldAssignmentStore
             */
            me.fireEvent('assignmentstorechange', me, assignmentStore, oldStore);
        }
    },

    /**
    * Checks if a date range is allocated or not for a given resource.
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Sch.model.Event} excludeEvent An event to exclude from the check (or null)
    * @param {Sch.model.Resource} resource The resource
    * @return {Boolean} True if the timespan is available for the resource
    */
    isDateRangeAvailable: function (start, end, excludeEvent, resource) {
        var DATE = Sch.util.Date,
            events = this.getEventsForResource(resource),
            available = true;

        // This can be optimized further if we use simple for() statement (will lead to -1 function call in the loop)
        Ext.each(events, function (ev) {

            available = (
                excludeEvent === ev ||
                !DATE.intersectSpans(start, end, ev.getStartDate(), ev.getEndDate())
            );

            return available; // to immediately stop looping if interval is occupied by a non excluding event
        });

        return available;
    },

    /**
    * Returns events between the supplied start and end date
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Boolean} allowPartial false to only include events that start and end inside of the span
    * @return {Ext.util.MixedCollection} the events
    */
    getEventsInTimeSpan: function (start, end, allowPartial) {
        var coll = new Ext.util.MixedCollection(); // TODO: do we real need the mixed collection here?
        var events = [];

        if (allowPartial !== false) {
            var DATE = Sch.util.Date;

            this.forEachScheduledEvent(function (event, eventStart, eventEnd) {
                if (DATE.intersectSpans(eventStart, eventEnd, start, end)) {
                    events.push(event);
                }
            });
        } else {
            this.forEachScheduledEvent(function (event, eventStart, eventEnd) {
                if (eventStart - start >= 0 && end - eventEnd >= 0) {
                    events.push(event);
                }
            });
        }

        coll.addAll(events);

        return coll;
    },

    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     *      - event : the event record
     *      - startDate : the event start date
     *      - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} fn iterator function
     * @param {Object} scope scope for the function
     */
    forEachScheduledEvent : function (fn, scope) {

        this.each(function (event) {
            var eventStart = event.getStartDate(),
                eventEnd = event.getEndDate();

            if (eventStart && eventEnd) {
                return fn.call(scope || this, event, eventStart, eventEnd);
            }
        }, this);
    },

    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     *
     * @return {Object} An object with 'start' and 'end' Date properties (or null values if data is missing).
     */
    getTotalTimeSpan : function() {
        var earliest = new Date(9999,0,1),
            latest = new Date(0),
            D = Sch.util.Date;

        this.each(function(r) {
            if (r.getStartDate()) {
                earliest = D.min(r.getStartDate(), earliest);
            }
            if (r.getEndDate()) {
                latest = D.max(r.getEndDate(), latest);
            }
        });

        // TODO: this will fail in programs designed to work with events in the past (after Jan 1, 1970)
        earliest = earliest < new Date(9999,0,1) ? earliest : null;
        latest = latest > new Date(0) ? latest : null;

        return {
            start : earliest || null,
            end : latest || earliest || null
        };
    },

    /**
     * Filters the events associated with a resource, based on the function provided. An array will be returned for those
     * events where the passed function returns true.
     * @private {Sch.model.Resource} resource
     * @param {Sch.model.Resource} resource
     * @param {Function} fn The function
     * @param {Object} [scope] The 'this object' for the function
     * @return {Sch.model.Event[]} the events in the time span
     */
    filterEventsForResource : function (resource, fn, scope) {
        // `getEvents` method of the resource will use either `indexByResource` or perform a full scan of the event store
        var events = resource.getEvents(this);

        return Ext.Array.filter(events, fn, scope || this);
    },

    // This method provides a way for the store to append a new record, and the consuming class has to implement it
    // since Store and TreeStore don't share the add API.
    append : function(record) {
        throw 'Must be implemented by consuming class';
    },

    // {{{ Entire data model management methods

    /**
     * Returns all resources assigned to an event.
     *
     * @param {Sch.model.Event|Mixed} event
     * @return {[Sch.model.Resource]}
     */
    getResourcesForEvent : function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resourceStore   = me.getResourceStore(),
            result;

        if (assignmentStore) {
            result = assignmentStore.getResourcesForEvent(event);
        }
        else if (resourceStore) {
            event   = event instanceof Sch.model.Event && event || me.getModelById(event);
            result = event && resourceStore.getModelById(event.getResourceId());
            result = result && [result] || [];
        }
        else {
            result = [];
        }

        return result;
    },

    /**
     * Returns all events assigned to a resource
     *
     * @param {Sch.model.Resource|Mixed} resource
     * @return {[Sch.model.Event]}
     */
    getEventsForResource : function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resourceStore,
            result;

        if (assignmentStore) {
            result = assignmentStore.getEventsForResource(resource);
        }
        // Resource->Events cache is not always accessable, a subclass might override createResourceEventsCache() method
        // returning null
        else if (me.resourceEventsCache) {
            result = me.resourceEventsCache.get(resource);
        }
        else {
            result = [];
        }

        return result;
    },

    /**
     * Returns all assignments for a given event.
     *
     * @param {Sch.model.Event|Mixed} event
     * @return {[Sch.model.Assignment]}
     */
    getAssignmentsForEvent : function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore();

        return assignmentStore && assignmentStore.getAssignmentsForEvent(event) || [];
    },

    /**
     * Returns all assignments for a given resource.
     *
     * @param {Sch.model.Resource|Mixed} resource
     * @return {[Sch.model.Assignment]}
     */
    getAssignmentsForResource : function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();

        return assignmentStore && assignmentStore.getAssignmentsForResource(resource) || [];
    },

    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Sch.model.Event|Mixed} The event
     * @param {Sch.model.Resource|Mixed|[Sch.model.Resource]|[Mixed]} The resource(s) to assign to the event
     */
    assignEventToResource : function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();

        if (assignmentStore) {
            assignmentStore.assignEventToResource(event, resource);
        }
        else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource; // resource id might be 0 thus we use ? operator
            event && event.setResourceId(resource); // This will update resource events cache via 'update' event.
        }
    },

    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Sch.model.Event|Mixed} event
     * @param {Sch.model.Resource|Mixed} resource
     */
    unassignEventFromResource : function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();

        if (assignmentStore) {
            assignmentStore.unassignEventFromResource(event, resource);
        }
        else  {
            event    = event instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource; // resource id might be 0 thus we use ? operator
            if (event && event.getResourceId() == resource) {
                event.setResourceId(null); // This will update resource events cache via 'update' event
            }
        }
    },

    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Sch.model.Event/Mixed}    event    An event to reassign
     * @param {Sch.model.Resource/Mixed} resource A resource to unassign from
     * @parma {Sch.model.Resource/Mixed} resource A resource to assign to
     */
    reassignEventFromResourceToResource : function(event, oldResource, newResource) {
        var me = this,
            assignmentStore = me.getAssignmentStore();

        if (assignmentStore) {
            assignmentStore.unassignEventFromResource(event, oldResource);
            assignmentStore.assignEventToResource(event, newResource);
        }
        else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            oldResource = oldResource instanceof Sch.model.Resource ? oldResource.getId() : oldResource; // resource id might be 0 thus we use ? operator
            newResource = newResource instanceof Sch.model.Resource ? newResource.getId() : newResource; // resource id might be 0 thus we use ? operator
            if (event.getResourceId() == oldResource) {
                event.setResourceId(newResource);
            }
        }
    },

    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Sch.model.Event|Mixed} event
     * @param {Sch.model.Resource|Mixed} resource
     * @param {Function} [fn] Function which will resieve assignment record if one present
     * @return {Boolean}
     */
    isEventAssignedToResource : function(event, resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            result;

        if (assignmentStore) {
            result = assignmentStore.isEventAssignedToResource(event, resource);
        }
        else {
            event    = event    instanceof Sch.model.Event && event || me.getModelById(event);
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource; // resource id might be 0 thus we use ? operator
            result = event && (event.getResourceId() == resource) || false;
        }

        return result;
    },

    /**
     * Removes all assignments for given event
     *
     * @param {Sch.model.Event|Mixed} event
     */
    removeAssignmentsForEvent : function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore();

        if (assignmentStore) {
            assignmentStore.removeAssignmentsForEvent(event);
        }
        else {
            event = event instanceof Sch.model.Event && event || me.getModelById(event);
            event && event.setResourceId(null); // This will update resource events cache via 'update' event
        }
    },

    /**
     * Removes all assignments for given resource
     *
     * @param {Sch.model.Resource|Mixed} resource
     */
    removeAssignmentsForResource : function(resource) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resourceStore   = me.getResourceStore();

        if (assignmentStore) {
            assignmentStore.removeAssignmentsForResource(resource);
        }
        else if (resourceStore) {
            resource = resource instanceof Sch.model.Resource && resource || resourceStore.getModelById(resource);
            resource && Ext.Array.forEach(me.resourceEventsCache.get(resource), function(event) {
                event.setResourceId(null); // This will update resource events cache via 'update' event
            });
        }
        else {
            resource = resource instanceof Sch.model.Resource ? resource.getId() : resource; // resource id might be 0 thus we use ? operator
            Ext.Array.forEach(me.getRange(), function(event) {
                event.getResourceId() == resource && event.setResourceId(null); // This will update resource events cache via 'update' event
            });
        }
    },

    /**
     * Checks if given event record is persistable.
     * In case assignment store is used to assign events to resources and vise versa event is considered to be always
     * persistable. Otherwise backward compatible logic is used, i.e. event is considered to be persistable when
     * resources it's assigned to are not phantom.
     *
     * @param {Sch.model.Range} event
     * @return {Boolean}
     */
    isEventPersistable : function(event) {
        var me = this,
            assignmentStore = me.getAssignmentStore(),
            resources, i, len,
            result = true;

        if (!assignmentStore) {
            resources = event.getResources();
            for (i = 0, len = resources.length; result && i < len; ++i) {
                result = resources[i].phantom !== true;
            }
        }

        return result;
    }
    // }}}
});

/**
@class Sch.data.EventStore

This is a class holding all the {@link Sch.model.Event events} to be rendered into a {@link Sch.SchedulerPanel scheduler panel}.

*/
if (!Ext.ClassManager.get("Sch.data.EventStore")) Ext.define("Sch.data.EventStore", {
    extend      : 'Ext.data.Store',
    alias       : 'store.eventstore',
    mixins      : [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.EventStore'
    ],

    storeId     : 'events',
    model       : 'Sch.model.Event',
    config      : { model : 'Sch.model.Event' },
    proxy       : 'memory',

    constructor : function(config) {
        var me = this;

        me.callParent([config]);

        me.resourceStore   && me.setResourceStore(me.resourceStore);
        me.assignmentStore && me.setAssignmentStore(me.assignmentStore);

        if (me.getModel() !== Sch.model.Event && !(me.getModel().prototype instanceof Sch.model.Event)) {
            throw 'The model for the EventStore must subclass Sch.model.Event';
        }
    },

    /**
     * Appends a new record to the store
     * @param {Sch.model.Event} record The record to append to the store
     */
    append : function(record) {
        this.add(record);
    }
});

/**
 * @class Sch.data.mixin.ResourceStore
 * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Sch.data.ResourceStore} class ("usual" store) and {@link Sch.data.ResourceTreeStore} - tree store.
 *
 */
if (!Ext.ClassManager.get("Sch.data.mixin.ResourceStore")) Ext.define("Sch.data.mixin.ResourceStore", {

    eventStore : null,

    /**
     * Returns the associated event store instance.
     *
     * @return {Gnt.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },

    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore;

        if (me.eventStore !== eventStore) {
            oldStore      = me.eventStore;
            me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;
            /**
             * @event eventstorechange
             * Fires when new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.ResourceStore}   this
             * @param {Sch.data.EventStore|null} newEventStore
             * @param {Sch.data.EventStore|null} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    }
});

/**
@class Sch.data.mixin.FilterableTreeStore

This is a mixin for the Ext.data.TreeStore providing filtering functionality. Please note, that Ext JS does not support filtering of tree stores,
and the functionality of this mixin is not related to the standard Ext JS store filtering (which utilizes Ext.util.Filter etc). This implementation should however be flexible
enough to cover all common uses cases.

The functionality of this class can be divided into two sections:

Filtering
=========

Filtering of a tree store is different from filtering flat stores. In a flat store, all nodes (items)
are of the same type and on the same hierarchical level. Filtering can hide any nodes that not matching some criteria.

On the other hand, in tree stores some of the nodes represent parent nodes with child nodes
("parent", "folder", "group" etc) and other nodes are "leaves". And usually a "leaf" node can't be
sufficiently identified w/o its parents - i.e. it is important to know all the parents that
a particular leaf node belongs to. So when filtering tree stores, we need to show all parent nodes of the filtered nodes.

Moreover, filtering is usually being used for searching and thus should ignore the "expanded/collapsed"
state of tree nodes (we need to search among all nodes, including collapsed ones).

Filtering can be activated with the {@link #filterTreeBy} method and cleared with {@link #clearTreeFilter}.

Hiding/Showing nodes
====================

Sometimes we want to keep some nodes in the tree, but remove them from the visual presentation and hide them.
This can be done with {@link #hideNodesBy} method and {@link #showAllNodes} can be used to restore the previous state.
When a node is hidden, all its child nodes are hidden too.

"Hidden" nodes will never appear in filtered results - consider them removed from the tree store completely.
They will, however, appear in a data package for a `store.sync()` operation (you can override the the "filterUpdated" method to exclude them from there if needed).

Note, that it is possible to filter a store with hidden nodes, but not the other way around (hide some nodes of a filtered store).

*/
Ext.define("Sch.data.mixin.FilterableTreeStore", {

    isFilteredFlag                      : false,
    isHiddenFlag                        : false,

    // ref to the last filter applied
    lastTreeFilter                      : null,
    lastTreeHiding                      : null,

    /**
     * @cfg {Boolean} allowExpandCollapseWhileFiltered When enabled (by default), tree store allows user to expand/collapse nodes while it is
     * filtered with the {@link #filterTreeBy} method. Please set it explicitly to `false` to restore the previous behavior,
     * where collapse/expand operations were disabled.
     */
    allowExpandCollapseWhileFiltered    : true,

    /**
     * @cfg {Boolean} reApplyFilterOnDataChange When enabled (by default), tree store will update the filtering (both {@link #filterTreeBy}
     * and {@link #hideNodesBy}) after new data is added to the tree or removed from it. Please set it explicitly to `false` to restore the previous behavior,
     * where this feature did not exist.
     */
    reApplyFilterOnDataChange           : true,

    suspendIncrementalFilterRefresh     : 0,

    filterGeneration                    : 0,
    currentFilterGeneration             : null,

    dataChangeListeners                 : null,
    monitoringDataChange                : false,
    
    filterUpdateSuspended               : false,

    onClassMixedIn : function (cls) {
        cls.override(Sch.data.mixin.FilterableTreeStore.prototype.inheritables() || {});
    },

     // Events (private)
     //    'filter-set',
     //    'filter-clear',
     //    'nodestore-datachange-start',
     //    'nodestore-datachange-end'

    /**
     * Should be called in the constructor of the consuming class, to activate the filtering functionality.
     */
    initTreeFiltering : function () {
        this.treeFilter = new Ext.util.Filter({
            filterFn    : this.isNodeFilteredIn,
            scope       : this
        });

        this.dataChangeListeners    = {
            nodeappend  : this.onNeedToUpdateFilter,
            nodeinsert  : this.onNeedToUpdateFilter,

            scope       : this
        };
        
        if (Ext.getVersion().isGreaterThan('5.1.0.107')) {
            // in Ext 5.1.1 sencha apparently fixed some issue and now each 'endupdate' on filters
            // lead to view refresh. When store is loading, filter is applied to each record and each time view is refreshed.
            // This code suspend filters until 'load' event is fired
            Ext.apply(this.dataChangeListeners, {
                beforeload  : this.onStoreBeforeLoad,
                load        : this.onStoreLoad
            });
        }
    },
    
    onStoreBeforeLoad : function () {
        this.filterUpdateSuspended = true;
    },
    
    onStoreLoad : function () {
        this.filterUpdateSuspended = false;
        this.onNeedToUpdateFilter();
    },

    startDataChangeMonitoring : function () {
        if (this.monitoringDataChange) return;

        this.monitoringDataChange   = true;

        this.on(this.dataChangeListeners);
    },


    stopDataChangeMonitoring : function () {
        if (!this.monitoringDataChange) return;

        this.monitoringDataChange   = false;

        this.un(this.dataChangeListeners);
    },


    onNeedToUpdateFilter : function () {
        if (this.reApplyFilterOnDataChange &&
            !this.filterUpdateSuspended && 
            !this.suspendIncrementalFilterRefresh) this.reApplyFilter();
    },


    /**
     * Clears the current filter (if any).
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    clearTreeFilter : function () {
        if (!this.isTreeFiltered()) return;

        this.currentFilterGeneration = null;
        this.isFilteredFlag     = false;
        this.lastTreeFilter     = null;

        if (!this.isTreeFiltered(true)) this.stopDataChangeMonitoring();

        this.refreshNodeStoreContent();

        this.fireEvent('filter-clear', this);
    },


    reApplyFilter : function () {
        // bypass the nodeStore content refresh if store has both hiding and filtering
        if (this.isHiddenFlag) this.hideNodesBy.apply(this, this.lastTreeHiding.concat(this.isFilteredFlag));

        if (this.isFilteredFlag) this.filterTreeBy(this.lastTreeFilter);
    },


    refreshNodeStoreContent : function () {
        var me      = this,
            filters = me.getFilters();

        if (filters.indexOf(me.treeFilter) < 0) {
            me.addFilter(me.treeFilter);
        } else {
            this.getFilters().fireEvent('endupdate', this.getFilters());
        }
    },


    getIndexInTotalDataset : function (record) {
        var root            = this.getRootNode(),
            index           = -1;

        var rootVisible     = this.rootVisible;

        if (!rootVisible && record == root) return -1;

        var isFiltered      = this.isTreeFiltered();
        var currentFilterGeneration = this.currentFilterGeneration;

        var collectNodes    = function (node) {
            if (isFiltered && node.__filterGen != currentFilterGeneration || node.hidden)
                // stop scanning if record we are looking for is hidden
                if (node == record) return false;

            if (rootVisible || node != root) index++;

            // stop scanning if we found the record
            if (node == record) return false;

            if (!node.data.leaf && node.isExpanded()) {
                var childNodes  = node.childNodes,
                    length      = childNodes.length;

                for (var k = 0; k < length; k++)
                    if (collectNodes(childNodes[ k ]) === false) return false;
            }
        };

        collectNodes(root);

        return index;
    },

    /**
     * Returns true if this store is currently filtered
     *
     * @return {Boolean}
     */
    isTreeFiltered : function (orHasHiddenNodes) {
        return this.isFilteredFlag || orHasHiddenNodes && this.isHiddenFlag;
    },

    markFilteredNodes : function (top, params) {
        var me                  = this;
        var filterGen           = this.currentFilterGeneration;
        var visibleNodes        = {};

        var root                = this.getRootNode(),
            rootVisible         = this.rootVisible;

        var includeParentNodesInResults = function (node) {
            var parent  = node.parentNode;

            while (parent && !visibleNodes[ parent.internalId ]) {
                visibleNodes[ parent.internalId ] = true;

                parent = parent.parentNode;
            }
        };

        var filter                  = params.filter;
        var scope                   = params.scope || this;
        var shallowScan             = params.shallow;
        var checkParents            = params.checkParents || shallowScan;
        var fullMatchingParents     = params.fullMatchingParents;
        var onlyParents             = params.onlyParents || fullMatchingParents;

        if (onlyParents && checkParents) throw new Error("Can't combine `onlyParents` and `checkParents` options");

        if (rootVisible) visibleNodes[ root.internalId ] = true;

        var collectNodes    = function (node) {
            if (node.hidden) return;

            var nodeMatches, childNodes, length, k;

            // `collectNodes` should not be called for leafs at all
            if (node.data.leaf) {
                if (filter.call(scope, node, visibleNodes)) {
                    visibleNodes[ node.internalId ] = true;

                    includeParentNodesInResults(node);
                }
            } else {
                if (onlyParents) {
                    nodeMatches     = filter.call(scope, node);

                    childNodes      = node.childNodes;
                    length          = childNodes.length;

                    if (nodeMatches) {
                        visibleNodes[ node.internalId ] = true;

                        includeParentNodesInResults(node);

                        // if "fullMatchingParents" option enabled we gather all matched parent's sub-tree
                        if (fullMatchingParents) {
                            node.cascadeBy(function (currentNode) {
                                visibleNodes[ currentNode.internalId ] = true;
                            });

                            return;
                        }
                    }

                    // at this point nodeMatches and fullMatchingParents can't be both true
                    for (k = 0; k < length; k++)
                        if (nodeMatches && childNodes[ k ].data.leaf)
                            visibleNodes[ childNodes[ k ].internalId ] = true;
                        else if (!childNodes[ k ].data.leaf)
                            collectNodes(childNodes[ k ]);

                } else {
                    // mark matching nodes to be kept in results
                    if (checkParents) {
                        nodeMatches = filter.call(scope, node, visibleNodes);

                        if (nodeMatches) {
                            visibleNodes[ node.internalId ] = true;

                            includeParentNodesInResults(node);
                        }
                    }

                    // recurse if
                    // - we don't check parents
                    // - shallow scan is not enabled
                    // - shallow scan is enabled and parent node matches the filter or it does not, but its and invisible root, so we don't care
                    if (!checkParents || !shallowScan || shallowScan && (nodeMatches || node == root && !rootVisible)) {
                        childNodes      = node.childNodes;
                        length          = childNodes.length;

                        for (k = 0; k < length; k++) collectNodes(childNodes[ k ]);
                    }
                }
            }
        };

        collectNodes(top);

        // additional filtering of the result set
        // removes parent nodes which do not match filter themselves and have no matching children


        root.cascadeBy(function (node) {
            if (visibleNodes[ node.internalId ]) {
                node.__filterGen = filterGen;

                if (me.allowExpandCollapseWhileFiltered && !node.data.leaf) node.expand();
            }
        });

    },


    /**
     * This method filters the tree store. It accepts an object with the following properties:
     *
     * - `filter` - a function to check if a node should be included in the result. It will be called for each **leaf** node in the tree and will receive the current node as the first argument.
     * It should return `true` if the node should remain visible, `false` otherwise. The result will also contain all parents nodes of all matching leafs. Results will not include
     * parent nodes, which do not have at least one matching child.
     * To call this method for parent nodes too, pass an additional parameter - `checkParents` (see below).
     * - `scope` - a scope to call the filter with (optional)
     * - `checkParents` - when set to `true` will also call the `filter` function for each parent node. If the function returns `false` for some parent node,
     * it could still be included in the filtered result if some of its children match the `filter` (see also "shallow" option below). If the function returns `true` for a parent node, it will be
     * included in the filtering results even if it does not have any matching child nodes.
     * - `shallow` - implies `checkParents`. When set to `true`, it will stop checking child nodes if the `filter` function return `false` for a parent node. The whole sub-tree, starting
     * from a non-matching parent, will be excluded from the result in such case.
     * - `onlyParents` - alternative to `checkParents`. When set to `true` it will only call the provided `filter` function for parent tasks. If
     * the filter returns `true`, the parent and all its direct child leaf nodes will be included in the results. If the `filter` returns `false`, a parent node still can
     * be included in the results (w/o direct children leafs), if some of its child nodes matches the filter.
     * - `fullMatchingParents` - implies `onlyParents`. In this mode, if a parent node matches the filter, then not only its direct children
     * will be included in the results, but the whole sub-tree, starting from the matching node.
     *
     * Repeated calls to this method will clear previous filters.
     *
     * This function can be also called with 2 arguments, which should be the `filter` function and `scope` in such case.
     *
     * For example:

    treeStore.filterTreeBy({
        filter          : function (node) { return node.get('name').match(/some regexp/) },
        checkParents    : true
    })

    // or, if you don't need to set any options:
    treeStore.filterTreeBy(function (node) { return node.get('name').match(/some regexp/) })

     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     *
     * @param {Object} params
     */
    filterTreeBy : function (params, scope) {
        this.currentFilterGeneration = this.filterGeneration++;

        var filter;

        if (arguments.length == 1 && Ext.isObject(arguments[ 0 ])) {
            scope       = params.scope;
            filter      = params.filter;
        } else {
            filter      = params;
            params      = { filter : filter, scope : scope };
        }

        this.fireEvent('nodestore-datachange-start', this);

        params                      = params || {};

        this.markFilteredNodes(this.getRootNode(), params);

        this.startDataChangeMonitoring();

        this.isFilteredFlag     = true;
        this.lastTreeFilter     = params;

        //this.fireEvent('clear', this);

        this.fireEvent('nodestore-datachange-end', this);

        this.fireEvent('filter-set', this);

        this.refreshNodeStoreContent();
    },


    isNodeFilteredIn : function (node) {
        var isFiltered              = this.isTreeFiltered();
        var currentFilterGeneration = this.currentFilterGeneration;

        return this.loading || !Boolean(isFiltered && node.__filterGen != currentFilterGeneration || node.hidden);
    },


    hasNativeFilters : function () {
        var me      = this,
            filters = me.getFilters(),
            count   = filters.getCount();

        return (count && count > 1) || filters.indexOf(me.treeFilter) < 0;
    },


    /**
     * Hide nodes from the visual presentation of tree store (they still remain in the store).
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     *
     * @param {Function} filter - A filtering function. Will be called for each node in the tree store and receive
     * the current node as the 1st argument. Should return `true` to **hide** the node
     * and `false`, to **keep it visible**.
     * @param {Object} scope (optional).
     */
    hideNodesBy : function (filter, scope, skipNodeStoreRefresh) {
        var me      = this;

        if (me.isFiltered() && me.hasNativeFilters()) throw new Error("Can't hide nodes of the filtered tree store");

        scope       = scope || me;

        me.getRootNode().cascadeBy(function (node) {
            node.hidden = Boolean(filter.call(scope, node, me));
        });

        me.startDataChangeMonitoring();

        me.isHiddenFlag     = true;
        me.lastTreeHiding   = [ filter, scope ];

        if (!skipNodeStoreRefresh) me.refreshNodeStoreContent();
    },


    /**
     * Shows all nodes that was previously hidden with {@link #hideNodesBy}
     *
     * See also {@link Sch.data.mixin.FilterableTreeStore} for additional information.
     */
    showAllNodes : function (skipNodeStoreRefresh) {
        this.getRootNode().cascadeBy(function (node) {
            node.hidden     = false;
        });

        this.isHiddenFlag       = false;
        this.lastTreeHiding     = null;

        if (!this.isTreeFiltered(true)) this.stopDataChangeMonitoring();

        if (!skipNodeStoreRefresh) this.refreshNodeStoreContent();
    },


    inheritables : function () {
        return {
            // @OVERRIDE
            onNodeExpand: function (parent, records, suppressEvent) {
                if (this.isTreeFiltered(true) && parent == this.getRoot()) {
                    this.callParent(arguments);
                    // the expand of the root node - most probably its the data loading
                    this.reApplyFilter();
                } else
                    return this.callParent(arguments);
            },

            // @OVERRIDE
            onNodeCollapse: function (parent, records, suppressEvent, callback, scope) {
                var me                      = this;
                var data                    = me.data;
                var prevContains            = data.contains;

                var isFiltered              = me.isTreeFiltered();
                var currentFilterGeneration = me.currentFilterGeneration;

                // the default implementation of `onNodeCollapse` only checks if the 1st record from collapsed nodes
                // exists in the node store. Meanwhile, that 1st node can be hidden, so we need to check all of them
                // thats what we do in the `for` loop below
                // then, if we found a node, we want to do actual removing of nodes and we override the original code from NodeStore
                // by always returning `false` from our `data.contains` override
                data.contains           = function () {
                    var node, sibling, lastNodeIndexPlus;

                    var collapseIndex   = me.indexOf(parent) + 1;
                    var found           = false;

                    for (var i = 0; i < records.length; i++)
                        if (
                            !(records[ i ].hidden || isFiltered && records[ i ].__filterGen != currentFilterGeneration) &&
                            prevContains.call(this, records[ i ])
                        ) {
                            // this is our override for internal part of `onNodeCollapse` method

                            // Calculate the index *one beyond* the last node we are going to remove
                            // Need to loop up the tree to find the nearest view sibling, since it could
                            // exist at some level above the current node.
                            node = parent;
                            while (node.parentNode) {
                                sibling = node;
                                do {
                                    sibling = sibling.nextSibling;
                                } while (sibling && (sibling.hidden || isFiltered && sibling.__filterGen != currentFilterGeneration));

                                if (sibling) {
                                    found = true;
                                    lastNodeIndexPlus = me.indexOf(sibling);
                                    break;
                                } else {
                                    node = node.parentNode;
                                }
                            }
                            if (!found) {
                                lastNodeIndexPlus = me.getCount();
                            }

                            // Remove the whole collapsed node set.
                            me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);

                            break;
                        }

                    // always return `false`, so original NodeStore code won't execute
                    return false;
                };

                this.callParent(arguments);

                data.contains           = prevContains;
            },

            // @OVERRIDE
            handleNodeExpand : function (parent, records, toAdd) {
                var me                      = this;
                var visibleRecords          = [];
                var isFiltered              = me.isTreeFiltered();
                var currentFilterGeneration = me.currentFilterGeneration;

                for (var i = 0; i < records.length; i++) {
                    var record          = records[ i ];

                    if (
                        !(isFiltered && record.__filterGen != currentFilterGeneration || record.hidden)
                    ) {
                        visibleRecords[ visibleRecords.length ] = record;
                    }
                }

                return this.callParent([ parent, visibleRecords, toAdd ]);
            },

            // @OVERRIDE
            onNodeInsert: function(parent, node, index) {
                var me = this,
                    refNode,
                    sibling,
                    storeReader,
                    nodeProxy,
                    nodeReader,
                    reader,
                    data = node.raw || node.data,
                    dataRoot,
                    isVisible,
                    childType;

                if (me.filterFn) {
                    isVisible = me.filterFn(node);
                    node.set('visible', isVisible);

                    // If a node which passes the filter is added to a parent node
                    if (isVisible) {
                        parent.set('visible', me.filterFn(parent));
                    }
                }

                // Register node by its IDs
                me.registerNode(node, true);

                me.beginUpdate();

                // Only react to a node append if it is to a node which is expanded.
                if (me.isVisible(node)) {
                    if (index === 0 || !node.previousSibling) {
                        refNode = parent;
                    } else {
                        // Find the previous visible sibling (filtering may have knocked out intervening nodes)
                        for (sibling = node.previousSibling; sibling && !sibling.get('visible'); sibling = sibling.previousSibling);
                        if (!sibling) {
                            refNode = parent;
                        } else {
                            while (sibling.isExpanded() && sibling.lastChild) {
                                sibling = sibling.lastChild;
                            }
                            refNode = sibling;
                        }
                    }

                    // The reaction to collection add joins the node to this Store
                    me.insert(me.indexOf(refNode) + 1, node);
                    if (!node.isLeaf() && node.isExpanded()) {
                        if (node.isLoaded()) {
                            // Take a shortcut
                            me.onNodeExpand(node, node.childNodes);
                        } else if (!me.fillCount) {
                            // If the node has been marked as expanded, it means the children
                            // should be provided as part of the raw data. If we're filling the nodes,
                            // the children may not have been loaded yet, so only do this if we're
                            // not in the middle of populating the nodes.
                            node.set('expanded', false);
                            node.expand();
                        }
                    }
                }

                // Set sync flag if the record needs syncing.
                else {
                    me.needsSync = me.needsSync || node.phantom || node.dirty;
                }

                if (!node.isLeaf() && !node.isLoaded() && !me.lazyFill) {
                    // With heterogeneous nodes, different levels may require differently configured readers to extract children.
                    // For example a "Disk" node type may configure it's proxy reader with root: 'folders', while a "Folder" node type
                    // might configure its proxy reader with root: 'files'. Or the root property could be a configured-in accessor.
                    storeReader = me.getProxy().getReader();
                    nodeProxy = node.getProxy();
                    nodeReader = nodeProxy ? nodeProxy.getReader() : null;

                    // If the node's reader was configured with a special root (property name which defines the children array) use that.
                    reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;

                    dataRoot = reader.getRoot(data);
                    if (dataRoot) {
                        childType = node.childType;
                        me.fillNode(node, reader.extractData(dataRoot, childType ? {
                            model: childType
                        } : undefined));
                    }
                }
                me.endUpdate();
            },

            isFiltered : function () {
                return this.callParent(arguments) || this.isTreeFiltered();
            }
        };
    }

});

/**
@class Sch.data.ResourceStore

This is a class holding the collection the {@link Sch.model.Resource resources} to be rendered into a {@link Sch.panel.SchedulerGrid scheduler panel}.
Its a subclass of "Ext.data.Store" - a store with linear data presentation.

*/
if (!Ext.ClassManager.get("Sch.data.ResourceStore")) Ext.define("Sch.data.ResourceStore", {
    extend      : 'Ext.data.Store',
    model       : 'Sch.model.Resource',
    config      : { model : 'Sch.model.Resource' },
    alias       : 'store.resourcestore',

    requires    : [
        'Sch.patches.OperationDestroy'
    ],

    mixins      : [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.ResourceStore'
    ],

    storeId     : 'resources',
    proxy       : 'memory',

    constructor : function() {
        this.callParent(arguments);

        if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
            throw 'The model for the ResourceStore must subclass Sch.model.Resource';
        }
    }
});

/**
 * @class Sch.data.ResourceTreeStore
 * @mixin Sch.data.mixin.FilterableTreeStore
 *
 * This is a class holding all the resources to be rendered into a {@link Sch.panel.SchedulerTree}. It is a subclass of "Ext.data.TreeStore" - a store containing hierarchical data.
 *
 * Filtering capabilities are provided by {@link Sch.data.mixin.FilterableTreeStore}, please refer to its documentation for additional information.
 */
if (!Ext.ClassManager.get("Sch.data.ResourceTreeStore")) Ext.define("Sch.data.ResourceTreeStore", {
    extend      : 'Ext.data.TreeStore',

    requires    : [
        'Sch.patches.TreeStore',
        'Sch.patches.TreeStoreInternalIdMap'
    ],

    mixins      : [
        'Sch.patches.NodeStore',
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper',
        'Sch.data.mixin.ResourceStore',
        'Sch.data.mixin.FilterableTreeStore'
    ],

    alias       : 'store.resourcetreestore',
    model       : 'Sch.model.Resource',
    storeId     : 'resources',
    proxy       : 'memory',

    constructor : function () {
        this.callParent(arguments);

        this.initTreeFiltering();

        if (this.getModel() !== Sch.model.Resource && !(this.getModel().prototype instanceof Sch.model.Resource)) {
            throw 'The model for the ResourceTreeStore must subclass Sch.model.Resource';
        }
    },

    setRootNode : function () {
        // this flag will prevent the "autoTimeSpan" feature from reacting on individual "append" events, which happens a lot
        // before the "rootchange" event
        this.isSettingRoot      = true;

        var res                 = this.callParent(arguments);

        this.isSettingRoot      = false;

        return res;
    }
});

/**
 * @class Sch.data.AssignmentStore
 * @extends Ext.data.Store
 *
 * A class representing a collection of assignments between events in the {@link Sch.data.EventStore} and resources
 * in the {@link Sch.data.ResourceStore}.
 *
 * Contains a collection of {@link Sch.model.Assignment} records.
 */
if (!Ext.ClassManager.get("Sch.data.AssignmentStore")) Ext.define('Sch.data.AssignmentStore', {
    extend      : 'Ext.data.Store',

    mixins : [
        'Sch.data.mixin.UniversalModelGetter',
        'Sch.data.mixin.CacheHintHelper'
    ],

    requires    : [
        'Sch.model.Assignment',
        'Sch.model.Range',
        'Sch.model.Resource',
        'Sch.data.util.EventAssignmentsCache',
        'Sch.data.util.ResourceAssignmentsCache',
        'Sch.data.util.AssignmentStoreEventResourcesCache',
        'Sch.data.util.AssignmentStoreResourceEventsCache'
    ],

    model       : 'Sch.model.Assignment',
    alias       : 'store.assignmentstore',
    storeId     : 'assignments',
    proxy       : 'memory',

    eventResourceCache    : null,
    resourceEventsCache   : null,

    eventStoreDetacher    : null,
    resourceStoreDetacher : null,

    /**
     * @property {Sch.data.EventStore} eventStore The event store to which this assignment store is associated.
     * Usually it is configured automatically, by the event store itself.
     *
     * @readonly
     */
    eventStore   : null,

    constructor : function(config) {
        var me = this;

        me.callParent([config]);

        me.eventAssignmentsCache    = me.eventAssignmentsCache    || new Sch.data.util.EventAssignmentsCache(me);
        me.resourceAssignmentsCache = me.resourceAssignmentsCache || new Sch.data.util.ResourceAssignmentsCache(me);
        // The caches commented are conflicting with the fact that assignments might be added to assignment store
        // before corresponding events/records are. For example SchedulerDragZone::updateRecords() does that
        // as soon as it's fixed this might be uncommented thus we might gain more performace at
        // event::getResources()/resource::getEvents() and corresponding methods
        //me.eventResourceCache       = me.eventResourceCache       || new Sch.data.util.AssignmentStoreEventResourcesCache(me);
        //me.resourceEventsCache      = me.resourceEventsCache      || new Sch.data.util.AssignmentStoreResourceEventsCache(me);
    },

    destroy : function() {
        var me = this;
        Ext.destroyMembers(
            me,
            'eventResourceCache',
            'resourceEventsCache',
            'eventAssignmentsCache',
            'resourceEventsCache',
            'eventStoreDetacher',
            'resourceStoreDetacher'
        );
        me.callParent();
    },

    /**
     * Returns the associated event store instance.
     *
     * @return {Gnt.data.EventStore}
     */
    getEventStore: function() {
        return this.eventStore;
    },

    /**
     * Sets the associated event store instance.
     *
     * @param {Sch.data.EventStore} eventStore
     */
    setEventStore: function(eventStore) {
        var me = this,
            oldStore = me.eventStore;

        if (me.eventStore) {
        }

        me.eventStore = eventStore && Ext.StoreMgr.lookup(eventStore) || null;

        if (me.eventStore) {
        }

        me.attachToEventStore(me.eventStore);

        if ((oldStore || eventStore) && oldStore !== eventStore) {
            /**
             * @event eventstorechange
             * Fires when new event store is set via {@link #setEventStore} method.
             * @param {Sch.data.AssignmentStore} this
             * @param {Sch.data.EventStore|null} newEventStore
             * @param {Sch.data.EventStore|null} oldEventStore
             */
            me.fireEvent('eventstorechange', me, eventStore, oldStore);
        }
    },

    attachToEventStore : function(eventStore) {
        var me = this;

        Ext.destroy(me.eventStoreDetacher);

        if (eventStore && eventStore instanceof Ext.data.TreeStore) {
            me.eventStoreDetacher = eventStore.on({
                'noderemove'          : me.onEventNodeRemove,
                'resourcestorechange' : me.onEventStoreResourceStoreChange,
                scope       : me,
                destroyable : true,
                priority    : 200 // higher then in cache
            });
        }
        else if (eventStore) {
            me.eventStoreDetacher = eventStore.on({
                'remove'              : me.onEventRemove,
                'resourcestorechange' : me.onEventStoreResourceStoreChange,
                scope       : me,
                destroyable : true,
                priority    : 200 // higher then in cache
            });
        }

        me.attachToResourceStore(eventStore && eventStore.getResourceStore());
    },

    attachToResourceStore : function(resourceStore) {
        var me = this;

        Ext.destroy(me.resourceStoreDetacher);

        if (resourceStore && resourceStore instanceof Ext.data.TreeStore) {
            me.resourceStoreDetacher = resourceStore.on({
                'noderemove' : me.onResourceNodeRemove,
                scope        : me,
                destroyable  : true,
                priority     : 200 // higher then in cache
            });
        }
        else if (resourceStore) {
            me.resourceStoreDetacher = resourceStore.on({
                'remove'    : me.onResourceRemove,
                scope       : me,
                destroyable : true,
                priority    : 200 // higher then in cache
            });
        }
    },

    onEventStoreResourceStoreChange : function(eventStore, newResourceStore, oldResourceStore) {
        this.attachToResourceStore(newResourceStore);
    },

    onEventRemove : function(eventStore, events, index, isMove) {
        var me = this,
            assignments;

        if (!isMove) {
            assignments = [];

            Ext.Array.forEach(events, function(event) {
                assignments = assignments.concat(me.getAssignmentsForEvent(event));
            });

            assignments.length && me.remove(assignments);
        }
    },

    onEventNodeRemove : function(eventStore, event, isMove) {
        var me = this,
            assignments;

        if (!isMove) {
            assignments = [];

            event.cascadeBy(function(cascadingEvent) {
                assignments = assignments.concat(me.getAssignmentsForEvent(cascadingEvent));
            });

            assignments.length && me.remove(assignments);
        }
    },

    onResourceRemove : function(resourceStore, resources, index, isMove) {
        var me = this,
            assignments;

        if (!isMove) {
            assignments = [];

            Ext.Array.forEach(resources, function(resource) {
                assignments = assignments.concat(me.getAssignmentsForResource(resource));
            });

            assignments.length && me.remove(assignments);
        }
    },

    onResourceNodeRemove : function(resourceStore, resource, isMove) {
        var me = this,
            assignments;

        if (!isMove) {
            assignments = [];

            resource.cascadeBy(function(cascadingResource) {
                assignments = assignments.concat(me.getAssignmentsForResource(cascadingResource));
            });

            assignments.length && me.remove(assignments);
        }
    },

    /**
     * Maps over event assignments.
     *
     * @param {Sch.model.Range|Mixed} event
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {[Mixed]}
     */
    mapAssignmentsForEvent : function(event, fn, filterFn) {
        var me = this,
            result = [];

        fn       = fn || Ext.identityFn;
        filterFn = filterFn || Ext.returnTrue;


        if (fn !== Ext.identityFn || filterFn !== Ext.returnTrue) {
            Ext.Array.forEach(me.eventAssignmentsCache.get(event), function(assignment) {
                var mapResult = fn(assignment);
                filterFn(mapResult) && result.push(mapResult);
            });
        }
        else {
            result = [].concat(me.eventAssignmentsCache.get(event));
        }

        return result;
    },

    /**
     * Maps over resource assignments.
     *
     * @param {Sch.model.Resource|Mixed} resource
     * @param {Function} [fn=Ext.identityFn]
     * @param {Function} [filterFn=Ext.returnTrue]
     * @return {[Mixed]}
     */
    mapAssignmentsForResource : function(resource, fn, filterFn) {
        var me = this,
            result = [];

        fn       = fn || Ext.identityFn;
        filterFn = filterFn || Ext.returnTrue;

        if (fn !== Ext.identityFn || filterFn !== Ext.returnTrue) {
            Ext.Array.forEach(me.resourceAssignmentsCache.get(resource), function(assignment) {
                var mapResult = fn(assignment);
                filterFn(mapResult) && result.push(mapResult);
            });
        }
        else {
            result = [].concat(me.resourceAssignmentsCache.get(resource));
        }

        return result;
    },

    /**
     * Returns all assignments for a given event.
     *
     * @param {Sch.model.Range|Mixed} event
     * @return {[Sch.model.Assignment]}
     */
    getAssignmentsForEvent : function(event) {
        return this.mapAssignmentsForEvent(event);
    },

    /**
     * Removes all assignments for given event
     *
     * @param {Sch.model.Range|Mixed} event
     */
    removeAssignmentsForEvent : function(event) {
        var me = this;
        me.remove(me.getAssignmentsForEvent(event));
    },

    /**
     * Returns all assignments for a given resource.
     *
     * @param {Sch.model.Resource|Mixed} event
     * @return {[Sch.model.Range]}
     */
    getAssignmentsForResource : function(resource) {
        return this.mapAssignmentsForResource(resource);
    },

    /**
     * Removes all assignments for given resource
     *
     * @param {Sch.model.Resource|Mixed} resource
     */
    removeAssignmentsForResource : function(resource) {
        var me = this;
        me.remove(me.getAssignmentsForResource(resource));
    },

    /**
     * Returns all resources assigned to an event.
     *
     * @param {Sch.model.Range|Mixed} event
     * @return {[Sch.model.Resource]}
     */
    getResourcesForEvent : function(event) {
        var me = this,
            result;

        if (me.eventResourceCache) {
            result = me.eventResourceCache.get(event);
        }
        else {
            result = me.mapAssignmentsForEvent(
                event,
                function mapper(assignment) {
                    return assignment.getResource();
                },
                function filter(resource) {
                    return !!resource;
                }
            );
        }

        return result;
    },

    /**
     * Returns all events assigned to a resource
     *
     * @param {Sch.model.Resource|Mixed} resource
     * @return {[Sch.model.Range]}
     */
    getEventsForResource : function(resource) {
        var me = this,
            result;

        if (me.resourceEventsCache) {
            result = me.resourceEventsCache.get(resource);
        }
        else {
            result = me.mapAssignmentsForResource(
                resource,
                function mapper(assignment) {
                    return assignment.getEvent();
                },
                function filter(event) {
                    return !!event;
                }
            );
        }

        return result;
    },

    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Sch.model.Range|Mixed} event
     * @param {Sch.model.Resource|Mixed|Array} resource The resource(s) to assign to the event
     * @privateparam {Function} [assignmentSetupFn=Ext.identityFn]
     * @return {[Sch.model.Assignment]} An array with the created assignment(s)
     */
    assignEventToResource : function(event, resource, assignmentSetupFn) {
        var me = this,
            assignments = [];

        assignmentSetupFn = assignmentSetupFn || Ext.identityFn;

        var resources = Ext.isArray(resource) ? resource : [resource];

        Ext.Array.forEach(resources, function(resource) {
            if (!me.isEventAssignedToResource(event, resource)) {
                var assignment = new me.model();
                assignment.setEventId(event instanceof Ext.data.Model && event.getId() || event);
                assignment.setResourceId(resource instanceof Ext.data.Model && resource.getId() || resource);
                assignment = assignmentSetupFn(assignment);

                assignments.push(assignment);
            }
        });

        me.add(assignments);

        return assignments;
    },

    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Sch.model.Range|Mixed} event
     * @param {Sch.model.Resource|Mixed} [resource] The resource to unassign the event from. If omitted, all resources of the events will be unassigned
     * @return {Sch.model.Assignment}
     */
    unassignEventFromResource : function(event, resource) {
        var me = this,
            assignment;

        if (!resource) {
            this.removeAssignmentsForEvent(event);
        } else if (me.isEventAssignedToResource(event, resource)) {
            assignment = me.getAssignmentForEventAndResource(event, resource);
            me.remove(assignment);
        }

        return assignment;
    },

    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Sch.model.Range|Mixed} event
     * @param {Sch.model.Resource|Mixed} resource
     * @return {Boolean}
     */
    isEventAssignedToResource : function(event, resource) {
        var me = this,
            records = me.getResourcesForEvent(event),
            result = false,
            i, len;

        resource = resource instanceof Ext.data.Model && resource.getId() || resource;

        for (i = 0, len = records.length; !result && i < len; i++) {
            result = records[i];
            result = result.getId() == resource;
        }

        return result;
    },

    /**
     * Returns assignment record for given event and resource
     *
     * @param {Sch.model.Range} event
     * @param {Sch.model.Resource} resource
     * @return {Sch.model.Assignment|null}
     */
    getAssignmentForEventAndResource : function(event, resource) {
        var me = this,
            records = me.getAssignmentsForEvent(event),
            result = null,
            i, len;

        resource = resource instanceof Ext.data.Model && resource.getId() || resource;

        for (i = 0, len = records.length; !result && i < len; i++) {
            result = records[i];
            result = result.getResourceId() == resource && result || null;
        }

        return result;
    }
});

/**
@class Sch.data.TimeAxis
@extends Ext.data.JsonStore

A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this class.
This is a pure "data" (model) representation of the time axis and has no UI elements.

The time axis can be {@link #continuous} or not. In continuos mode, each timespan starts where the previous ended, and in non-continuous mode
 there can be gaps between the ticks.
A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time axis.

To create a non-continuos time axis you have 2 options. First, you can create a time axis containing only the time spans of interest.
To do that, subclass this class and override the {@link #generateTicks} method. See the `noncontinuous-timeaxis` example in the Ext Scheduler SDK for guidance.

The other alternative is to call the {@link #filterBy} method, passing a function to it which should return `false` if the time tick should be filtered out.
Calling the {@link #clearFilter} method will return you to full time axis.

*/
Ext.define("Sch.data.TimeAxis", {
    extend      : "Ext.data.JsonStore",

    requires    : [
        'Sch.util.Date',
        // this "require" is needed for Sencha Touch
        'Sch.model.TimeAxisTick'
    ],

    model               : 'Sch.model.TimeAxisTick',

    /**
    * @cfg {Boolean} continuous
    * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).
    */
    continuous          : true,

    originalContinuous  : null,

    /**
    * @cfg {Boolean} autoAdjust
    * Automatically adjust the timespan when generating ticks with {@link #generateTicks} according to the `viewPreset` configuration. Setting this to false
    * may lead to shifting time/date of ticks.
    */
    autoAdjust          : true,

    unit                : null,
    increment           : null,
    resolutionUnit      : null,
    resolutionIncrement : null,

    weekStartDay        : null,

    mainUnit            : null,
    shiftUnit           : null,

    shiftIncrement      : 1,
    defaultSpan         : 1,

    isConfigured        : false,

    // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick
    // these dates will contain adjusted start/end (like if the tick has not been truncated)
    adjustedStart       : null,
    adjustedEnd         : null,
    // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`
    visibleTickStart    : null,
    // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count
    visibleTickEnd      : null,

    // name of the current preset
    presetName          : null,

    /**
     * @cfg {String} mode This option determines how timeaxis should be rounded.
     * When we round timeAxis for calendar we want to get minimum number of weeks that comprises desired month.
     * Options: ['plain', 'calendar']
     */
    mode                : 'plain',

    /**
     * @cfg {Number} startTime Start time for calendar mode, used only with day/week presets.
     */
    startTime           : 0,
    
    /**
     * @cfg {Number} endTime End time for calendar mode, used only with day/week presets.
     */
    endTime             : 24,

    /**
     * @event beforereconfigure
     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return false to abort the operation.
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     * @param {Date} startDate The new time axis start date
     * @param {Date} endDate The new time axis end date
     */

    /**
     * @event endreconfigure
     * @private
     * Event that is triggered when we end reconfiguring and everything ui-related should be done
     */

    /**
     * @event reconfigure
     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)
     * @param {Sch.data.TimeAxis} timeAxis The time axis instance
     */

    // private
    constructor : function(config) {
        var me = this;

        config = config || {};

        // For Sencha Touch, config system
        if (me.setModel) {
            me.setModel(me.model);
        }

        me.setMode(config.mode || me.mode);

        me.originalContinuous = me.continuous;

        me.callParent(arguments);

        me.on(Ext.versions.touch ? 'refresh' : 'datachanged', function(ta) {
            me.fireEvent('reconfigure', me, false);
        });

        me.on('endreconfigure', function(me, suppressRefresh) {
            me.fireEvent('reconfigure', me, suppressRefresh);
        });

        if (config.viewPreset) {
            var preset      = Sch.preset.Manager.getPreset(config.viewPreset);
            preset && me.consumeViewPreset(preset);
        }

        // not sure what me.start is but just in case I'm leaving previous condition
        if (config.start || me.start) {
            me.reconfigure(config);
        }
    },

    /**
    * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.
    * @param {Object} config
    * @private
    */
    reconfigure : function (config, suppressRefresh) {
        this.isConfigured   = true;

        Ext.apply(this, config);

        var adjusted        = this.getAdjustedDates(config.start, config.end, true);
        var normalized      = this.getAdjustedDates(config.start, config.end);

        var start           = normalized.start;
        var end             = normalized.end;

        if (this.fireEvent('beforereconfigure', this, start, end) !== false) {

            this.fireEvent('beginreconfigure', this);

            var unit                = this.unit;
            var increment           = this.increment || 1;
            var ticks               = this.generateTicks(start, end, unit, increment, this.mainUnit);

            // Suspending to be able to detect an invalid filter
            this.removeAll(true);
            this.suspendEvents();
            this.add(ticks);

            if (this.getCount() === 0) {
                Ext.Error.raise('Invalid time axis configuration or filter, please check your input data.');
            }
            this.resumeEvents();

            var DATE                = Sch.util.Date;
            var count               = ticks.length;

            if (this.isContinuous()) {
                this.adjustedStart      = adjusted.start;
                this.adjustedEnd        = this.getNext(count > 1 ? ticks[ count - 1 ].start : adjusted.start, unit, increment);
            } else {
                this.adjustedStart      = this.getStart();
                this.adjustedEnd        = this.getEnd();
            }

            // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to
            // drop it and adjust "adjustedStart" accordingly
            do {
                // TODO this has to use more sophisticated formula to take into account that months for example can be expressed in ms consistenly
                this.visibleTickStart   = (this.getStart() - this.adjustedStart) / (DATE.getUnitDurationInMs(unit) * increment);

                if (this.visibleTickStart >= 1) this.adjustedStart = DATE.getNext(this.adjustedStart, unit, increment);
            } while (this.visibleTickStart >= 1);

            do {
                this.visibleTickEnd     = count - (this.adjustedEnd - this.getEnd()) / (DATE.getUnitDurationInMs(unit) * increment);

                if (count - this.visibleTickEnd >= 1) this.adjustedEnd = DATE.getNext(this.adjustedEnd, unit, -1);
            } while (count - this.visibleTickEnd >= 1);

            this.fireEvent('endreconfigure', this, suppressRefresh);
        }
    },

    setMode : function (mode) {
        this.mode = mode;
        
        if (mode === 'calendar') {
            this.generateTicksValidatorFn = function (start) { 
                if (this.startTime > 0 || this.endTime < 24) {
                    return (start.getHours() >= this.startTime && start.getHours() < this.endTime);
                } else {
                    return true;
                }
            };
        } else {
            this.generateTicksValidatorFn = function () { return true; };
        }
    },

    /**
    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end The new end date
    */
    setTimeSpan : function (start, end) {
        var adjusted    = this.getAdjustedDates(start, end);

        start           = adjusted.start;
        end             = adjusted.end;

        if (this.getStart() - start !== 0 || this.getEnd() - end !== 0) {
            this.reconfigure({
                start   : start,
                end     : end
            });
        }
    },

    /**
     * [Experimental] Filter the time axis by a function. The passed function will be called with each tick in time axis.
     * If the function returns true, the 'tick' is included otherwise it is filtered.
     * @param {Function} fn The function to be called, it will receive an object with start/end properties, and 'index' of the tick.
     * @param {Object} scope (optional) The scope (`this` reference) in which the function is executed.
     */
    filterBy : function(fn, scope) {
        this.continuous = false;
        scope = scope || this;

        this.clearFilter(true);
        // Suspending to be able to detect an invalid filter
        this.suspendEvents(true);
        this.filter([{
            filterFn : function(t, index) {
                return fn.call(scope, t.data, index);
            }
        }]);

        if (this.getCount() === 0) {
            this.clearFilter();
            this.resumeEvents();
            Ext.Error.raise('Invalid time axis filter - no ticks passed through the filter. Please check your filter method.');
        }
        this.resumeEvents();
    },

    /**
     * Returns `true` if the time axis is continuos (will return `false` when filtered)
     * @return {Boolean}
     */
    isContinuous : function() {
        return this.continuous && !this.isFiltered();
    },

    /**
     * Clear the current filter of the time axis
     */
    clearFilter : function() {
        this.continuous = this.originalContinuous;
        this.callParent(arguments);
    },

    /**
     * Method generating the ticks for this time axis. Should return an array of ticks. Each tick is an object of the following structure:
        {
            start       : ..., // start date
            end         : ...  // end date
        }
     *
     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.
     *
     * @param {Date} startDate The start date of the interval
     * @param {Date} endDate The end date of the interval
     * @param {String} unit The unit of the time axis
     * @param {Mixed} increment The increment for the unit specified.
     * @return {Array} ticks The ticks representing the time axis
     */
    generateTicks : function (start, end, unit, increment) {
        var ticks           = [],
            intervalEnd,
            DATE            = Sch.util.Date,
            dstDiff         = 0;

        unit                = unit || this.unit;
        increment           = increment || this.increment;

        var adjusted        = this.getAdjustedDates(start, end);

        start               = adjusted.start;
        end                 = adjusted.end;

        while (start < end) {
            intervalEnd     = this.getNext(start, unit, increment);

            if (!this.autoAdjust && intervalEnd > end) intervalEnd = end;

            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct
            // Only do this for HOUR resolution currently, and only handle it once per tick generation.
            if (unit === DATE.HOUR && increment > 1 && ticks.length > 0 && dstDiff === 0) {
                var prev    = ticks[ ticks.length - 1 ];

                dstDiff     = ((prev.start.getHours() + increment) % 24) - prev.end.getHours();

                if (dstDiff !== 0) {
                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis "symmetric".
                    intervalEnd = DATE.add(intervalEnd, DATE.HOUR, dstDiff);
                }
            }

            this.generateTicksValidatorFn(start) && ticks.push({
                start   : start,
                end     : intervalEnd
            });
            
            start           = intervalEnd;
        }

        return ticks;
    },


    getVisibleTickTimeSpan : function () {
        return this.isContinuous() ? this.visibleTickEnd - this.visibleTickStart : this.getCount();
    },


    getAdjustedDates : function (start, end, forceAdjust) {
        var DATE    = Sch.util.Date;
        start       = start || this.getStart();
        end         = end || DATE.add(start, this.mainUnit, this.defaultSpan);

        if (this.mode === 'calendar') {
            // 'month' is tricky so we have to handle it separately
            if (this.shiftUnit === DATE.MONTH) {
                var startWeekEnd = DATE.add(start, DATE.WEEK, 1);
                var endWeekStart = DATE.add(end, DATE.WEEK, -1);
                // when this method is called from 'switchViewPreset' end date isn't provided, so we should just create one
                if (!end) {
                    end = this.getNext(start, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.shiftUnit, 1);
                    end = this.ceilDate(end, false, this.mainUnit, 1);
                }
                if (startWeekEnd.getMonth() !== start.getMonth() && endWeekStart.getMonth() !== end.getMonth()) {
                    return {
                        start   : start,
                        end     : end
                    };
                }
            }

            // This code sets time span to 1 viewPreset's shiftUnit from the time axis start date
            var adjustedStart   = this.floorDate(start, false, this.shiftUnit, 1);
            adjustedStart       = this.floorDate(adjustedStart, false, this.mainUnit, 1);

            var clone           = this.getNext(start, this.shiftUnit, 1);
            var adjustedEnd     = this.ceilDate(clone, false, this.shiftUnit, 1);
            adjustedEnd         = this.ceilDate(adjustedEnd, false, this.mainUnit, 1);

            return {
                start   : adjustedStart,
                end     : adjustedEnd
            };
        } else {
            return this.autoAdjust || forceAdjust ? {
                start   : this.floorDate(start, false, this.autoAdjust ? this.mainUnit : this.unit, 1),
                end     : this.ceilDate(end, false, this.autoAdjust ? this.mainUnit : this.unit, 1)
            } : {
                start   : start,
                end     : end
            };
        }
    },

    /**
     * Gets a tick "coordinate" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.
     * @param {Date} date the date
     * @return {Number} the tick position on the scale or -1 if the date is not part of the time axis
     */
    getTickFromDate : function (date) {
        var ticks           = this.data.items;
        var lastTickIndex   = ticks.length - 1;

        // quick bailout
        if (date < ticks[ 0 ].data.start || date > ticks[ lastTickIndex ].data.end) {
            return -1;
        }

        var tick, tickStart, tickEnd;

        if (this.isContinuous()) {
            if (date - ticks[ 0 ].data.start === 0) return this.visibleTickStart;
            if (date - ticks[ lastTickIndex ].data.end === 0) return this.visibleTickEnd;

            var adjustedStart   = this.adjustedStart;
            var adjustedEnd     = this.adjustedEnd;

            var tickIndex       = Math.floor(ticks.length * (date - adjustedStart) / (adjustedEnd - adjustedStart));

            // for the date == adjustedEnd case
            if (tickIndex > lastTickIndex) tickIndex = lastTickIndex;

            tickStart           = tickIndex === 0 ? adjustedStart : ticks[ tickIndex ].data.start;
            tickEnd             = tickIndex == lastTickIndex ? adjustedEnd : ticks[ tickIndex ].data.end;

            tick                = tickIndex + (date - tickStart) / (tickEnd - tickStart);

            // in case of `autoAdjust : false` the actual visible timespan starts not from 0 tick coordinate, but
            // from `visibleTickStart` coordinate, this check generally repeats the "quick bailout" check in the begining of the method,
            // but still
            if (tick < this.visibleTickStart || tick > this.visibleTickEnd) return -1;

            return tick;
        } else {
            for (var i = 0; i <= lastTickIndex; i++) {
                tickEnd         = ticks[ i ].data.end;

                if (date <= tickEnd) {
                    tickStart   = ticks[ i ].data.start;

                    // date < tickStart can occur in filtered case
                    tick        = i + (date > tickStart ? (date - tickStart) / (tickEnd - tickStart) : 0);

                    return tick;
                }
            }
        }

        return -1;
    },

    /**
    * Gets the time represented by a tick "coordinate".
    * @param {Number} tick the tick "coordinate"
    * @param {String} roundingMethod The rounding method to use
    * @return {Date} The date to represented by the tick "coordinate", or null if invalid.
    */
    getDateFromTick : function (tick, roundingMethod) {
        if (tick === this.visibleTickEnd) return this.getEnd();

        var wholeTick   = Math.floor(tick),
            fraction    = tick - wholeTick,
            t           = this.getAt(wholeTick);

        if (!t) return null;

        var tickData    = t.data;
        var start       = wholeTick === 0 ? this.adjustedStart : tickData.start;
        // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end
        var end         = (wholeTick == this.getCount() - 1) && this.isContinuous() ? this.adjustedEnd : tickData.end;

        var date        = Sch.util.Date.add(start, Sch.util.Date.MILLI, fraction * (end - start));

        if (roundingMethod) {
            date        = this[ roundingMethod + 'Date' ](date);
        }

        return date;
    },

    /**
    * Returns the ticks of the timeaxis in an array of objects with a "start" and "end" date.
    * @return {Object[]} the ticks on the scale
    */
    getTicks : function() {
        var ticks = [];

        this.each(function (r) { ticks.push(r.data); });
        return ticks;
    },

    /**
    * Method to get the current start date of the time axis
    * @return {Date} The start date
    */
    getStart : function() {
        var first = this.first();

        if (first) {
            return new Date(first.data.start);
        }
        return null;
    },

    /**
    * Method to get a the current end date of the time axis
    * @return {Date} The end date
    */
    getEnd : function() {
        var last = this.last();

        if (last) {
            return new Date(last.data.end);
        }
        return null;
    },

    // Floors a date and optionally snaps it to one of the following resolutions:
    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.
    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,
    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date
    //
    // returns a copy of the original date
    // private
    floorDate : function(date, relativeToStart, resolutionUnit, incr) {
        relativeToStart = relativeToStart !== false;

        var dt          = Ext.Date.clone(date),
            relativeTo  = relativeToStart ? this.getStart() : null,
            increment   = incr || this.resolutionIncrement,
            unit;

        if (resolutionUnit) {
            unit        = resolutionUnit;
        } else {
            unit        = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        var DATE        = Sch.util.Date;
        var snap        = function (value, increment) { return Math.floor(value / increment) * increment; };

        switch (unit) {
            case DATE.MILLI:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInMilliseconds(relativeTo, dt), increment));
                }
                break;

            case DATE.SECOND:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.MILLI, snap(DATE.getDurationInSeconds(relativeTo, dt), increment) * 1000);
                } else {
                    dt.setMilliseconds(0);
                    dt.setSeconds(snap(dt.getSeconds(), increment));
                }
                break;

            case DATE.MINUTE:
                if (relativeToStart) {
                    dt          = DATE.add(relativeTo, DATE.SECOND, snap(DATE.getDurationInMinutes(relativeTo, dt), increment) * 60);
                } else {
                    dt.setMinutes(snap(dt.getMinutes(), increment));
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                }
                break;

            case DATE.HOUR:
                if (relativeToStart) {
                    dt           = DATE.add(relativeTo, DATE.MINUTE, snap(DATE.getDurationInHours(this.getStart(), dt), increment) * 60);
                } else {
                    dt.setMinutes(0);
                    dt.setSeconds(0);
                    dt.setMilliseconds(0);
                    dt.setHours(snap(dt.getHours(), increment));
                }
                break;

            case DATE.DAY:
                if (relativeToStart) {
                    dt            = DATE.add(relativeTo, DATE.DAY, snap(DATE.getDurationInDays(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    // days are 1-based so need to make additional adjustments
                    dt.setDate(snap(dt.getDate() - 1, increment) + 1);
                }
                break;

            case DATE.WEEK:
                var day      = dt.getDay()       || 7;
                var startDay = this.weekStartDay || 7;
                Sch.util.Date.clearTime(dt);

                dt      = DATE.add(dt, DATE.DAY, day >= startDay ? startDay - day : -(7 - startDay + day));

                // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)
                if (dt.getDay() !== startDay && dt.getHours() === 23) {
                    dt = DATE.add(dt, DATE.HOUR, 1);
                }
                break;

            case DATE.MONTH:
                if (relativeToStart) {
                    dt      = DATE.add(relativeTo, DATE.MONTH, snap(DATE.getDurationInMonths(relativeTo, dt), increment));
                } else {
                    Sch.util.Date.clearTime(dt);
                    dt.setDate(1);
                    dt.setMonth(snap(dt.getMonth(), increment));
                }
                break;

            case DATE.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt                      = DATE.add(dt, DATE.MONTH, - (dt.getMonth() % 3));
                break;

            case DATE.YEAR:
                if (relativeToStart) {
                    dt                  = DATE.add(relativeTo, DATE.YEAR, snap(DATE.getDurationInYears(relativeTo, dt), increment));
                } else {
                    // years are 1-based so need to make additional adjustments
                    dt                  = new Date(snap(date.getFullYear() - 1, increment) + 1, 0, 1);
                }
                break;
        }

        return dt;
    },


    // Rounds the date to nearest unit increment
    // private
    roundDate : function(date, relativeTo) {
        var dt = Ext.Date.clone(date),
            increment = this.resolutionIncrement;

        relativeTo = relativeTo || this.getStart();

        switch(this.resolutionUnit) {
            case Sch.util.Date.MILLI:
                var milliseconds = Sch.util.Date.getDurationInMilliseconds(relativeTo, dt),
                    snappedMilliseconds = Math.round(milliseconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedMilliseconds);
                break;

            case Sch.util.Date.SECOND:
                var seconds = Sch.util.Date.getDurationInSeconds(relativeTo, dt),
                    snappedSeconds = Math.round(seconds / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MILLI, snappedSeconds * 1000);
                break;

            case Sch.util.Date.MINUTE:
                var minutes = Sch.util.Date.getDurationInMinutes(relativeTo, dt),
                    snappedMinutes = Math.round(minutes / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.SECOND, snappedMinutes * 60);
                break;

            case Sch.util.Date.HOUR:
                var nbrHours = Sch.util.Date.getDurationInHours(relativeTo, dt),
                    snappedHours = Math.round(nbrHours / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MINUTE, snappedHours * 60);
                break;

            case Sch.util.Date.DAY:
                var nbrDays = Sch.util.Date.getDurationInDays(relativeTo, dt),
                    snappedDays = Math.round(nbrDays / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.DAY, snappedDays);
                break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);

                var distanceToWeekStartDay = dt.getDay() - this.weekStartDay,
                    toAdd;

                if (distanceToWeekStartDay < 0) {
                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;
                }

                if (Math.round(distanceToWeekStartDay/7) === 1) {
                    toAdd = 7 - distanceToWeekStartDay;
                } else {
                    toAdd = -distanceToWeekStartDay;
                }

                dt = Sch.util.Date.add(dt, Sch.util.Date.DAY, toAdd);
                break;

            case Sch.util.Date.MONTH:
                var nbrMonths = Sch.util.Date.getDurationInMonths(relativeTo, dt) + (dt.getDate() / Ext.Date.getDaysInMonth(dt)),
                    snappedMonths = Math.round(nbrMonths / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.MONTH, snappedMonths);
                break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                dt.setDate(1);
                dt = Sch.util.Date.add(dt, Sch.util.Date.MONTH, 3 - (dt.getMonth() % 3));
                break;

            case Sch.util.Date.YEAR:
                var nbrYears = Sch.util.Date.getDurationInYears(relativeTo, dt),
                    snappedYears = Math.round(nbrYears / increment) * increment;
                dt = Sch.util.Date.add(relativeTo, Sch.util.Date.YEAR, snappedYears);
                break;
        }

        return dt;
    },

    // private
    ceilDate : function(date, relativeToStart, resolutionUnit) {
        var dt = Ext.Date.clone(date);
        relativeToStart = relativeToStart !== false;

        var increment = relativeToStart ? this.resolutionIncrement : 1,
            doCall = false,
            unit;

        if (resolutionUnit){
            unit = resolutionUnit;
        } else {
            unit = relativeToStart ? this.resolutionUnit : this.mainUnit;
        }

        switch (unit) {
            case Sch.util.Date.HOUR:
                if (dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.DAY:
                if (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.WEEK:
                Sch.util.Date.clearTime(dt);
                if (dt.getDay() !== this.weekStartDay || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.MONTH:
                Sch.util.Date.clearTime(dt);
                if (dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.QUARTER:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            case Sch.util.Date.YEAR:
                Sch.util.Date.clearTime(dt);
                if (dt.getMonth() !== 0 || dt.getDate() !== 1 || date.getTime() - dt.getTime() > 0) {
                    doCall = true;
                }
            break;

            default:
            break;
        }

        if (doCall) {
            return this.getNext(dt, unit, increment);
        } else {
            return dt;
        }
    },

    // private
    getNext : function(date, unit, increment) {
        return Sch.util.Date.getNext(date, unit, increment, this.weekStartDay);
    },

    // private
    getResolution : function() {
        return {
            unit : this.resolutionUnit,
            increment : this.resolutionIncrement
        };
    },

    // private
    setResolution : function(unit, increment) {
        this.resolutionUnit = unit;
        this.resolutionIncrement = increment || 1;
    },

    /**
     * Moves the time axis by the passed amount and unit.
     * @param {Number} amount The number of units to jump
     * @param {String} unit The unit (Day, Week etc)
     */
    shift: function (amount, unit) {
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
    * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`
    * config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function (amount) {
        amount      = amount || this.getShiftIncrement();
        var unit    = this.getShiftUnit();

        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    /**
    * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function (amount) {
        amount = -(amount || this.getShiftIncrement());
        var unit = this.getShiftUnit();
        this.setTimeSpan(Sch.util.Date.add(this.getStart(), unit, amount), Sch.util.Date.add(this.getEnd(), unit, amount));
    },

    getShiftUnit: function () {
        return this.shiftUnit || this.mainUnit;
    },

    // private
    getShiftIncrement: function () {
        return this.shiftIncrement || 1;
    },

    // private
    getUnit: function () {
        return this.unit;
    },

    // private
    getIncrement: function () {
        return this.increment;
    },
    
    // to keep rows and time axis in sync, we use this function to return ticks to generate rows.
    getRowTicks    : function () {
        if (this.mode === 'plain') {
            return;
        } else {
            var start = this.getStart();
            var end = Sch.util.Date.add(start, this.headerConfig.middle.splitUnit, 1);
            
            var endIndex = this.findBy(function (record) {
                return record.getStartDate().getTime() >= end.getTime();
            });
            
            // if no such record was found - we are dealing with day view
            if (endIndex === -1) {
                return this.getRange();
            }
            
            return this.getRange(0, endIndex - 1);
        }
    },

    /**
    * Returns true if the passed date is inside the span of the current time axis.
    * @param {Date} date The date to query for
    * @return {Boolean} true if the date is part of the timeaxis
    */
    dateInAxis: function(date) {
        return Sch.util.Date.betweenLesser(date, this.getStart(), this.getEnd());
    },

    /**
    * Returns true if the passed timespan is part of the current time axis (in whole or partially).
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @return {boolean} true if the timespan is part of the timeaxis
    */
    timeSpanInAxis: function(start, end) {
        if (this.isContinuous()) {
            return Sch.util.Date.intersectSpans(start, end, this.getStart(), this.getEnd());
        } else {
            return (start < this.getStart() && end > this.getEnd()) ||
                   this.getTickFromDate(start) !== this.getTickFromDate(end);
        }
    },

    // Accepts a Sch.model.Range model
    isRangeInAxis: function(range) {
        var start = range.getStartDate(),
            end = range.getEndDate();

        // only consider fully scheduled ranges
        if (!start || !end) return false;

        return this.timeSpanInAxis(start, end);
    },


    /**
     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.
     * @protected
     * @param {String} unit The unit to use when iterating over the timespan
     * @param {Number} increment The increment to use when iterating over the timespan
     * @param {Function} iteratorFn The function to call
     * @param {Object} scope (optional) The "this" object to use for the function call
     */
    forEachAuxInterval : function (unit, increment, iteratorFn, scope) {
        scope               = scope || this;

        var end             = this.getEnd(),
            dt              = this.getStart(),
            i               = 0,
            intervalEnd;

        if (dt > end) throw 'Invalid time axis configuration';

        while (dt < end) {
            intervalEnd     =  Sch.util.Date.min(this.getNext(dt, unit, increment || 1), end);
            iteratorFn.call(scope, dt, intervalEnd, i);
            dt              = intervalEnd;
            i++;
        }
    },


    consumeViewPreset : function (preset) {
        Ext.apply(this, {
            unit                : preset.getBottomHeader().unit,
            increment           : preset.getBottomHeader().increment || 1,

            resolutionUnit      : preset.timeResolution.unit,
            resolutionIncrement : preset.timeResolution.increment,

            mainUnit            : preset.getMainHeader().unit,
            shiftUnit           : preset.shiftUnit,
            shiftIncrement      : preset.shiftIncrement || 1,

            defaultSpan         : preset.defaultSpan || 1,
            presetName          : preset.name,

            // Calendar columns are updated upon 'datachanged' event on this object.
            // We have to pass headerConfig in order to render them correctly (timeAxisViewModel is incorrect in required time)
            headerConfig        : preset.headerConfig
        });
    }
});
/**
 * @class Sch.view.Horizontal
 * @private
 *
 * An internal view mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView}.
 * This class is consumed by the scheduling view and provides the horizontal implementation of certain methods.
 */
Ext.define("Sch.view.Horizontal", {
    requires : [
        'Ext.util.Region',
        'Ext.Element',
        'Sch.util.Date'
    ],
    // Provided by creator, in the config object
    view: null,

    constructor: function (config) {
        Ext.apply(this, config);
    },

    translateToScheduleCoordinate: function (x) {
        var view = this.view;

        if (view.rtl) {
            return view.getHorizontalTimeAxisColumn().getEl().getRight() - x;
        }
        return x - view.getEl().getX() + view.getScroll().left;
    },

    translateToPageCoordinate: function (x) {
        var view = this.view;
        return x + view.getEl().getX() - view.getScroll().left;
    },

    getDateFromXY   : function (xy, roundingMethod, local) {
        var coord   = xy[0];

        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },

    getEventRenderData: function (event) {
        var eventStart  = event.getStartDate(),
            eventEnd    = event.getEndDate() || eventStart, // Allow events to be rendered even they are missing an end date
            view        = this.view,
            viewStart   = view.timeAxis.getStart(),
            viewEnd     = view.timeAxis.getEnd(),
            M           = Math,
            startX      = view.getXFromDate(Sch.util.Date.max(eventStart, viewStart)),
            endX        = view.getXFromDate(Sch.util.Date.min(eventEnd, viewEnd)),
            data        = {};

        if (this.view.rtl) {
            data.right = M.min(startX, endX);
        } else {
            data.left = M.min(startX, endX);
        }

        data.width = M.max(1, M.abs(endX - startX)) - view.eventBorderWidth;

        if (view.managedEventSizing) {
            data.top = M.max(0, (view.barMargin - ((Ext.isIE && !Ext.isStrict) ? 0 : view.eventBorderWidth - view.cellTopBorderWidth)));
            data.height = view.timeAxisViewModel.rowHeightHorizontal - (2 * view.barMargin) - view.eventBorderWidth;
        }

        data.start              = eventStart;
        data.end                = eventEnd;
        data.startsOutsideView  = eventStart < viewStart;
        data.endsOutsideView    = eventEnd > viewEnd;
        return data;
    },

    /**
    * Gets the Ext.util.Region, relative to the page, represented by the schedule and optionally only for a single resource. This method will call getDateConstraints to
    * allow for additional resource/event based constraints. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record
    * @param {Sch.model.Event} eventRecord (optional) The event record
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function (resourceRecord, eventRecord) {
        var getRegionFn     = Ext.Element.prototype.getRegion ? 'getRegion' : 'getPageBox',
            view            = this.view,
            region          = resourceRecord ? Ext.fly(view.getRowNode(resourceRecord))[getRegionFn]() : view.getTableRegion(),
            taStart         = view.timeAxis.getStart(),
            taEnd           = view.timeAxis.getEnd(),
            dateConstraints = view.getDateConstraints(resourceRecord, eventRecord) || { start: taStart, end: taEnd },
            startX          = this.translateToPageCoordinate(view.getXFromDate(Sch.util.Date.max(taStart, dateConstraints.start))),
            endX            = this.translateToPageCoordinate(view.getXFromDate(Sch.util.Date.min(taEnd, dateConstraints.end))),
            top             = region.top + view.barMargin,
            bottom          = region.bottom - view.barMargin - view.eventBorderWidth;

        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },


    /**
    * Gets the Ext.util.Region, relative to the scheduling view element, representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function (resourceRecord, startDate, endDate) {
        var view        = this.view,
            rowNode     = view.getRowNode(resourceRecord),
            offsets     = Ext.fly(rowNode).getOffsetsTo(view.getEl()),
            taStart     = view.timeAxis.getStart(),
            taEnd       = view.timeAxis.getEnd(),
            start       = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end         = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startX      = view.getXFromDate(start),
            endX        = view.getXFromDate(end),
            top         = offsets[1] + view.cellTopBorderWidth,
            bottom      = offsets[1] + Ext.fly(rowNode).getHeight() - view.cellBottomBorderWidth;

        if (!Ext.versions.touch) {
            var ctElScroll  = view.getScroll();
            top += ctElScroll.top;
            bottom += ctElScroll.top;
        }
        return new Ext.util.Region(top, Math.max(startX, endX), bottom, Math.min(startX, endX));
    },


    columnRenderer: function (val, meta, resourceRecord, rowIndex, colIndex) {
        var view            = this.view;
        var resourceEvents  = view.eventStore.filterEventsForResource(resourceRecord, function(event) {
            return view.timeAxis.isRangeInAxis(event);
        });

        if (resourceEvents.length === 0) {
            return;
        }

        // Iterate events belonging to current row
        var eventsTplData = Ext.Array.map(resourceEvents, function(event) {
            return view.generateTplData(event, resourceRecord, rowIndex);
        });

        // Event data is now gathered, calculate layout properties for each event (if dynamicRowHeight is used)
        if (view.dynamicRowHeight) {
            var layout              = view.eventLayout.horizontal;
            var nbrOfBandsRequired = layout.applyLayout(eventsTplData, resourceRecord, this.layoutEventVertically, this);

            var rowHeight = (nbrOfBandsRequired * view.timeAxisViewModel.rowHeightHorizontal) - ((nbrOfBandsRequired - 1) * view.barMargin);
                            view.cellTopBorderWidth - view.cellBottomBorderWidth;

            meta.rowHeight      = rowHeight;
        }

        return view.eventTpl.apply(eventsTplData);
    },

    layoutEventVertically : function(bandIndex, eventRecord) {
        var view     = this.view;
        var eventTop = bandIndex === 0 ? view.barMargin : (bandIndex * view.timeAxisViewModel.rowHeightHorizontal - (bandIndex - 1) * view.barMargin);

        if (eventTop >= view.cellBottomBorderWidth) {
            eventTop -= view.cellBottomBorderWidth;
        }

        return eventTop;
    },

    // private
    resolveResource: function (node) {
        var me = this,
            view = me.view,
            eventNode,
            result;

        eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);

        if (eventNode) {
            // Fast case
            result = view.getResourceRecordFromDomId(eventNode.id);
        }
        else {
            // Not that fast case
            // I'm not sure if it's really needed, the method documentation doesn't state that node must be
            // within event node. If node might be outside of event node then yes, this branch is needed, otherwise
            // it is not.
            node = view.findRowByChild(node);
            result = node && view.getRecordForRowNode(node) || null;
        }

        return result;
    },

    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function (startDate, endDate, useViewSize) {
        var view    = this.view,
            startX  = view.getXFromDate(startDate),
            endX    = endDate ? view.getXFromDate(endDate) : startX,
            height, region;

        region = view.getTableRegion();

        if (useViewSize) {
            height = Math.max(region ? region.bottom - region.top: 0, view.getEl().dom.clientHeight); // fallback in case grid is not rendered (no rows/table)
        } else {
            height = region ? region.bottom - region.top: 0;
        }
        return new Ext.util.Region(0, Math.max(startX, endX), height, Math.min(startX, endX));
    },

    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function (region, roundingMethod, allowPartial) {
        var view        = this.view;
        var rtl         = view.rtl;

        var startDate   = view.getDateFromCoordinate(rtl ? region.right : region.left, roundingMethod),
            endDate     = view.getDateFromCoordinate(rtl ? region.left : region.right, roundingMethod);

        if (startDate && endDate || allowPartial && (startDate || endDate)) {
            return {
                start   : startDate,
                end     : endDate
            };
        }

        return null;
    },

    // private
    onEventAdd: function (s, events) {
        var view = this.view,
            affectedResources = {},
            event, startDate, endDate,
            resources, resource,
            i, l, j, k;

        for (i = 0, l = events.length; i < l; i++) {
            event       = events[i];
            startDate   = event.getStartDate();
            endDate     = event.getEndDate();

            if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
                // repaint row only if event is in time axis
                resources = events[i].getResources(view.eventStore);

                for (j = 0, k = resources.length; j < k; j++) {
                    resource = resources[j];

                    affectedResources[resource.getId()] = resource;
                }
            }
        }

        Ext.Object.each(affectedResources, function (id, resource) {
            view.repaintEventsForResource(resource);
        });
    },

    // private
    onEventRemove: function (s, eventRecords) {
        var me            = this,
            view          = me.view,
            resourceStore = me.resourceStore,
            eventStore    = view.eventStore,
            resources,
            nodes;

        resources = Ext.Array.unique(
                        Ext.Array.flatten(
                            Ext.Array.map(eventRecords, function(r) {
                                // It's important to use event store's method here, instead just
                                // r.getResources(). r.getResources() will always return empty array here
                                // since r is already removed from the event store.
                                return eventStore.getResourcesForEvent(r);
                            })
                        )
                    );

        function updateResource(resource) {
            view.store.indexOf(resource) >= 0 && view.repaintEventsForResource(resource);
        }

        // TODO:
        // I really don't know why this logic is important here
        // Why anyone need to distinguish between multiple resources case and single resource case here.
        // I've just left it as it were before.
        if (resources.length > 1) {
            Ext.Array.forEach(resources, updateResource);
        }
        else if (resources.length == 1) {
            nodes = Ext.Array.flatten(
                        Ext.Array.map(eventRecords, function(r) {
                            return view.getElementsFromEventRecord(r, null, null, true);
                        })
                    );
            nodes = new Ext.CompositeElementLite(nodes);

            nodes.fadeOut({
                callback: function() { updateResource(resources[0]); }
            });
        }
    },

    // private
    onEventUpdate: function (eventStore, model) {
        var previous = model.previous || {};
        var view = this.view;
        var timeAxis = view.timeAxis;

        var newStartDate  = model.getStartDate();
        var newEndDate    = model.getEndDate();

        var startDate       = previous.StartDate || newStartDate;
        var endDate         = previous.EndDate || newEndDate;

        // event was visible or visible now
        var eventWasInView  = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);

        var resource;

        // resource has to be repainted only if it was changed and event was rendered/is still rendered
        if (model.resourceIdField in previous && eventWasInView) {
            // If an event has been moved to a new row, refresh old row first
            resource = eventStore.getResourceStore().getById(previous[model.resourceIdField]);
            resource && view.repaintEventsForResource(resource, true);
        }

        // also resource has to be repainted if event was moved inside/outside of time axis
        if ((newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate)) || eventWasInView) {
            Ext.Array.forEach(model.getResources(), function(resource) {
                view.repaintEventsForResource(resource, true);
            });
        }
    },

    setColumnWidth: function (width, preventRefresh) {
        var view = this.view;

        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },

    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function () {
        var view = this.view;

        if (!view.getEl()) {
            return null;
        }

        var tableRegion = view.getTableRegion(),
            startDate   = view.timeAxis.getStart(),
            endDate     = view.timeAxis.getEnd(),
            width       = view.getWidth();

        if ((tableRegion.right - tableRegion.left) < width) {
            return { startDate: startDate, endDate: endDate };
        }

        var scroll      = view.getScroll();

        return {
            startDate   : view.getDateFromCoordinate(scroll.left, null, true),
            endDate     : view.getDateFromCoordinate(scroll.left + width, null, true)
        };
    }
});

/**
@class Sch.view.Vertical

A mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView} and providing the implementation of some methods, specific to vertical mode.

*/
Ext.define("Sch.view.Vertical", {

    // Provided by creator, in the config object
    view : null,

    constructor : function(config) {
        Ext.apply(this, config);
    },

    translateToScheduleCoordinate: function (y) {
        var view = this.view;
        return y - view.getEl().getY() + view.getScroll().top;
    },

    // private
    translateToPageCoordinate: function (y) {
        var view = this.view;
        var el = view.getEl(),
            scroll = el.getScroll();

        return y + el.getY() - scroll.top;
    },

    getDateFromXY   : function (xy, roundingMethod, local) {
        var coord   = xy[1];

        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },

    getEventRenderData : function(event, resource, columnIndex) {
        var eventStart  = event.getStartDate(),
            eventEnd    = event.getEndDate(),
            view        = this.view,
            viewStart   = view.timeAxis.getStart(),
            viewEnd     = view.timeAxis.getEnd(),
            M           = Math,
            startY      = M.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart))),
            endY        = M.floor(view.getCoordinateFromDate(Sch.util.Date.min(eventEnd, viewEnd))),
            colWidth    = this.getResourceColumnWidth(resource),
            data;

        data = {
            top     : M.max(0, M.min(startY, endY) - view.eventBorderWidth),
            height  : M.max(1, M.abs(startY - endY))
        };

        if (view.managedEventSizing) {
            data.left = view.barMargin;
            data.width = colWidth - (2*view.barMargin) - view.eventBorderWidth;
        }

        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;

        return data;
    },

    getScheduleRegion: function (resourceRecord, eventRecord) {
        var view        = this.view,
            region      = resourceRecord ? Ext.fly(view.getScheduleCell(0, view.resourceStore.indexOf(resourceRecord))).getRegion() : view.getTableRegion(),

            taStart     = view.timeAxis.getStart(),
            taEnd       = view.timeAxis.getEnd(),

            dateConstraints     = view.getDateConstraints(resourceRecord, eventRecord) || { start: taStart, end: taEnd },

            startY      = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.max(taStart, dateConstraints.start))),
            endY        = this.translateToPageCoordinate(view.getCoordinateFromDate(Sch.util.Date.min(taEnd, dateConstraints.end))),

            left        = region.left + view.barMargin,
            right       = (resourceRecord ? (region.left + this.getResourceColumnWidth(resourceRecord)) : region.right) - view.barMargin;

        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },

    getResourceColumnWidth : function(resource) {
        return this.view.timeAxisViewModel.resourceColumnWidth;
    },

    /**
    * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function (resourceRecord, startDate, endDate) {
        var view            = this.view,
            cellLeft        = view.resourceStore.indexOf(resourceRecord) * this.getResourceColumnWidth(resourceRecord),
            taStart         = view.timeAxis.getStart(),
            taEnd           = view.timeAxis.getEnd(),
            start           = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end             = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startY          = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth),
            endY            = view.getCoordinateFromDate(end) - view.cellTopBorderWidth,
            left            = cellLeft + view.cellBorderWidth,
            right           = cellLeft + this.getResourceColumnWidth(resourceRecord) - view.cellBorderWidth;

        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },

    columnRenderer: function (val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view;
        var retVal = '';

        if (rowIndex === 0) {
            var D               = Sch.util.Date,
                ta              = view.timeAxis,
                columnEvents,
                resourceEvents,
                i, l;

            columnEvents = [];
            resourceEvents = view.eventStore.getEventsForResource(resourceRecord);

            // Iterate events (belonging to current resource)
            for (i = 0, l = resourceEvents.length; i < l; i++) {
                var event   = resourceEvents[i],
                    start   = event.getStartDate(),
                    end     = event.getEndDate();

                // Determine if the event should be rendered or not
                if (start && end && ta.timeSpanInAxis(start, end)) {
                    columnEvents.push(view.generateTplData(event, resourceRecord, colIndex));
                }
            }
            view.eventLayout.vertical.applyLayout(columnEvents, this.getResourceColumnWidth(resourceRecord));
            retVal = '&#160;' + view.eventTpl.apply(columnEvents);
        }

        if (colIndex % 2 === 1) {
            meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
            meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
        }

        return retVal;
    },

    // private
    resolveResource: function(node) {
        var me     = this,
            view   = me.view,
            eventNode,
            index,
            result;

        eventNode = Ext.fly(node).is(view.eventSelector) && node || Ext.fly(node).up(view.eventSelector, null, true);

        if (eventNode) {
            // Fast case
            result = view.getResourceRecordFromDomId(eventNode.id);
        }
        else {
            // Not that fast case
            // I'm not sure if it's really needed, the method documentation doesn't state that node must be
            // within event node. If node might be outside of event node then yes, this branch is needed, otherwise
            // it is not.
            node = Ext.fly(node).is(view.timeCellSelector) ? node : Ext.fly(node).up(view.timeCellSelector, null, true);
            index = -1;

            if (node && Ext.isIE8m) {
                node = node.previousSibling;
                while (node) {
                    if (node.nodeType === 1 ) {
                        index++;
                    }
                    node = node.previousSibling;
                }
            }
            else if (node) {
                index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
            }

            result = index >= 0 && view.resourceStore.getAt(index) || null;
        }

        return result;
    },

    // private
    onEventUpdate: function (store, event) {
        var me = this;
        var previous = event.previous || {};
        var view = me.view;
        var timeAxis = view.timeAxis;

        var newStartDate  = event.getStartDate();
        var newEndDate    = event.getEndDate();

        var startDate       = previous.StartDate || newStartDate;
        var endDate         = previous.EndDate || newEndDate;

        // event was visible or visible now
        var eventWasInView  = startDate && endDate && timeAxis.timeSpanInAxis(startDate, endDate);

        var resource;

        // resource has to be repainted only if it was changed and event was rendered/is still rendered
        if (event.resourceIdField in previous && eventWasInView) {
            // If an event has been moved to a new resource, refresh old resource first
            resource = store.getResourceStore().getById(previous[event.resourceIdField]);
            resource && me.relayoutRenderedEvents(resource);
        }

        // also resource has to be repanted if event was moved inside/outside of time axis
        if ((newStartDate && newEndDate && timeAxis.timeSpanInAxis(newStartDate, newEndDate)) || eventWasInView) {
            me.renderSingle(event);
            Ext.Array.forEach(event.getResources(), function(resource) {
                me.relayoutRenderedEvents(resource);
                view.getEventSelectionModel().isSelected(event) && view.onEventBarSelect(event, true);
            });
        }
    },

    // private
    onEventAdd: function (store, recs) {
        var me = this,
            view = me.view,
            event, startDate, endDate;

        if (recs.length === 1) {
            event     = recs[0];
            startDate = event.getStartDate();
            endDate   = event.getEndDate();

            if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
                me.renderSingle(event);
                // Here one could use event.getResources() as well, I use store.getResourcesForEvent() here
                // for consistency with onEventUpdate only
                Ext.Array.forEach(store.getResourcesForEvent(event), function(resource) {
                    me.relayoutRenderedEvents(resource);
                });
            }
        } else {
            view.repaintAllEvents();
        }
    },

    // private
    onEventRemove: function (s, events) {
        // a comment from `repaintEventsForResource`
        // For vertical, we always repaint all events (do per-column repaint is not supported)
        // so it seems we can't optimize and repaint only for single resource
        var me = this,
            view = me.view,
            event,
            startDate,
            endDate,
            i, len, gotEventInTimeSpan;

        for (gotEventInTimeSpan = false, i = 0, len = events.length; !gotEventInTimeSpan && i < len; i++) {
            event       = events[i];
            startDate   = event.getStartDate();
            endDate     = event.getEndDate();

            gotEventInTimeSpan = startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate);
            gotEventInTimeSpan && view.repaintAllEvents();
        }
    },


    relayoutRenderedEvents : function(resource) {
        var data   = [],
            view   = this.view,
            events = view.eventStore.getEventsForResource(resource);

        Ext.Array.forEach(view.eventStore.getEventsForResource(resource), function(event) {
            // In vertical mode there can be only 0 or 1 nodes rendered for each event/resource pair
            var nodes = view.getElementsFromEventRecord(event, resource);

            nodes.length && data.push({
                start : event.getStartDate(),
                end   : event.getEndDate(),
                event : event,
                node  : nodes[0]
            });
        });

        // Now do a layout pass to get updated dimension / position data for all affected events
        view.eventLayout.vertical.applyLayout(data, this.getResourceColumnWidth(resource));

        Ext.Array.forEach(data, function(event) {
            event.node.setStyle({
                left  : event.left + 'px',
                width : event.width + 'px'
            });

            view.fireEvent('eventrepaint', view, event.event, event.node);
        });
    },

    renderSingle : function (event) {
        // Inject moved event into correct cell
        var me          = this,
            view        = me.view,
            startDate   = event.getStartDate(),
            endDate     = event.getEndDate(),
            resources;

        // First removing existing event DOM elements, there might be one element per each event/resource pair
        Ext.Array.forEach(view.getElementsFromEventRecord(event), function(el) {
            el.destroy();
        });

        // If event is within a currently displayed timespan
        if (startDate && endDate && view.timeAxis.timeSpanInAxis(startDate, endDate)) {
            // then render event DOM elements for each event assigned resource
            Ext.Array.forEach(event.getResources(), function(resource) {
                var rIndex        = view.resourceStore.indexOf(resource),
                    containerCell = Ext.fly(view.getScheduleCell(0, rIndex)),
                    data;

                if (containerCell) { // This check is unclear, I've just left it as is after the method refactoring
                    data = view.generateTplData(event, resource, rIndex);
                    view.eventTpl.append(containerCell.first(), [data]);
                }
            });
        }
    },

    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function (startDate, endDate) {
        var view        = this.view,
            startY      = view.getCoordinateFromDate(startDate),
            endY        = endDate ? view.getCoordinateFromDate(endDate) : startY,
            tableRegion = view.getTableRegion(),
            width       = tableRegion ? tableRegion.right - tableRegion.left : view.getEl().dom.clientWidth; // fallback in case grid is not rendered (no rows/table)

        return new Ext.util.Region(Math.min(startY, endY), width, Math.max(startY, endY), 0);
    },

    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function (region, roundingMethod, allowPartial) {
        var topDate = this.view.getDateFromCoordinate(region.top, roundingMethod),
            bottomDate = this.view.getDateFromCoordinate(region.bottom, roundingMethod);

        if (topDate && bottomDate) {
            return {
                start : Sch.util.Date.min(topDate, bottomDate),
                end : Sch.util.Date.max(topDate, bottomDate)
            };
        } else {
            return null;
        }
    },

    setColumnWidth : function (width, preventRefresh) {
        var view = this.view;

        view.resourceColumnWidth = width;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },

    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function () {
        var view = this.view;

        if (!view.rendered) {
            return null;
        }

        var scroll      = view.getScroll(),
            height      = view.getHeight(),
            tableRegion = view.getTableRegion(),
            viewEndDate = view.timeAxis.getEnd();

        if (tableRegion.bottom - tableRegion.top < height) {
            var startDate   = view.timeAxis.getStart();

            return { startDate: startDate, endDate: viewEndDate };
        }

        return {
            startDate   : view.getDateFromCoordinate(scroll.top, null, true),
            endDate     : view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate
        };
    }
});

/**
@class Sch.view.Calendar

A mixin, purposed to be consumed along with {@link Sch.mixin.AbstractTimelineView} and providing the implementation of some methods, specific to calendar mode.

*/
Ext.define("Sch.view.Calendar", {

    requires : [
        'Ext.util.Region'
    ],

    // Provided by creator, in the config object
    view : null,

    constructor : function(config) {
        Ext.apply(this, config);
    },

    // return columns that passes condition
    // if includeIndex is true then column index is also returned
    getColumnBy : function (conditionFn, includeIndex) {
        var columns = this.view.panel.headerCt.getGridColumns();

        var result = [];

        for (var i = 0; i < columns.length; i++) {
            if (conditionFn.call(this, columns[i])) {
                if (includeIndex !== true) {
                    result.push(columns[i]);
                } else {
                    result.push({
                        column  : columns[i],
                        index   : i
                    });
                }
            }
        }

        return result;
    },

    getEventColumns  : function (event, includeIndex) {
        return this.getColumnBy(function (column) {
            return !(event.getEndDate() <= column.start || event.getStartDate() >= column.end);
        }, includeIndex);
    },

    getColumnEvents : function (column) {
        var result  = [];

        this.view.eventStore.each(function (record) {
            if (!(record.getEndDate() <= column.start || record.getStartDate() >= column.end )) {
                result.push(record);
            }
        });

        return result;
    },

    getColumnByResource : function (resource, includeIndex) {
        return this.getColumnBy(function (column) {
            return column.start == resource.start;
        }, includeIndex)[0];
    },

    translateToScheduleCoordinate: function (coord) {
        var view = this.view;

        if (Ext.isArray(coord)) {
            return [
                coord[0] - view.getEl().getX() + view.getScroll().left,
                coord[1] - view.getEl().getY() + view.getScroll().top
            ];
        } else {
            return coord - view.getEl().getY() + view.getScroll().top;
        }
    },

    // private
    translateToPageCoordinate: function (coord) {
        var view = this.view;
        var el = view.getEl(),
            scroll = el.getScroll();

        if (Ext.isArray(coord)) {
            return [
                coord[0] + el.getX() - scroll.left,
                coord[1] + el.getY() - scroll.top
            ];
        } else {
            return coord + el.getY() - scroll.top;
        }
    },

    getDateFromXY   : function (xy, roundingMethod, local) {
        var coord   = xy;

        if (!local) {
            coord = this.translateToScheduleCoordinate(coord);
        }
        return this.view.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },

    getEventRenderData : function(event, resource, resourceIndex) {
        var eventStart  = event.getStartDate(),
            eventEnd    = event.getEndDate(),
            view        = this.view,
            columns     = view.panel.headerCt.getGridColumns(),
            viewStart   = columns[resourceIndex].start,
            viewEnd     = columns[resourceIndex].end,
            M           = Math;

        var startY      = Math.floor(view.getCoordinateFromDate(Sch.util.Date.max(eventStart, viewStart)));
        var endY        = Math.floor(view.timeAxisViewModel.getPositionFromDate(Sch.util.Date.min(eventEnd, viewEnd), true));
        var colWidth    = this.getCalendarColumnWidth();
        var data;

        // in calendar view we duplicate time for end of column and start of next column
        // if we got 0 that means end is in fact column bottom
        if (endY === 0) {
            endY    = view.getStore().getCount() * view.getRowHeight();
        }

        data = {
            top     : M.max(0, M.min(startY, endY) - view.eventBorderWidth),
            height  : M.max(1, M.abs(startY - endY))
        };

        if (view.managedEventSizing) {
            data.left = view.barMargin;
            data.width = colWidth - (2*view.barMargin) - view.eventBorderWidth;
        }

        data.start = eventStart;
        data.end = eventEnd;
        data.startsOutsideView = eventStart < viewStart;
        data.endsOutsideView = eventEnd > viewEnd;

        return data;
    },

    // we consider resourceRecord to be date
    getScheduleRegion: function (resourceRecord, eventRecord) {
        var view        = this.view,
            region      = resourceRecord ? this.getColumnByResource(resourceRecord).getRegion() : view.getTableRegion(),

            startY      = this.translateToPageCoordinate(0),
            endY        = this.translateToPageCoordinate(view.getStore().getCount() * view.getRowHeight()),

            left        = region.left + view.barMargin,
            right       = region.right - view.barMargin;

        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },

    getCalendarColumnWidth : function(resource) {
        return this.view.timeAxisViewModel.calendarColumnWidth;
    },

    /**
    * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function (resourceRecord, startDate, endDate) {
        var view            = this.view,
            cellLeft        = view.resourceStore.indexOf(resourceRecord) * this.getCalendarColumnWidth(),
            taStart         = view.timeAxis.getStart(),
            taEnd           = view.timeAxis.getEnd(),
            start           = startDate ? Sch.util.Date.max(taStart, startDate) : taStart,
            end             = endDate ? Sch.util.Date.min(taEnd, endDate) : taEnd,
            startY          = Math.max(0, view.getCoordinateFromDate(start) - view.cellTopBorderWidth),
            endY            = view.getCoordinateFromDate(end) - view.cellTopBorderWidth,
            left            = cellLeft + view.cellBorderWidth,
            right           = cellLeft + this.getCalendarColumnWidth() - view.cellBorderWidth;

        return new Ext.util.Region(Math.min(startY, endY), right, Math.max(startY, endY), left);
    },

    columnRenderer: function (val, meta, resourceRecord, rowIndex, colIndex) {
        var view = this.view;
        var retVal = '';

        if (rowIndex === 0) {
            var columnEvents,
                resourceEvents,
                i, l;

            columnEvents = [];
            resourceEvents = this.getColumnEvents(meta.column);

            // Iterate events (belonging to current resource)
            for (i = 0, l = resourceEvents.length; i < l; i++) {
                var event   = resourceEvents[i];
                columnEvents.push(view.generateTplData(event, resourceRecord, colIndex));
            }
            view.eventLayout.vertical.applyLayout(columnEvents, this.getCalendarColumnWidth());
            retVal = '&#160;' + view.eventTpl.apply(columnEvents);
        }

        if (colIndex % 2 === 1) {
            meta.tdCls = (meta.tdCls || '') + ' ' + view.altColCls;
            meta.cellCls = (meta.cellCls || '') + ' ' + view.altColCls;
        }

        return retVal;
    },

    // private
    resolveResource: function (el) {
        var view = this.view;
        el = Ext.fly(el).is(view.timeCellSelector) ? el : Ext.fly(el).up(view.timeCellSelector);

        if (el) {
            var node = el.dom ? el.dom : el;
            var index = 0;

            if (Ext.isIE8m) {
                node = node.previousSibling;

                while (node) {
                    if( node.nodeType === 1 ) {
                        index++;
                    }

                    node = node.previousSibling;
                }
            } else {
                index = Ext.Array.indexOf(Array.prototype.slice.call(node.parentNode.children), node);
            }

            if (index >= 0) {
                // TODO: unsafe
                var column = view.panel.headerCt.getGridColumns()[index];
                return {
                    start   : column.start,
                    end     : column.end
                };
            }
        }
    },

    // private
    onEventUpdate: function (store, model) {
        this.renderSingle.call(this, model);

        //model previous is undefined after return store sync
        var previous = model.previous || {};

        // TODO: need to refactor, we call relayoutRenderedEvents() twice which may trigger redundant repainting of the same column(s) twice

        // relayout column we dragged from
        var tmpEvent = new Sch.model.Event({
            StartDate   : previous.StartDate || model.getStartDate(),
            EndDate     : previous.EndDate || model.getEndDate()
        });
        this.relayoutRenderedEvents(tmpEvent);

        // relayout column we dropped to
        this.relayoutRenderedEvents(model);


        // restore visual event selection
        var view = this.view;
        var sm = view.getEventSelectionModel();

        sm.forEachEventRelatedSelection(model, function(selectedRecord) {
            view.onEventBarSelect(selectedRecord);
        });
    },

    // private
    onEventAdd: function (s, recs) {
        var view = this.view;

        if (recs.length === 1) {
            this.renderSingle(recs[0]);
            this.relayoutRenderedEvents(recs[0]);
        } else {
            view.repaintAllEvents();
        }
    },

    // private
    onEventRemove: function (s, recs) {
        var view = this.view;

        if (recs.length === 1) {
            this.relayoutRenderedEvents(recs[0]);
        } else {
            view.repaintAllEvents();
        }
    },

    relayoutRenderedEvents : function(targetEvent) {
        var me      = this,
            columns = me.getEventColumns(targetEvent, true);

        // When event is rendered into multiple columns each part should behave like separate event.
        // For example, event is rendered into two columns. User created new event and dropped it so
        // new one is overlapping with old one in second column. Desired behavior is following:
        // part in the first column is untouched and part of old event in second column takes only half width.
        Ext.each(columns, function (column) {
            me.repaintEventsForColumn(column.column, column.index);
        });
    },

    renderSingle : function (event) {
        // Inject moved event into correct cell
        var view        = this.view;
        // TODO: we don't have resource for new event, let's simulate for now
        var resource    = this.view.resourceStore.first();
        var columns     = this.getEventColumns(event, true);

        Ext.each(view.getElementsFromEventRecord(event), function (el) {
            Ext.fly(el).destroy();
        });

        Ext.each(columns, function (column) {
            var containerCell   = Ext.fly(view.getScheduleCell(0, column.index));

            // if grid content is not yet rendered, then just do nothing
            if (!containerCell) return;

            var data            = view.generateTplData(event, resource, column.index);

            if (!Ext.versions.touch) {
                containerCell = containerCell.first();
            }

            view.eventTpl.append(containerCell, [data]);
        });
    },

    repaintEventsForColumn  : function (column, index) {
        var me      = this;
        var events  = me.getColumnEvents(column);
        var view    = me.view;
        var data    = [],
            i, l, event, node, start, end;

        if (events.length > 0) {
            for (i = 0, l = events.length; i < l; i++) {
                event   = events[i];
                node    = view.getElementsFromEventRecord(event)[0];

                // nothing is rendered yet
                if (!node) {
                    return;
                }

                // each event node if calendar view has column index in it
                // we need a common id without column index, so we perform split/pop/join
                var commonId    = node.id.split('-');
                commonId.pop();

                start   = event.getStartDate();
                end     = event.getEndDate();

                // simulate one-column events for vertical layout
                data.push({
                    start   : start < column.start ? column.start : start,
                    end     : end > column.end ? column.end : end,
                    event   : event,
                    id      : commonId.join('-')
                });
            }
        }

        view.eventLayout.vertical.applyLayout(data, column.getWidth());

        // We render events into first row in the table so we need this element to make lookups.
        var trEl    = Ext.get(Ext.DomQuery.selectNode('tr:nth-child(1)', view.el.dom));

        for (i = 0; i < data.length; i++) {
            event = data[i];
            // We should only touch events (events' parts) that are rendered into changed column.
            // Since parts of one event share element id we have to look up in certain cell.
            // In Ext5 Ext.dom.Query is not a default selector, so pseudo classes are failing in IE8
            var fly = Ext.get(Ext.DomQuery.selectNode('td:nth-child(' + (index + 1) + ') [id^=' + event.id + '-]', trEl.dom));
            // for the case when we relayout short event
            fly && fly.setStyle({
                left    : event.left + 'px',
                width   : Math.max(event.width, 0) + 'px'
            });
        }
    },

    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function (startDate, endDate) {
        var view        = this.view,
            startY      = view.getCoordinateFromDate(startDate),
            endY        = endDate ? view.getCoordinateFromDate(endDate, true, true) : startY;

        var startColumn = this.getColumnBy(function (column) {
            return column.start <= startDate && column.end > startDate;
        })[0];

        var endColumn   = this.getColumnBy(function (column) {
            return column.start < endDate && column.end >= endDate;
        })[0];

        var pair1 = this.translateToScheduleCoordinate([startColumn.getX(), 0]);
        var pair2 = this.translateToScheduleCoordinate([endColumn ? endColumn.getRegion().right : startColumn.getWidth() + pair1[0], 0]);

        return new Ext.util.Region(Math.min(startY, endY), pair2[0],  Math.max(startY, endY), pair1[0]);
    },

    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function (region, roundingMethod, allowPartial) {
        var topDate = this.view.getDateFromCoordinate([region.left, region.top], roundingMethod),
            bottomDate = this.view.getDateFromCoordinate([region.left, region.bottom], roundingMethod);

        if (topDate && bottomDate) {
            return {
                start : Sch.util.Date.min(topDate, bottomDate),
                end : Sch.util.Date.max(topDate, bottomDate)
            };
        } else {
            return null;
        }
    },

    setColumnWidth : function (width, preventRefresh) {
        var view = this.view;

        view.calendarColumnWidth = width;
        view.getTimeAxisViewModel().setViewColumnWidth(width, preventRefresh);
    },

    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function () {
        var view = this.view;

        if (!view.rendered) {
            return null;
        }

        var scroll      = view.getScroll(),
            height      = view.getHeight(),
            tableRegion = view.getTableRegion(),
            viewEndDate = view.timeAxis.getEnd();

        if (tableRegion.bottom - tableRegion.top < height) {
            var startDate   = view.timeAxis.getStart();

            return { startDate: startDate, endDate: viewEndDate };
        }

        return {
            startDate   : view.getDateFromCoordinate(scroll.top, null, true),
            endDate     : view.getDateFromCoordinate(scroll.top + height, null, true) || viewEndDate
        };
    }
});

/**
@class Sch.selection.EventModel
@extends Ext.selection.Model

This class provides the basic implementation event selection in a grid.

*/
Ext.define("Sch.selection.EventModel", {
    extend      : 'Ext.selection.Model',

    alias       : 'selection.eventmodel',

    requires    : [ 'Ext.util.KeyNav' ],

    /**
     * @cfg {Boolean} deselectOnContainerClick `True` to deselect all events when user clicks on the underlying space in scheduler. Defaults to `true`.
     */
    deselectOnContainerClick : true,

    // Stores selected record on mousedown event to avoid
    // unselecting record on click
    selectedOnMouseDown : false,

    /**
     * @event beforedeselect
     * Fired before a record is deselected. If any listener returns false, the
     * deselection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */

    /**
     * @event beforeselect
     * Fired before a record is selected. If any listener returns false, the
     * selection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */

    /**
     * @event deselect
     * Fired after a record is deselected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */

    /**
     * @event select
     * Fired after a record is selected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Event} record The selected event
     */

    bindToView : function(view) {

        var me = this;

        me.view = view;

        var eventStore = view.eventStore;
        var resourceStore = view.resourceStore;

        me.bindStore(eventStore);

        // events are redrawn on 'refresh' event, so we have to clear selection at this point
        view.mon(resourceStore, 'beforeload', me.clearSelectionOnRefresh, me);
        view.mon(eventStore, 'beforeload', me.clearSelectionOnRefresh, me);

        view.on({
            eventclick     : me.onEventClick,
            eventmousedown : me.onEventMouseDown,
            itemmousedown  : me.onItemMouseDown,
            refresh        : function() {
                me.refresh();
            },
            destroy        : function() {
                me.bindStore(null);
            },
            scope          : me
        });
    },

    // TODO: remove this code after testing, it's not neccessary anymore in ExtJS 5.x probably
    // #1555 - Drag&drop of multiple events works incorrectly at second time
    // There is a bug in extjs version 4.2.2 and less - when store is loaded, selection model contains unbound records.
    // We decided to clear selection after store is loaded.
    // http://www.sencha.com/forum/showthread.php?290474-Selected-records-are-unbound-of-store-after-store-is-refreshed&p=1061396
    clearSelectionOnRefresh    : function () {
        this.clearSelections();
    },


    onEventMouseDown: function(view, record, e) {
        // Reset previously stored records
        this.selectedOnMouseDown = null;

        // Change selection before dragging to avoid moving of unselected events
        if (!this.isSelected(record)) {
            this.selectedOnMouseDown = record;
            this.selectWithEvent(record, e);
        }
    },

    onEventClick: function(view, record, e) {
        // Don't change selection if record been already selected on mousedown
        if (!this.selectedOnMouseDown) {
            this.selectWithEvent(record, e);
        }
    },

    onItemMouseDown: function(a, b, c, d, eventObj) {
        if (this.deselectOnContainerClick && !eventObj.getTarget(this.view.eventSelector)) {
            this.deselectAll();
        }
    },

    onSelectChange: function(record, isSelected, suppressEvent, commitFn) {
         var me      = this,
            view   = me.view,
            store   = me.store,
            eventName = isSelected ? 'select' : 'deselect',
            i = 0;

        if ((suppressEvent || me.fireEvent('before' + eventName, me, record)) !== false && commitFn() !== false) {

            if (isSelected) {
                view.onEventBarSelect(record, suppressEvent);
            } else {
                view.onEventBarDeselect(record, suppressEvent);
            }

            if (!suppressEvent) {
                me.fireEvent(eventName, me, record);
            }
        }
    },

    // Not supported.
    selectRange : Ext.emptyFn,

    selectNode: function(node, keepExisting, suppressEvent) {
        var r = this.view.resolveEventRecord(node);
        if (r) {
            this.select(r, keepExisting, suppressEvent);
        }
    },

    deselectNode: function(node, keepExisting, suppressEvent) {
        var r = this.view.resolveEventRecord(node);
        if (r) {
            this.deselect(r, suppressEvent);
        }
    },

    /**
     * Returns first selected event record for the given resource record or null if the resource has no assigned
     * events which are selected.
     *
     * @param {Sch.model.Resource} resource
     * @return {Sch.model.Event}
     */
    getFirstSelectedEventForResource : function(resource) {
        var selections = this.getSelection(),
            event = null,
            i, len, r;

        for (i = 0, len = selections.length; !event && i < len; ++i) {
            r = selections[i];
            if (r.isAssignedTo(resource)) {
                event = r;
            }
        }

        return event;
    },

    getDraggableSelections : function() {
        return Ext.Array.filter(
            this.getSelection(),
            function(record) {
                return record.isDraggable();
            }
        );
    },

    forEachEventRelatedSelection : function(eventRecord, fn) {
        this.isSelected(eventRecord) && fn(eventRecord);
    }
});

/**
 * @class Sch.selection.EventModel
 * @extends Ext.selection.Model
 *
 * This class provides assignment selection model for multiple assignments mode, i.e. when the event store is configured
 * with assignment store and uses it for storring event to resource and resource to event assignment information.
 * In multiple assignment mode there're might be several event bars rendered for each event in the event store, thus
 * an inconsistency appears, to solve the inconsistency we use assignment record as entities being selected since
 * there's direct correspondence between event bar and assignment the bar is rendered for.
 */
Ext.define('Sch.selection.AssignmentModel', {
    extend : 'Sch.selection.EventModel',
    alias  : 'selection.assignmentmodel',

    /**
     * @event beforedeselect
     * Fired before a record is deselected. If any listener returns false, the
     * deselection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */

    /**
     * @event beforeselect
     * Fired before a record is selected. If any listener returns false, the
     * selection is cancelled.
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */

    /**
     * @event deselect
     * Fired after a record is deselected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */

    /**
     * @event select
     * Fired after a record is selected
     * @param {Sch.selection.EventModel} this
     * @param {Sch.model.Assignment} record The selected assignment
     */

    assignmentStoreDetacher : null,

    destroy : function() {
        var me = this;

        Ext.destroyMembers(
            me,
            'assignmentStoreDetacher'
        );

        me.callParent();
    },

    bindToView : function(view) {
        var me = this,
            eventStore,
            assignmentStore;

        me.callParent([view]);

        eventStore = me.view.eventStore;
        assignmentStore = eventStore.getAssignmentStore();

        if (assignmentStore) {
            me.assignmentStoreDetacher = assignmentStore.on({
                'remove'    : me.onAssignmentStoreRemove,
                'clear'     : me.onAssignmentStoreClear,
                'refresh'   : me.onAssignmentStoreRefresh,
                scope       : me,
                destroyable : true
            });
        }
    },

    selectWithEvent : function(eventRecord, e) {
        var me = this,
            view = me.view,
            resourceRecord = view.resolveResource(e.getTarget()),
            assignmentStore,
            assignmentRecord;

        if (resourceRecord) {
            assignmentStore  = view.eventStore.getAssignmentStore();
            assignmentRecord = assignmentStore.getAssignmentForEventAndResource(eventRecord, resourceRecord);
            if (assignmentRecord) {
                me.callParent([assignmentRecord, e]);
            }
        }
    },


    getFirstSelectedEventForResource : function(resource) {
        var selections = this.getSelection(),
            event = null,
            i, len, r;

        for (i = 0, len = selections.length; !event && i < len; ++i) {
            r = selections[i];
            if (r.getEvent().isAssignedTo(resource)) {
                event = r;
            }
        }

        return event;
    },

    getDraggableSelections : function() {
        return Ext.Array.filter(
            this.getSelection(),
            function(record) {
                return record.getEvent().isDraggable();
            }
        );
    },

    forEachEventRelatedSelection : function(eventRecord, fn) {
        Ext.Array.forEach(this.getSelection(), function(selectedRecord) {
            selectedRecord.getEvent() === eventRecord && fn(selectedRecord);
        });
    },

    onAssignmentStoreRemove : function(assignmentStore, removedRecords) {
        this.deselect(removedRecords, true);
    },

    onAssignmentStoreClear : function(assignmentStore) {
        this.clearSelections();
    },

    onAssignmentStoreRefresh : function(assignmentStore) {
        this.clearSelections();
    }
});

/**
@class Sch.plugin.Printable

Plugin (ptype = 'scheduler_printable') for printing an Ext Scheduler instance. Please note that this will not generate a picture perfect
 printed version, due to various limitations in the browser print implementations. If you require a high quality print, you should use the Export plugin instead and first export to PDF.

 To use this plugin, add it to scheduler as usual. The plugin will add an additional `print` method to the scheduler:

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Printable', {
                    // default values
                    docType             : '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">',
                    autoPrintAndClose   : true
                })
            ]
        });

        ...

        scheduler.print();

In the opened print window, a special 'sch-print-body' CSS class will be added to the BODY element. You can use this to
 further customize the printed contents.

*/
Ext.define("Sch.plugin.Printable", {
    extend          : 'Ext.AbstractPlugin',

    alias           : 'plugin.scheduler_printable',

    requires        : [
        'Ext.XTemplate'
    ],

    lockableScope   : 'top',

    /**
     * @cfg {String} docType This is the DOCTYPE to use for the print window. It should be the same DOCTYPE as on your application page.
     */
    docType             : '<!DOCTYPE HTML>',

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the print plugin extracts data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @method beforePrint
     */
    beforePrint         : Ext.emptyFn,

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the print plugin has extracted the data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @method afterPrint
     */
    afterPrint          : Ext.emptyFn,

    /**
     * @cfg {Boolean} autoPrintAndClose True to automatically call print and close the new window after printing. Default value is `true`
     */
    autoPrintAndClose   : true,

     /**
     * @cfg {Boolean} fakeBackgroundColor True to reset background-color of events and enable use of border-width to fake background color (borders print by default in every browser). Default value is `true`
     */
    fakeBackgroundColor : true,

    scheduler           : null,

    // private, the template for the new window
    mainTpl        : null,

    constructor : function(config) {
        Ext.apply(this, config);

        if (!this.mainTpl) {

            this.mainTpl = new Ext.XTemplate('{docType}' +
                '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' +
                '<head>' +
                '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' +
                '<title>{title}</title>' +
                '{styles}' +
                '</head>' +
                '<body class="sch-print-body {bodyClasses}">' +
                '<div class="sch-print-ct {componentClasses}" style="width:{totalWidth}px">' +
                '<div class="sch-print-headerbg" style="border-left-width:{totalWidth}px;height:{headerHeight}px;"></div>' +
                '<div class="sch-print-header-wrap">' +
                '{[this.printLockedHeader(values)]}' +
                '{[this.printNormalHeader(values)]}' +
                '</div>' +
                '{[this.printLockedGrid(values)]}' +
                '{[this.printNormalGrid(values)]}' +
                '</div>' +
                '<script type="text/javascript">' +
                '{setupScript}' +
                '</script>' +
                '</body>' +
                '</html>',
            {
                printLockedHeader : function (values) {
                    var str = '';

                    if (values.lockedGrid) {
                        str += '<div style="left:-' + values.lockedScroll + 'px;margin-right:-' + values.lockedScroll + 'px;width:' + (values.lockedWidth + values.lockedScroll) + 'px"';
                        str += 'class="sch-print-lockedheader ' + values.lockedGrid.headerCt.el.dom.className + '">';
                        str += values.lockedHeader;
                        str += '</div>';
                    }
                    return str;
                },
                printNormalHeader : function (values) {
                    var str = '';

                    if (values.normalGrid) {
                        str += '<div style="left:' + (values.lockedGrid ? values.lockedWidth : '0') + 'px;width:' + values.normalWidth + 'px;" class="sch-print-normalheader ' + values.normalGrid.headerCt.el.dom.className + '">';
                        str += '<div style="margin-left:-' + values.normalScroll + 'px">' + values.normalHeader + '</div>';
                        str += '</div>';
                    }
                    return str;
                },
                printLockedGrid   : function (values) {
                    var str = '';

                    if (values.lockedGrid) {
                        str += '<div id="lockedRowsCt" style="left:-' + values.lockedScroll + 'px;margin-right:-' + values.lockedScroll + 'px;width:' + (values.lockedWidth + values.lockedScroll) + 'px;top:' + values.headerHeight + 'px;" class="sch-print-locked-rows-ct ' + values.innerLockedClasses + ' ' + Ext.baseCSSPrefix + 'grid-inner-locked">';
                        str += values.lockedRows;
                        str += '</div>';
                    }
                    return str;
                },
                printNormalGrid   : function (values) {
                    var str = '';

                    if (values.normalGrid) {
                        str += '<div id="normalRowsCt" style="left:' + (values.lockedGrid ? values.lockedWidth : '0') + 'px;top:' + values.headerHeight + 'px;width:' + values.normalWidth + 'px" class="sch-print-normal-rows-ct ' + values.innerNormalClasses + '">';
                        str += '<div style="position:relative;overflow:visible;margin-left:-' + values.normalScroll + 'px">' + values.normalRows + '</div>';
                        str += '</div>';
                    }
                    return str;
                }
            });
        }
    },

    init : function(scheduler) {
        this.scheduler = scheduler;

        scheduler.print = Ext.Function.bind(this.print, this);
    },

    // private
    getGridContent : function(component) {
        var normalGrid = component.normalGrid,
            lockedGrid = component.lockedGrid,
            lockedView = lockedGrid.getView(),
            normalView = normalGrid.getView(),
            header, lockedRows, normalRows, lockedScroll, normalScroll,
            normalWidth, lockedWidth;

        this.beforePrint(component);

        if (lockedGrid.collapsed && !normalGrid.collapsed){
            normalWidth = lockedGrid.getWidth() + normalGrid.getWidth();
        } else {
            normalWidth = normalGrid.getWidth();
            lockedWidth = lockedGrid.getWidth();
        }

        // Render rows
        var records  = lockedView.store.getRange();
        lockedRows   = lockedView.tpl.apply(lockedView.collectData(records, 0));
        normalRows   = normalView.tpl.apply(normalView.collectData(records, 0));
        lockedScroll = lockedView.el.getScroll().left;
        normalScroll = normalView.el.getScroll().left;

        var div = document.createElement('div');
        div.innerHTML = lockedRows;
        // Need to manually set a width on the table el
        div.firstChild.style.width = lockedView.el.dom.style.width;

        lockedRows = div.innerHTML;

        // Print additional markup produced by lines plugins, zones plugins etc
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {
            var toIterate = (component.plugins || []).concat(component.normalGrid.plugins || []).concat(component.columnLinesFeature || []);
            Ext.each(toIterate, function(plug) {
                if (plug instanceof Sch.feature.AbstractTimeSpan && plug.generateMarkup) {
                    normalRows = plug.generateMarkup(true) + normalRows;
                }
            });
        }

        this.afterPrint(component);

        return {
            normalHeader       : normalGrid.headerCt.el.dom.innerHTML,
            lockedHeader       : lockedGrid.headerCt.el.dom.innerHTML,
            lockedGrid         : lockedGrid.collapsed ? false : lockedGrid,
            normalGrid         : normalGrid.collapsed ? false : normalGrid,
            lockedRows         : lockedRows,
            normalRows         : normalRows,
            lockedScroll       : lockedScroll,
            normalScroll       : normalScroll,
            lockedWidth        : lockedWidth - (Ext.isWebKit ? 1 : 0),
            normalWidth        : normalWidth,
            headerHeight       : normalGrid.headerCt.getHeight(),
            innerLockedClasses : lockedGrid.view.el.dom.className,
            innerNormalClasses : normalGrid.view.el.dom.className + (this.fakeBackgroundColor ? ' sch-print-fake-background' : ''),
            width              : component.getWidth()
        };
    },

    getStylesheets : function() {
        return Ext.getDoc().select('link[rel="stylesheet"]');
    },

    /**
     * Prints a scheduler panel. This method will be aliased to the main scheduler instance, so you can call it directly:
     *
     *      scheduler.print()
     */
    print : function() {
        var component = this.scheduler;

        if (!(this.mainTpl instanceof Ext.Template)) {
            // Compile the tpl upon first call
            var headerRowHeight = 22;

            this.mainTpl = new Ext.XTemplate(this.mainTpl, {
                compiled : true,
                disableFormats : true
            });
        }

        var v = component.getView(),
            styles = this.getStylesheets(),
            ctTmp = Ext.get(Ext.core.DomHelper.createDom({
                tag : 'div'
            })),
            styleFragment;

        styles.each(function(s) {
            ctTmp.appendChild(s.dom.cloneNode(true));
        });

        styleFragment = ctTmp.dom.innerHTML + '';

        var gridContent = this.getGridContent(component),
            html = this.mainTpl.apply(Ext.apply({
                waitText            : this.waitText,
                docType             : this.docType,
                htmlClasses         : Ext.getBody().parent().dom.className,
                bodyClasses         : Ext.getBody().dom.className,
                componentClasses    : component.el.dom.className,
                title               : (component.title || ''),
                styles              : styleFragment,
                totalWidth          : component.getWidth(),
                setupScript         : ("window.onload = function(){ (" + this.setupScript.toString() + ")(" +
                    component.syncRowHeight + ", " + this.autoPrintAndClose + ", " + Ext.isChrome + ", " + Ext.isIE +
                "); };")
            }, gridContent));

        var win             = window.open('', 'printgrid');

        // this crazy case (there's a window but win.document is null) happens sometimes in IE10 during testing in automation mode
        if (!win || !win.document) return false;

        // Assign to this for testability, need a reference to the opened window
        this.printWindow    = win;

        win.document.write(html);
        win.document.close();
    },

    // Script executed in the newly open window, to sync row heights
    setupScript : function (syncRowHeight, autoPrintAndClose, isChrome, isIE) {
        var syncHeightAndPrint  = function () {
            if (syncRowHeight) {
                var lockedTableCt = document.getElementById('lockedRowsCt'),
                    normalTableCt = document.getElementById('normalRowsCt'),

                    //checks added in case of hidden/collapsed grids
                    lockedRows = lockedTableCt && lockedTableCt.getElementsByTagName('tr'),
                    normalRows = normalTableCt && normalTableCt.getElementsByTagName('tr'),
                    count      = normalRows && lockedRows ? normalRows.length : 0;

                for (var i = 0; i < count; i++) {
                    var normalHeight    = normalRows[ i ].clientHeight;
                    var lockedHeight    = lockedRows[ i ].clientHeight;

                    var max             = Math.max(normalHeight, lockedHeight) + 'px';

                    lockedRows[ i ].style.height = normalRows[ i ].style.height = max;
                }
            }

            // Let's make special mark saying that document is loaded. This is needed for test purposes.
            document._loaded  = true;

            if (autoPrintAndClose) {
                window.print();
                // Chrome cannot print the page if you close the window being printed
                if (!isChrome) {
                    window.close();
                }
            }
        };

        if (isIE)
            // TODO: probably we don't need this anymore, as we now use window.onload to call setupScript
            setTimeout(syncHeightAndPrint, 0);
        else
            syncHeightAndPrint();
    }
});

/**
 @class Sch.plugin.exporter.AbstractExporter
 @extends Ext.util.Observable

 This class represents the base implementation of an exporter.
 An exporter extracts the provided component content and packs it into array of pages (based on provided export settings and implemented algorithm).
 The main entry point for an exporter that launches the extraction process is {@link #extractPages} method:

             exporter.extractPages(component, config, function (pages) {

                alert(pages.length + " extracted");

                ...

             }, me);


*/
Ext.define('Sch.plugin.exporter.AbstractExporter', {

    extend                  : 'Ext.util.Observable',

    requires                : [
        'Ext.dom.Element',
        'Ext.core.DomHelper'
    ],

    mixins                  : ['Sch.mixin.Localizable'],

    /**
     * @cfg {Number} pageHeaderHeight
     * Header height. Amount of space for {@link #headerTpl the page header}.
     */
    pageHeaderHeight        : 41,

    /**
     * @cfg {Number} pageFooterHeight
     * Footer height. Amount of space for {@link #footerTpl the page footer}.
     */
    pageFooterHeight        : 0,

    bufferedHeightMargin    : 25,

    /**
     * @property {Number} paperWidth
     * Paper width. Calculated based on provided page format and DPI resolution.
     */
    paperWidth              : 0,

    /**
     * @property {Number} paperHeight
     * Paper height. Calculated based on provided page format and DPI resolution.
     */
    paperHeight             : 0,

    /**
     * @property {Number} printHeight
     * Paper height that can be used for printing rows. Calculated as {@link #paperHeight} minus header heights.
     */
    printHeight             : 0,

    lockedRowsHeight        : 0,

    normalRowsHeight        : 0,

    iterateTimeout          : 10,

    /**
     * @cfg {String} tableSelector
     * The selector for the row container used for both normalGrid and lockedGrid.
     */
    tableSelector           : undefined,

    /**
     * @property {Ext.dom.Element} currentPage
     * Current page being extracted.
     */
    currentPage             : undefined,

    /**
     * @cfg {Function} headerTplDataFn
     * If specified the function result will be applied to {@link #getHeaderTplData} result.
     * To define the scope please use {@link #headerTplDataFnScope}.
     */
    headerTplDataFn        : null,

    /**
     * @cfg {Function} footerTplDataFn
     * If specified the function result will be applied to {@link #getFooterTplData} result.
     * To define the scope please use {@link #footerTplDataFnScope}.
     */
    footerTplDataFn        : null,

    /**
     * @cfg {Object} headerTplDataFnScope The scope for {@link #footerTplDataFn} template method.
     */
    headerTplDataFnScope   : null,

    /**
     * @cfg {Object} footerTplDataFnScope The scope for {@link #footerTplDataFn} template method.
     */
    footerTplDataFnScope   : null,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - name    : 'Exporter'
     */

    config                      : {
        /**
         * @cfg {String} exporterId
         * Exporter identifier. Has to be unique among other exporters when you register in in {@link Sch.plugin.Export} instance.
         */
        exporterId              : 'abstractexporter',
        /**
         * Exporter name. By default will be taken from the class {@link #l10n locale}.
         * @cfg {String}
         */
        name                    : '',

        translateURLsToAbsolute : true,

        expandAllBeforeExport   : false,

        /**
         * @cfg {String} headerTpl
         * Template of an extracted page header.
         */
        headerTpl               : '<div class="sch-export-header" style="height:{height}px; width:{width}px"><h2>{pageNo}/{totalPages}</h2></div>',

        /**
         * @cfg {String/Ext.XTemplate} tpl
         * Template of an extracted page.
         */
        tpl                     : '<!DOCTYPE html>' +
            '<html class="' + Ext.baseCSSPrefix + 'border-box {htmlClasses}">' +
            '<head>' +
            '<meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />' +
            '<title>{title}</title>' +
            '{styles}' +
            '</head>' +
            '<body class="' + Ext.baseCSSPrefix + 'webkit sch-export {bodyClasses}">' +
            '{header}' +
            '<div class="{componentClasses}" style="height:{bodyHeight}px; width:{totalWidth}px; position: relative !important">' +
            '{HTML}' +
            '</div>' +
            '{footer}' +
            '</body>' +
            '</html>',

        /**
         * @cfg {String} footerTpl
         * Template of an extracted page footer.
         */
        footerTpl               : ''

    },

    //private placeholder for provided callback functions passed in extractPages
    callbacks               : undefined,

    //private String errorMessage, when internally set this message will be displayed in a pop-up message.
    error                   : undefined,

    /**
     * @property {Array[Object]} extractedPages Collection of extracted pages.
     */
    extractedPages          : undefined,

    /**
     * @property {Number} numberOfPages Total number of pages extracted.
     */
    numberOfPages           : 0,

    constructor : function (config) {
        var me  = this;

        config  = config || {};

        me.callParent(arguments);

        // initConfig thinks that we're trying to override methods so we have to delete following
        delete config.getUserHeaderTplData;
        delete config.getUserFooterTplData;

        me.initConfig(config);

        if (!config.tableSelector) {
            me.tableSelector    = '.' + Ext.baseCSSPrefix + 'grid-item-container';
        }

        // get the exporter name from locale (if not provided explicitly)
        if (!config.name) me.setName(me.L('name'));
    },

    setHeaderTpl : function (tpl) {
        this.headerTpl = this.getTplInstance(tpl);
    },

    getHeaderTpl : function () {
       return this.headerTpl;
    },

    setTpl : function (tpl) {
        this.tpl = this.getTplInstance(tpl);
    },

    getTpl : function () {
        return this.tpl;
    },

    setFooterTpl : function (tpl) {
        this.footerTpl = this.getTplInstance(tpl);
    },

    getFooterTpl : function () {
        return this.footerTpl;
    },

    getTplInstance : function (tpl) {
        return (tpl && !tpl.isTemplate) ? new Ext.XTemplate(tpl, { disableFormats : true }) : tpl;
    },

    /**
     * @protected
     * Returns the CSS classes for BODY element of extracted page. Override this if you need to customize exported pages CSS classes.
     * @return {String} CSS classes.
     */
    getBodyClasses : function () {
        var re      = new RegExp(Ext.baseCSSPrefix + 'ie\\d?|' + Ext.baseCSSPrefix + 'gecko', 'g'),
            result  = Ext.getBody().dom.className.replace(re, '');

        if (Ext.isIE) {
            result  += ' sch-ie-export';
        }

        return result;
    },

    /**
     * @protected
     * Returns the CSS classes for element containing exported component. Override this if you need to customize exported pages CSS classes.
     * @return {String} CSS classes.
     */
    getComponentClasses : function () {
        return this.getComponent().el.dom.className;
    },

    /**
     * Sets the component being exported.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component The component being exported.
     */
    setComponent : function (component) {
        var me                  = this;

        me.component            = component;
        me.view                 = component.getSchedulingView();
        me.normalGrid           = component.normalGrid;
        me.lockedGrid           = component.lockedGrid;
        me.normalView           = component.normalGrid.view;
        me.lockedView           = component.lockedGrid.view;
        me.lockedBodySelector   = '#' + me.lockedView.getId();
        me.normalBodySelector   = '#' + me.normalView.getId();
        me.lockedHeader         = me.lockedGrid.headerCt;
        me.normalHeader         = me.normalGrid.headerCt;
        me.headerHeight         = me.normalHeader.getHeight();

        // page height w/o component headers
        me.printHeight = Math.floor(me.paperHeight) - me.headerHeight - (me.exportConfig.showHeader ? me.pageHeaderHeight : 0) - (me.exportConfig.showFooter ? me.pageFooterHeight : 0);

        me.saveComponentState(component);
    },

    /**
     * Returns the component being exported.
     * @return {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} The component being exported.
     */
    getComponent : function () {
        return this.component;
    },


    /**
     * @private
     * Applies the selected paper size based on export configuration and {@link #paperSizes} config. Calculates {@link #paperWidth} and {@link #paperHeight} properties.
     */
    setPaperSize : function (pageSize, orientation) {
        var me          = this;

        //size of paper we will be printing on. take orientation into account
        if (orientation === 'landscape') {
            me.paperWidth   = pageSize.height;
            me.paperHeight  = pageSize.width;
        } else {
            me.paperWidth   = pageSize.width;
            me.paperHeight  = pageSize.height;
        }
    },

    /**
     * @return {String} returns the format of the current export operation.
     */
    getPaperFormat : function () {
        return this.exportConfig.format;
    },


    /**
     * @private
     * Returns whether the component uses buffered rendering.
     * @return {boolean} `true` if the underlying component uses buffered rendering.
     */
    isBuffered : function () {
        return !!this.getBufferedRenderer();
    },

    /**
     * @private
     * Returns the normal grid buffered renderer instance (if the component uses buffered rendering).
     * @return {Ext.grid.plugin.BufferedRendererView} The normal grid buffered renderer instance.
     */
    getBufferedRenderer : function () {
        return this.view.bufferedRenderer;
    },

    /**
     * @protected
     * Applies the passed date range to the component.
     * @param {Object} config Export configuration.
     */
    setComponentRange : function (config) {
        var me          = this,
            component   = me.getComponent(),
            view        = me.view,
            newStart,
            newEnd;

        // if we export a part of scheduler
        if (config.range !== 'complete') {

            switch (config.range) {
                case 'date' :
                    newStart    = new Date(config.dateFrom);
                    newEnd      = new Date(config.dateTo);

                    // ensure that specified period has at least a day
                    if (Sch.util.Date.getDurationInDays(newStart, newEnd) < 1) {
                        newEnd  = Sch.util.Date.add(newEnd, Sch.util.Date.DAY, 1);
                    }

                    newStart    = Sch.util.Date.constrain(newStart, component.getStart(), component.getEnd());
                    newEnd      = Sch.util.Date.constrain(newEnd, component.getStart(), component.getEnd());
                    break;

                case 'current' :
                    var visibleSpan = view.getVisibleDateRange();
                    newStart        = visibleSpan.startDate;
                    newEnd          = visibleSpan.endDate || view.timeAxis.getEnd();

                    if (config.cellSize) {
                        // will change columns width to provided value
                        var cellSize = config.cellSize;

                        me.timeColumnWidth = cellSize[0];

                        if (me.timeColumnWidth) {
                            component.setTimeColumnWidth(me.timeColumnWidth);
                        }

                        // change the row height only if value is provided
                        if (cellSize.length > 1) {
                            me.view.setRowHeight(cellSize[1]);
                        }
                    }

                    break;
            }

            // set specified time frame
            component.setTimeSpan(newStart, newEnd);
        }

        me.ticks  = component.timeAxis.getTicks();

    },

    /**
     * @protected
     * Get links to the stylesheets of current page.
     */
    getStylesheets : function() {
        var translate   = this.translateURLsToAbsolute,
            styleSheets = Ext.getDoc().select('link[rel="stylesheet"]'),
            ctTmp       = Ext.get(Ext.core.DomHelper.createDom({
                tag : 'div'
            })),
            stylesString;

        styleSheets.each(function(s) {
            var node    = s.dom.cloneNode(true);
            // put absolute URL to node `href` attribute
            translate && node.setAttribute('href', s.dom.href);
            ctTmp.appendChild(node);
        });

        stylesString = ctTmp.dom.innerHTML + '';

        return stylesString;
    },


    // Since export is a sync operation for now, all plugins drawing lines & zones need to be temporarily adjusted
    // to draw their content synchronously.
    forEachTimeSpanPlugin : function (component, fn, scope) {
        if (Sch.feature && Sch.feature.AbstractTimeSpan) {

            var me = this;
            var plugins = (component.plugins || []).concat(component.normalGrid.plugins || []).concat(component.columnLinesFeature || []);

            for (var i = 0, l = plugins.length; i < l; i++) {
                var plugin  = plugins[i];

                if (plugin instanceof Sch.feature.AbstractTimeSpan) {
                    fn.call(scope || me, plugin);
                }
            }
        }
    },


    /**
     * @protected
     * Prepares the component to export. This includes setting requested time span, time column width etc.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component The component being exported.
     * @param {Object} config    Export configuration.
     */
    prepareComponent : function (component, config) {
        var me      = this;

        component   = component || me.getComponent();

        me.suspendInfiniteScroll(component);

        me.forEachTimeSpanPlugin(component, function (plugin) {
            plugin._renderDelay = plugin.renderDelay;
            plugin.renderDelay  = 0;
        });

        component.getSchedulingView().timeAxisViewModel.suppressFit = true;
        component.timeAxis.autoAdjust                               = false;
        //expand grids in case they're collapsed
        component.normalGrid.expand();
        component.lockedGrid.expand();

        // change timespan/tick width according to provided settings
        me.setComponentRange(config);

        // For Tree grid, optionally expand all nodes
        if (me.expandAllBeforeExport && component.expandAll) {
            component.expandAll();
        }

        // resizes the component to fit it into specified paper size (depending on pagination rules)
        me.fitComponentIntoPage();

        //IE8 bug
        if (me.isBuffered() && Ext.isIE8) {
            me.normalView.bufferedRenderer.variableRowHeight = false;
            me.lockedView.bufferedRenderer.variableRowHeight = false;
        }

    },


    restoreComponent : function (component) {
        var me      = this;

        component   = component || me.getComponent();

        me.forEachTimeSpanPlugin(component, function (plugin) {
            plugin.renderDelay  = plugin._renderDelay;
            delete plugin._renderDelay;
        });

        // restore scheduler state
        me.restoreComponentState(component);

        me.restoreInfiniteScroll(component);

        //We need to update TimeAxisModel for layout fix #1334
        // component.getSchedulingView().timeAxisViewModel.update();

        // call template method
        me.exportConfig.afterExport && me.exportConfig.afterExport(component);
    },


    saveComponentState : function (component) {
        component           = component || this.getComponent();

        var me              = this,
            view            = component.getSchedulingView(),
            normalGrid      = component.normalGrid,
            lockedGrid      = component.lockedGrid;

        //values needed to restore original size/dates of component
        me.restoreSettings    = {
            width               : component.getWidth(),
            height              : component.getHeight(),
            rowHeight           : view.timeAxisViewModel.getViewRowHeight(),
            columnWidth         : view.timeAxisViewModel.getTickWidth(),
            startDate           : component.getStart(),
            endDate             : component.getEnd(),
            normalWidth         : normalGrid.getWidth(),
            normalLeft          : normalGrid.getEl().getStyle('left'),
            lockedWidth         : lockedGrid.getWidth(),
            lockedCollapse      : lockedGrid.collapsed,
            normalCollapse      : normalGrid.collapsed,
            autoAdjust          : component.timeAxis.autoAdjust,
            suppressFit         : view.timeAxisViewModel.suppressFit,
            restoreColumnWidth  : false,
            startIndex          : view.all ? view.all.startIndex : 0
        };

    },


    restoreComponentState : function (component) {
        var me      = this;

        component   = component || me.getComponent();

        var config  = me.restoreSettings,
            view    = component.getSchedulingView();

        component.timeAxis.autoAdjust = config.autoAdjust;

        component.normalGrid.show();

        component.setWidth(config.width);
        component.setHeight(config.height);
        component.setTimeSpan(config.startDate, config.endDate);
        component.setTimeColumnWidth(config.columnWidth, true);

        view.setRowHeight(config.rowHeight);
        component.lockedGrid.show();

        component.normalGrid.setWidth(config.normalWidth);
        component.normalGrid.getEl().setStyle('left', config.normalLeft);
        component.lockedGrid.setWidth(config.lockedWidth);
        view.timeAxisViewModel.suppressFit = config.suppressFit;
        view.timeAxisViewModel.setTickWidth(config.columnWidth);

        if (config.lockedCollapse) {
            component.lockedGrid.collapse();
        }

        if (config.normalCollapse) {
            component.normalGrid.collapse();
        }

        if (me.getBufferedRenderer()) {

            me.scrollTo(config.startIndex);

            if (Ext.isIE8) {
                me.normalView.bufferedRenderer.variableRowHeight = true;
                me.lockedView.bufferedRenderer.variableRowHeight = true;
            }
        }
    },

    /**
     * Extracts the component content. On completion calls specified callback function providing an array of extracted pages as an argument.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component Component content of which to be extracted
     * @param {Object} config Configuration object. May contain the following properties:
     * @param {String} config.format Page format
     * @param {String} config.orientation Page orientation (either `portrait` or `landscape`)
     * @param {String} config.range Range of the panel to be exported. Options are `complete`, `current`, `date`. When `date` is specified there also has to be specified next two configs.
     * @param {Date} config.dateFrom Range start date. Used only when `config.range` is `date`
     * @param {Date} config.dateTo Range end date. Used only when `config.range` is `date`
     * @param {Boolean} config.showHeader Flag saying that page numbers header has to be shown
     * @param {Function} callback Function which is called after extraction of pages has completed. The callback will have the following arguments:
     * @param {Function} callback.pages An array with extracted pages
     * @param {Object} scope Scope for the callback function
     */
    extractPages : function (component, config, callback, scope) {
        var me          = this;

        // keep provided export config
        me.exportConfig = config;

        me.normalRows       = [];
        me.lockedRows       = [];
        me.extractedPages   = [];
        me.numberOfPages    = 0;
        me.lockedRowsHeight = 0;
        me.normalRowsHeight = 0;

        // calculates paper sizes based on provided parameters and DPI
        me.setPaperSize(config.pageSize, config.orientation);

        // stores references to the component, its elements and makes a backup of its pre-export state
        me.setComponent(component, config);

        // prepares component to exporting (applies provided timespan etc.)
        me.prepareComponent(component, config);

        // launch template method
        config.beforeExport && config.beforeExport(component, me.ticks);

        me.callbacks        = {
            success : callback || Ext.emptyFn,
            scope   : scope || me
        };

        // fetch all component rows into temporary arrays
        // and call 'onRowsCollected' to collect them into pages and call 'onPagesExtracted' on completion
        setTimeout(function () {
            me.collectRows(me.onRowsCollected, me);
        }, 1);
    },

    /**
     * @protected
     * Finishes exporting process. Restores the component to its initial state and returns extracted pages by calling a provided callback.
     * @param  {Array[Object]} [pages] Extracted pages. If omitted then will take collected pages from {@link #extractedPages} array.
     */
    onPagesExtracted : function (pages) {
        var me  = this;

        // restore panel to initial state
        me.restoreComponent();
        // and return results
        me.submitPages(pages);
    },


    submitPages : function (pages) {
        var me          = this,
            callbacks   = me.callbacks;

        callbacks.success.call(callbacks.scope, me.renderPages(pages));
    },


    getCurrentPage : function () {
        return this.currentPage;
    },


    setCurrentPage : function (page) {
        this.currentPage = page;
    },


    getExpectedNumberOfPages : Ext.emptyFn,


    /**
     * Commits a filled page. Pushes the page into {@link #extractedPages resulted set of pages}.
     * Calls {@link #preparePageToCommit} for the final page DOM tweaking.
     * @param [config] An optional configuration object. Will also be passed to {@link #preparePageToCommit} method.
     */
    commitPage : function (config) {

        var me      = this;

        me.numberOfPages++;

        var pageBody = me.preparePageToCommit(config);

        var page    = Ext.apply({
            html    : pageBody.dom.innerHTML,
            number  : me.numberOfPages
        }, config);

        me.extractedPages.push(page);

        me.fireEvent('commitpage', me, page, me.numberOfPages, me.getExpectedNumberOfPages());
    },

    /**
     * @protected
     * Collects the locked grid row.
     * @param  {Element} item The locked grid row
     * @param  {Ext.data.Model} recordIndex Index of the record corresponding to the row.
     * @return {Object} Object keeping reference to the cloned row element and its height.
     */
    collectLockedRow : function (item, recordIndex) {
        var height  = Ext.fly(item).getHeight();

        this.lockedRowsHeight   += height;

        var result  = {
            height : height,
            row    : item.cloneNode(true),
            record : this.lockedView.getRecord(recordIndex)
        };

        this.lockedRows.push(result);

        return result;
    },

    /**
     * @protected
     * Collects the normal grid row.
     * @param  {Element} item The normal grid row
     * @param  {Ext.data.Model} recordIndex Index of the record corresponding to the row.
     * @return {Object} Object keeping reference to the cloned row element and its height.
     */
    collectNormalRow : function (item, recordIndex) {
        var height  = Ext.fly(item).getHeight();

        this.normalRowsHeight   += height;

        var result  = {
            height : Ext.fly(item).getHeight(),
            row    : item.cloneNode(true),
            record : this.normalView.getRecord(recordIndex)
        };

        this.normalRows.push(result);

        return result;
    },


    onRowsCollected : function () {
        throw 'Sch.plugin.exporter.AbstractExporter: [onRowsCollected] Abstract method called.';
    },


    /**
     * @private
     * Iterates by calling provided function asynchronously with a delay.
     * The delay duration is specified by {@link #iterateTimeout} config.
     * @param  {Function} fn    Function implementing a single iteration step.
     * @param  {Function} fn.next Callback function to be called to run the next iteration step.
     * This will cause `fn` function launch. All arguments passed to {@link #fn.next} will be transfered to {@link #fn}.
     * @param  {[type]}   [scope] Scope for the callback function
     */
    iterateAsync : function (fn, scope) {
        var me      = this;

        scope       = scope || me;

        var next    = function () {
            var args    = arguments;

            // run iteration step asynchronously w/ delay
            var interval = setInterval(function() {
                clearInterval(interval);
                fn.apply(scope, [].concat.apply([ next ], args));
            }, me.iterateTimeout);

        };

        next.apply(me, Ext.Array.slice(arguments, 2));
    },


    callAsync : function (fn, scope) {
        scope = scope || this;

        var interval = setInterval(function() {
            clearInterval(interval);
            fn.apply(scope, Ext.Array.slice(arguments, 2));
        }, this.iterateTimeout);
    },


    /**
     * @protected
     * Collects rows from the component. Launches the provided callback and passes collected rows as its arguments.
     * @param callback {Function} The callback function when extraction of rows has finished.
     */
    collectRows : function (callback, scope) {

        var me = this;

        if (me.isBuffered()) {
            // scroll to start index before rows collecting
            setTimeout(function () {
                me.scrollTo(0, function () {
                    me.iterateAsync(me.collectRowsStep, me, 0, callback, scope);
                });
            }, 1);

        } else {
            setTimeout(function () {
                me.collectRowsStep(null, 0, callback, scope);
            }, 1);
        }
    },


    collectRowsStep : function (next, startIndex, callback, scope) {
        var me          = this,
            endIndex    = me.normalView.all.endIndex,
            count       = me.component.store.getCount(),
            normalRows  = me.normalView.all.slice(startIndex),
            lockedRows  = me.lockedView.all.slice(startIndex);

        for (var i = 0; i < lockedRows.length; i++) {
            me.collectLockedRow(lockedRows[i], startIndex + i);
        }

        for (i = 0; i < normalRows.length; i++) {
            me.collectNormalRow(normalRows[i], startIndex + i);
        }

        me.fireEvent('collectrows', me, startIndex, endIndex, count);

        if (me.isBuffered()) {

            if (endIndex + 1 < count) {
                me.callAsync(function () {
                    me.scrollTo(endIndex + 1, function () {
                        next(endIndex + 1, callback, scope);
                    });
                });

            } else {
                me.callAsync(function () {
                    me.scrollTo(0, function () {
                        callback.call(scope || me, me.lockedRows, me.normalRows);
                    });
                });
            }

        } else {
            callback.call(scope || me, me.lockedRows, me.normalRows);
        }
    },

    /**
     * @private
     * Fills extracted pages `html` property before submitting them.
     * @param  {Array} [pages] Array of pages. By default {@link #extractedPages} is used.
     * @return {Array} Array of pages.
     */
    renderPages : function (pages) {
        var me  = this;

        pages   = pages || me.extractedPages;

        for (var i = 0, l = pages.length; i < l; i++) {
            var page    = pages[i];
            page.html   = me.applyPageTpl(page);
        }

        return pages;
    },

    /**
     * @protected
     * Builds HTML content of the page by applying provided page data to the {@link #tpl page template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the page.
     */
    applyPageTpl : function (pageInfo) {
        var me  = this;
        return me.getTpl().apply(me.getPageTplData(pageInfo));
    },

    /**
     * @protected
     * Builds HTML content of the page header by applying provided page data to the {@link #headerTpl header template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the header.
     */
    applyHeaderTpl : function (pageInfo) {
        var me          = this,
            headerTpl   = me.getHeaderTpl();

        if (me.exportConfig.showHeader && headerTpl) {
            // if function was provided to alter tpl data
            var fn          = me.headerTplDataFn;
            var alterData   = fn && fn.call(me.headerTplDataFnScope || me, pageInfo);

            return headerTpl.apply(Ext.apply(me.getHeaderTplData(pageInfo), alterData));
        }

        return '';
    },

    /**
     * @protected
     * Builds HTML content of the page footer by applying provided page data to the {@link #footerTpl footer template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {String}          HTML content of the footer.
     */
    applyFooterTpl : function (pageInfo) {
        var me          = this,
            footerTpl   = me.getFooterTpl();

        if (me.exportConfig.showFooter && footerTpl) {
            // if function was provided to alter tpl data
            var fn          = me.footerTplDataFn;
            var alterData   = fn && fn.call(me.footerTplDataFnScope || me, pageInfo);

            return footerTpl.apply(Ext.apply(me.getFooterTplData(pageInfo), alterData));
        }

        return '';
    },

    /**
     * @protected
     * Function to provide data for the {@link #headerTpl} template.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object} The template data:
     * @return {Number} return.width width of the page header (page width)
     * @return {Number} return.height height of the page header
     * @return {Number} return.totalPages total number of pages
     * @return {Number} return.pageNo the page number
     */
    getHeaderTplData : function (pageInfo) {
        var me  = this;

        return {
            width       : me.paperWidth,
            height      : me.pageHeaderHeight,
            totalPages  : me.numberOfPages,
            pageNo      : pageInfo.number
        };
    },

    /**
     * @protected
     * Function to provide data for the {@link #footerTpl} template.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object} The template data:
     * @return {Number} return.width width of the page footer (page width)
     * @return {Number} return.height height of the page footer
     * @return {Number} return.totalPages total number of pages
     * @return {Number} return.pageNo the page number
     */
    getFooterTplData : function (pageInfo) {
        var me  = this;

        return {
            width       : me.paperWidth,
            height      : me.pageFooterHeight,
            totalPages  : me.numberOfPages,
            pageNo      : pageInfo.number
        };
    },

    /**
     * @protected
     * Provides data to be applied to the {@link #tpl page template}.
     * @param  {Object} pageInfo Page data:
     * @param  {Object} pageInfo.html HTML code of the page
     * @param  {Object} pageInfo.number page number
     * @return {Object}      Data to be applied to the {@link #tpl page template}.
     */
    getPageTplData : function (pageInfo) {
        var me  = this;

        return {
            bodyClasses         : me.getBodyClasses(),
            bodyHeight          : me.printHeight + me.headerHeight,
            componentClasses    : me.getComponentClasses(),
            styles              : me.getStylesheets(),
            showHeader          : me.exportConfig.showHeader,
            showFooter          : me.exportConfig.showFooter,
            header              : me.applyHeaderTpl(pageInfo),
            HTML                : pageInfo.html,
            footer              : me.applyFooterTpl(pageInfo),
            totalWidth          : me.paperWidth,
            title               : pageInfo.number + ' of ' + me.numberOfPages
        };
    },

    /**
     * @protected
     * Resizes the component to fit it into specified paper size, export settings etc. (depending on implemented pagination rules).
     */
    fitComponentIntoPage : Ext.emptyFn,

    /**
     * @private
     * Function that retrieves the table body of the locked grid.
     * @param {Ext.dom.Element} [element] The fragment root for the selector. Defaults to current page.
     * @return {Ext.dom.Element} Table body of the locked grid.
     */
    getLockedGridBody : function (element) {
        element    = element || this.getCurrentPage();

        return element.select(this.lockedBodySelector + ' > ' + this.tableSelector).first();
    },

    /**
     * @private
     * Retrieves the table body of the normal grid.
     * @param {Ext.dom.Element} [element] The root element to retrieve from. Defaults to current page.
     * @return {Ext.dom.Element} Table body of the normal grid.
     */
    getNormalGridBody : function (element) {
        element = element || this.getCurrentPage();

        return element.select(this.normalBodySelector + ' > ' + this.tableSelector).first();
    },


    emptyLockedGrid : function (element) {
        this.getLockedGridBody(element).select(this.lockedView.getItemSelector()).remove();
    },


    fillGrids : function (lockedRows, normalRows, clone, append) {
        var me  = this;

        me.fillLockedGrid(lockedRows, clone, append);
        me.fillNormalGrid(normalRows, clone, append);
    },


    fillLockedGrid : function (rows, clone, append) {
        var me  = this;
        if (!append) me.emptyLockedGrid();

        me.appendRows(me.getLockedGridBody(), rows || me.lockedRows, clone);
    },


    fillNormalGrid : function (rows, clone, append) {
        var me  = this;
        if (!append) me.emptyNormalGrid();

        me.appendRows(me.getNormalGridBody(), rows || me.normalRows, clone);
    },


    appendRows : function (node, children, clone) {
        var dom     = node.dom;
        for (var i = 0, l = children.length; i < l; i++) {
            dom.appendChild(clone ? children[i].row.cloneNode(true) : children[i].row);
        }
    },


    emptyNormalGrid : function (element) {
        this.getNormalGridBody(element).select(this.normalView.getItemSelector()).remove();
    },


    getRowHeight : function () {
        return this.view.timeAxisViewModel.getViewRowHeight();
    },


    /**
     * @private
     * Returns full width and height of both grids.
     * @return {Object} Object containing `width` and `height` properties.
     */
    getTotalSize : function() {
        return {
            width   : this.getTotalWidth(),
            height  : this.getTotalHeight()
        };
    },

    /**
     * @private
     * Returns full height of the component.
     * @return {Number} Full height of the component.
     */
    getTotalHeight : function () {
        var me  = this,
            viewHeight;

        if (me.isBuffered()) {
            viewHeight  = me.bufferedHeightMargin + me.normalRowsHeight;
        } else {
            viewHeight  = me.lockedView.getEl().down(me.tableSelector).getHeight();
        }

        return me.headerHeight + viewHeight;
    },

    /**
     * @private
     * Returns full width of the component.
     * @return {Number} Full width of both grids.
     */
    getTotalWidth : function () {
        return this.getLockedGridWidth() + this.normalGrid.body.down(this.tableSelector).getWidth();
    },


    getLockedGridWidth : function () {
        return this.lockedHeader.getEl().first().getWidth();
    },


    getNormalGridWidth : function () {
        return this.normalHeader.getEl().first().getWidth();
    },


    /**
     * @protected
     * Performs last changes to {@link #getCurrentPage the current page} being extracted before it's pushed into {@link #extractedPages} array.
     * @param {Object} [config] Optional configuration object.
     * @return {Ext.dom.Element} element Element holding the page.
     */
    preparePageToCommit : function () {
        //create empty div that will temporarily hold our panel current HTML
        var frag        = this.getCurrentPage(),
            component   = this.component,
            lockedGrid  = component.lockedGrid,
            normalGrid  = component.normalGrid;

        frag.el.select('.sch-remove').remove();

        var get             = function (s) { var el = frag.select('#' + s).first(); return el && el.dom; },
            elapseWidth     = function (el) { if (el) el.style.width  = '100%'; },
            elapseHeight    = function (el) { if (el) el.style.height = '100%'; };

        var normalBody      = frag.select(this.normalBodySelector).first();
        normalBody.dom.style.top    = '0px';

        var lockedBody      = frag.select(this.lockedBodySelector).first();
        lockedBody.dom.style.top    = '0px';

        // we elapse some elements width and/or height

        var lockedElements  = [
            get(component.id + '-targetEl'),
            get(component.id + '-innerCt'),
            get(lockedGrid.id),
            get(lockedGrid.body.id),
            get(lockedGrid.view.el.id)
        ];

        Ext.Array.forEach(lockedElements, elapseHeight);

        elapseWidth(lockedElements[0]);
        elapseWidth(lockedElements[1]);

        elapseWidth(get(normalGrid.headerCt.id));

        Ext.Array.forEach([
            get(normalGrid.id),
            get(normalGrid.body.id),
            get(normalGrid.getView().id)
        ], function(el) {
            if (el) {
                el.style.height = el.style.width = '100%';
            }
        });

        return frag;
    },


    cloneElement : function (el) {
        return new Ext.dom.Element(Ext.core.DomHelper.createDom({
            tag     : 'div',
            html    : el.dom.innerHTML
        }));
    },


    /**
     * Starts a new page. Initializes {@link #currentPage} with a copy of the component that will
     * be filled with collected rows based on implemented pagination rules.
     * @param  {Ext.dom.Element} [pattern] Element to make a copy of. This is optional by default will make a copy of {@link #getComponent the component}.
     */
    startPage : function (pattern) {
        var me      = this;

        // make a detached copy of the component body
        var copy    = me.cloneElement(pattern || me.getComponent().body);

        // and put it into storedFragment
        me.setCurrentPage(copy);
    },

    scrollTo : function (position, callback) {
        var me = this;

        if (me.component.ensureVisible) {

            var record = me.component.store.getAt(position);

            me.component.ensureVisible(record, {
                callback : function () {
                   if (callback && this.isLocked === false) {
                       callback.apply(me);
                   }
                },
                select  : false,
                focus   : false,
                animate : false
            });

        }
        else {
            me.lockedView.bufferedRenderer.scrollTo(position, false, function () {
                me.normalView.bufferedRenderer.scrollTo(position, false, callback);
            });
        }
    },

    removeNode : function (el) {
        if (el && el.parentNode) {
            el.parentNode.removeChild(el);
        }
        else {
            if (el.elements) {

                for (var i = 0; i < el.elements.length; i++) {
                    var elem = el.elements[i];
                    elem.parentNode.removeChild(elem);
                }

            }
        }
    },

    //private
    restoreInfiniteScroll : function (panel) {

        var view = panel.getSchedulingView();

        if (panel.infiniteScroll && view.rendered) {

            // restore saved time span and scroll position
            panel.timeAxis.setTimeSpan(this._oldStart, this._oldEnd);
            view.setScrollX(this._oldScrollX);

            // enable back infiniteScroll mode event listeners
            view.bindInfiniteScrollListeners();
        }
    },

    //private
    suspendInfiniteScroll : function (panel) {

        var view = panel.getSchedulingView();

        // unbind events reacting on scroll specific to infiniteScroll mode
        if (panel.infiniteScroll && view.rendered) {

            view.unbindInfiniteScrollListeners();

            // remember current time span and scroll position
            this._oldStart      = panel.timeAxis.getStart();
            this._oldEnd        = panel.timeAxis.getEnd();
            this._oldScrollX    = view.getScrollX();

            var span = panel.getEventStore().getTotalTimeSpan();
            panel.setTimeSpan(span.start, span.end);
        }
    }

});
/**
 @class Sch.plugin.exporter.SinglePage
 @extends Sch.plugin.exporter.AbstractExporter

 This class extracts all scheduler data to fit in a single page.

 The exporterId of this exporter is `singlepage`
 */


Ext.define('Sch.plugin.exporter.SinglePage', {

    extend  : 'Sch.plugin.exporter.AbstractExporter',

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - name    : 'Single page'
     */

    config  : {
        exporterId : 'singlepage',

        headerTpl   : '<div class="sch-export-header" style="height:{height}px; width:{width}px"></div>'
    },

    getExpectedNumberOfPages : function () {
        return 1;
    },

    getPaperFormat : function () {
        var me          = this,
            realSize    = me.getTotalSize(),
            dpi         = me.exportConfig.DPI,
            width       = Ext.Number.toFixed(realSize.width / dpi, 1),
            height      = Ext.Number.toFixed(realSize.height / dpi, 1);

        return width+'in*'+height+'in';
    },


    onRowsCollected : function () {
        var me = this;

        me.startPage();
        me.fillGrids();
        me.commitPage();

        me.onPagesExtracted();
    },


    getPageTplData : function () {
        var me          = this,
            realSize    = me.getTotalSize();

        return Ext.apply(me.callParent(arguments), {
            bodyHeight  : realSize.height,
            showHeader  : false,
            totalWidth  : realSize.width
        });
    },

    getHeaderTplData : function (pageInfo) {
        var me  = this;

        return {
            width       : me.getTotalWidth(),
            height      : me.pageHeaderHeight
        };
    },


    fitComponentIntoPage : function () {
        var me          = this,
            lockedGrid  = me.lockedGrid;

        lockedGrid.setWidth(lockedGrid.headerCt.getEl().first().getWidth());
    },

    preparePageToCommit : function () {
        var me          = this,
            frag        = me.callParent(arguments),
            secondaryCanvas = frag.select('.sch-secondary-canvas').first(),
            zones = secondaryCanvas.select('.sch-zone'),
            lines = secondaryCanvas.select('.sch-column-line');

        var height = me.getTotalHeight();

        secondaryCanvas.setTop(0);
        zones.setHeight(height);
        lines.setHeight(height);

        return frag;
    }

});
/**
 @class Sch.plugin.exporter.MultiPage
 @extends Sch.plugin.exporter.AbstractExporter

 This class extracts pages in a vertical and horizontal order.

 The exporterId of this exporter is `multipage`
 */

Ext.define('Sch.plugin.exporter.MultiPage', {

    extend          : 'Sch.plugin.exporter.AbstractExporter',


    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - name    : 'Multi pages'
     */

    config          : {
        exporterId  : 'multipage'
    },

    rowPageIndex    : 0,

    columnPageIndex : 0,

    pagesPerColumn  : 0,


    extractPages : function () {
        // stop garbage collecting
        this.enableGarbageCollector = Ext.enableGarbageCollector;
        Ext.enableGarbageCollector  = false;
        Ext.dom.GarbageCollector.pause();

        return this.callParent(arguments);
    },


    onRowsCollected : function (lockedRows, normalRows) {
        var me  = this;

        // reset row/column page counters
        me.rowPageIndex     = 0;
        me.columnPageIndex  = 0;
        me.pagesPerColumn   = 0;

        // - build page frame (skeleton) for each page column,
        me.buildPageFrames(function () {
            // - build pages by filling grids w/ collected rows
            me.buildPages(function () {
                // - finish exporting by launching `onPagesExtracted`
                me.onPagesExtracted.apply(me, arguments);
                // resume garbage collecting
                Ext.enableGarbageCollector = me.enableGarbageCollector;
                Ext.dom.GarbageCollector.resume();
            }, me, lockedRows, normalRows);
        });
    },

    /**
     * Builds pages using collected rows. Uses {@link #pagesFrames page frames} built by {@link #buildPageFrames} method.
     * Calls provided function on pages building completion.
     * @param  {Function} callback Function to be called on building completion.
     * @param  {Object}   [scope] Scope for the specified function. By default set to this exporter instance.
     */
    buildPages : function (callback, scope, lockedRows, normalRows) {
        var me      = this,
            frame   = me.pageFrames[0];

        // start new column page based on specified frame
        me.startPage(frame, true);

        // handle each collected row w/ `rowIteratorStep` method
        this.iterateAsync(me.rowIteratorStep, me, {
            rowIndex    : 0,
            pageFrame   : frame,
            rowsHeight  : 0,
            leftHeight  : this.printHeight,
            lockeds     : [],
            normals     : [],
            lockedRows  : lockedRows,
            normalRows  : normalRows,
            callback    : callback,
            scope       : scope || me
        });
    },

    /**
     * Processes a collected row and decides on its distribution between pages.
     * @param  {Function} next    A callback function to call to proceed w/ a next row.
     * @param  {Object}   context Processing context:
     * @param  {Object}   context.rowIndex Zero based index of the row.
     */
    rowIteratorStep : function (next, context) {

        var me          = this,
            rowIndex    = context.rowIndex,
            lockedRows  = context.lockedRows,
            normalRows  = context.normalRows,
            leftHeight  = context.leftHeight,
            lockeds     = context.lockeds,
            normals     = context.normals,
            async       = true;

        // if we have rows to handle
        if (rowIndex < lockedRows.length) {

            var lockedRow   = lockedRows[rowIndex],
                normalRow   = normalRows[rowIndex];

            // if row fits into current page
            if (lockedRow.height <= leftHeight) {
                // gather rows into temp arrays
                lockeds.push(lockedRow);
                normals.push(normalRow);

                context.leftHeight -= lockedRow.height;
                context.rowsHeight += lockedRow.height;

                async = false;

            // ..if doesn't fit
            } else {
                // flush temp arrays to fill page with gathered rows
                me.fillGrids(lockeds, normals, context.pageFrame);
                // and start a new page
                me.commitPage({ rowsHeight : context.rowsHeight });
                me.startPage( context.pageFrame );

                context.lockeds     = [ lockedRow ];
                context.normals     = [ normalRow ];
                context.leftHeight  = me.printHeight - lockedRow.height;
                context.rowsHeight  = lockedRow.height;
            }

            context.rowIndex++;

        // if we have more column pages to build
        } else if (me.columnPageIndex < me.pageFrames.length) {

            // flush temp arrays to fill page with gathered rows
            me.fillGrids(lockeds, normals, context.pageFrame);
            me.commitPage({ rowsHeight : context.rowsHeight });
            // me.columnPageIndex is 1-based so it points to the neaxt frame in me.pageFrames array
            context.pageFrame   = me.pageFrames[me.columnPageIndex];

            // start new column page based on specified frame
            me.startPage(context.pageFrame, true);

            context.leftHeight  = me.printHeight;
            context.rowsHeight  = 0;
            context.lockeds = [];
            context.normals = [];
            context.rowIndex = 0;

        // if we ran out of rows & columns then we finished
        } else {

            // flush temp arrays to fill page with gathered rows
            me.fillGrids(lockeds, normals, context.pageFrame);
            me.commitPage({ rowsHeight : context.rowsHeight });

            // run specified callback on completion
            context.callback.call(context.scope);
            return;
        }

        // handle next row
        if (async) {
            next(context);
        }
        else {
            me.rowIteratorStep(next, context);
        }
    },


    fillGrids : function (lockeds, normals, frame) {
        var me              = this,
            hasLockedGrid   = me.lockedColumnPages[me.columnPageIndex - 1],
            hasNormalGrid   = !hasLockedGrid || (hasLockedGrid && hasLockedGrid.leftWidth);

        if (hasLockedGrid) {
            me.fillLockedGrid(lockeds, true);
            me.removeHiddenLockedColumns(hasLockedGrid);
        }

        if (hasNormalGrid) {
            me.fillNormalGrid(normals, true);
            me.removeInvisibleEvents(-frame.normalGridOffset, -frame.normalGridOffset + frame.normalGridWidth);
        }
    },


    /**
     * @protected
     * Builds a page frame, a DOM-"skeleton" for a future pages.
     * @param  {Number} colIndex Zero based index of page column to build frame for.
     * @param  {Number} offset   Proper normal grid offset for the page column.
     * @return {Ext.dom.Element} Column page frame.
     */
    buildPageFrame : function (colIndex, offset) {
        var me          = this,
            lockedCols  = me.lockedColumnPages[ colIndex ];

        // if this page column has locked grid
        if (lockedCols) {
            me.lockedGrid.setWidth( me.showLockedColumns(lockedCols.start, lockedCols.end) + (lockedCols.startOffset || 0) );

            // if there is some room after locked grid let's show normal grid
            if (lockedCols.leftWidth) {
                me.normalGrid.show();
            // otherwise we hide normal grid
            } else {
                me.normalGrid.hide();
            }

        // if no locked grid on the page
        } else {
            me.lockedGrid.setWidth(0);
            me.lockedGrid.hide();
            me.normalGrid.show();
        }

        // now after we set locked columns/grid and normal grid visibility
        // we clone the content of the component
        var copy    = me.cloneElement(me.getComponent().body);

        copy.normalGridOffset   = offset;
        copy.lockedGridOffset   = lockedCols && lockedCols.startOffset || 0;
        copy.normalGridWidth    = me.normalGrid.getWidth();
        copy.lockedGridWidth    = me.lockedGrid.getWidth();

        // do some CSS-tweaks to shift locked grid
        copy.select(me.lockedBodySelector).first().dom.style.position   = '';
        copy.select('#' + me.lockedView.id).first().dom.style.overflow  = 'visible';

        // if normal grid is visible on this column page
        // do some CSS-tweaks to place normal grid to show only this page content
        if (!me.normalGrid.hidden) {
            var table   = copy.select(me.normalBodySelector).first();
            table.dom.style.position    = '';
            table.dom.style.top         = '0px';

            var body            = me.getNormalGridBody(copy);
            var header          = copy.select('#' + me.normalView.headerCt.id).first();
            var secondaryCanvas = copy.select('.sch-secondary-canvas').first();
            var view            = copy.select('#' + me.normalView.id).first();

            body.dom.style.left             = offset + 'px';
            header.dom.style.left           = offset + 'px';
            header.dom.style.overflow       = 'visible';
            secondaryCanvas.dom.style.left  = offset + 'px';
            view.dom.style.overflow         = 'visible';
        }

        return copy;
    },

    /**
     * @protected
     * Builds column page frames.
     * @param  {Function} callback A callback function to call on completion
     * @param  {Array[Ext.dom.Element]} callback.pageFrames An array of page frames built
     * @param  {[type]}   scope    A scope for the specified callback function
     */
    buildPageFrames : function (callback, scope) {
        var me                  = this;

        scope                   = scope || me;

        // markup locked columns ranges for page columns
        me.lockedColumnPages    = me.calculateLockedColumnPages();

        var columnPagesNum      = Math.ceil(me.getTotalWidth() / me.paperWidth),
            pageFrames          = me.pageFrames = [];

        me.iterateAsync(function (next, colIndex, offset) {
            // on build completion we call provided function
            if (colIndex >= columnPagesNum) {
                callback.call(scope, pageFrames);
                return;
            }

            pageFrames.push( me.buildPageFrame(colIndex, offset) );

            var lockedCols  = me.lockedColumnPages[ colIndex ];

            // adjust normal grid offset for the next page column
            if (lockedCols) {
                offset -= lockedCols.leftWidth || 0;
            } else {
                offset -= me.paperWidth;
            }

            // let's build frame for next page column
            next(colIndex + 1, offset);

        }, me, 0, 0);
    },


    startPage : function (pattern, newColumnPage) {
        var me  = this;

        if (newColumnPage) {
            // on the very first page commit step we know the exact number of row pages
            // let's keep that value
            if (me.columnPageIndex == 1) {
                me.pagesPerColumn = me.extractedPages.length;
            }
            me.rowPageIndex   = 0;
            me.columnPageIndex++;
        }

        me.rowPageIndex++;

        me.callParent(arguments);

        me.emptyNormalGrid();
        me.emptyLockedGrid();
    },


    commitPage : function (cfg) {
        var me  = this;
        me.callParent([ Ext.apply({ row : me.rowPageIndex, column : me.columnPageIndex }, cfg) ]);
    },


    getExpectedPagesPerColumn : function () {
        return this.pagesPerColumn || Math.ceil((this.lockedRowsHeight || this.component.store.count() * this.component.getRowHeight()) / this.printHeight);
    },


    getExpectedColumnsNumber : function () {
        return this.pageFrames ? this.pageFrames.length : Math.ceil((this.lockedGrid.getWidth() + this.ticks.length * this.view.timeAxisViewModel.getTickWidth()) / this.paperWidth);
    },


    getExpectedNumberOfPages : function () {
        return this.getExpectedColumnsNumber() * this.getExpectedPagesPerColumn();
    },


    /**
     * @protected
     * Calculates which locked columns belong to which page.
     * @return {Array[Object]} Array of object
     */
    calculateLockedColumnPages : function () {
        var me          = this,
            result      = [],
            columns     = me.lockedColumns,
            leftWidth   = me.paperWidth,
            page;

        for (var i = 0, l = columns.length; i < l; i++) {
            var column  = columns[i],
                width   = column.width;

            page        = page || { start : i, end : i };
            leftWidth   -= width;

            // if column violated page width
            if (leftWidth < 0) {
                // push page
                result.push(page);

                if (leftWidth) {
                    page    = { start : i, end : i };
                }

                leftWidth   = me.paperWidth - width + leftWidth;
            } else {
                page.end = i;
            }

/*
            // support for columns sharing between pages

            page        = page || { start : i };
            page.end    = i;
            leftWidth   -= width;

            // if column violated page width
            if (leftWidth <= 0) {
                // push page
                result.push(page);
                // if the column was split next page will start from it w/ corresponding offset
                if (leftWidth) {
                    page    = {
                        start       : i,
                        end         : i,
                        startOffset : leftWidth
                    };
                } else {
                    page    = null;
                }

                leftWidth   = me.paperWidth - width + leftWidth;
            }
*/
        }

        // if we have unpushed column page
        if (page) {
            page.leftWidth  = leftWidth;
            result.push(page);
        }

        return result;
    },


    getPageTplData : function (data) {
        return Ext.apply(this.callParent(arguments), {
            title : data.number + ' of ' + this.numberOfPages + ' (column: ' + data.column + ', row: ' + data.row + ')'
        });
    },


    showLockedColumns : function (startColumn, endColumn) {
        var me      = this,
            columns = me.lockedColumns,
            width   = 0;

        startColumn = startColumn || 0;
        endColumn   = endColumn || columns.length - 1;

        for (var i = 0; i < columns.length; i++) {

            var column = columns[i];

            if (i >= startColumn && i <= endColumn) {
                column.column.show();
                width += column.width;
            } else {
                column.column.hide();
            }
        }

        return width;
    },


    removeInvisibleEvents : function (leftBorder, rightBorder) {
        var me          = this,
            normalBody  = me.getNormalGridBody(),
            eventCls    = me.normalView.eventCls;

        var elements = normalBody.select('.' + eventCls).elements;

        for (var i = 0; i < elements.length; i++) {

            var start   = parseInt(elements[i].style.left, 10),
                end     = start + parseInt(elements[i].style.width, 10);

            if (end < leftBorder || start > rightBorder) {
                me.removeNode(elements[i]);
            }
        }
    },

    removeHiddenLockedColumns : function (lockedGrid) {
        var me = this,
            page = me.getCurrentPage(),
            tableBody = me.getLockedGridBody();

        for (var i = 0; i < me.lockedColumns.length; i++ ) {
            var column = me.lockedColumns[i].column;

            if ( i < lockedGrid.start || i > lockedGrid.end) {
                var headerSelector = '#' + column.getId();
                var header = page.select(headerSelector);
                me.removeNode(header);

                var cellSelector = column.getCellSelector();
                var cells = tableBody.select(cellSelector);
                me.removeNode(cells);
            }
        }
    },


    fitComponentIntoPage : function () {
        var me  = this;

        me.getComponent().setWidth(me.paperWidth);
    },


    restoreComponentState : function () {
        this.callParent(arguments);
        // restore locked columns visibility
        this.showLockedColumns();
    },


    setComponent : function () {
        var me      = this,
            columns = me.lockedColumns = [];

        me.callParent(arguments);

        // keep visible locked columns data
        me.lockedGrid.headerCt.items.each(function (column) {
            if (!column.hidden) {
                columns.push({
                    column  : column,
                    width   : column.getWidth()
                });
            }
        });
    }

});
/**
 @class Sch.plugin.exporter.MultiPageVertical
 @extends Sch.plugin.exporter.AbstractExporter

  This class extracts pages in a vertical order. It fits all locked columns and the timeaxis on a single page and will generate
  new pages vertically down for the rows.

  The exporterId of this exporter is `multipagevertical`

  To adjust column widths for specific export cases the function {@link #fitLockedColumnWidth} can be overridden.

*/

Ext.define('Sch.plugin.exporter.MultiPageVertical', {

    extend              : 'Sch.plugin.exporter.AbstractExporter',

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - name    : 'Multi pages (vertically)'
     */

    config              : {
        exporterId  : 'multipagevertical'
    },


    minRowHeight        : 20,

    visibleColumns      : null,

    visibleColumnsWidth : 0,

    onRowsCollected : function (lockedRows, normalRows) {
        var me          = this;

        me.iterateAsync(function (next, rowIndex) {

            if (rowIndex === lockedRows.length) {
                me.onPagesExtracted();
                return;
            }

            var index       = rowIndex,
                spaceLeft   = me.printHeight,
                rowsHeight  = 0,
                lockeds     = [],
                normals     = [],
                normal,
                newPage     = false;

            me.startPage();

            while (!newPage && index < lockedRows.length) {

                normal      = normalRows[index];
                spaceLeft   -= normal.height;

                if (spaceLeft > 0) {
                    rowsHeight  += normal.height;
                    lockeds.push(lockedRows[index]);
                    normals.push(normal);
                    index++;
                }
                else {
                    newPage = true;
                }
            }

            me.fillGrids(lockeds, normals);
            me.commitPage({ rowIndex : index, rowsHeight : rowsHeight });

            next( index );

        }, me, 0);
    },


    startPage : function () {
        var me      = this;
        me.callParent(arguments);

        var view    = me.getCurrentPage().select('#' + me.lockedView.id).first();
        view.dom.style.overflow = 'visible';
    },


    getExpectedNumberOfPages : function () {
        return Math.ceil(this.lockedRowsHeight / this.printHeight);
    },


    setComponent : function () {
        var me                  = this,
            visibleColumns      = me.visibleColumns = [];

        me.callParent(arguments);

        me.visibleColumnsWidth  = 0;

        me.lockedGrid.headerCt.items.each(function (column) {
            if (!column.hidden) {
                visibleColumns.push({
                    column  : column,
                    width   : column.getWidth()
                });

                me.visibleColumnsWidth += column.getWidth();
            }
        });

    },


    fitComponentIntoPage : function () {
        var me              = this,
            component       = me.getComponent(),
            normalGrid      = component.normalGrid,
            lockedGrid      = component.lockedGrid,
            totalWidth      = me.getTotalWidth(),
            ticks           = me.ticks,
            timeColumnWidth = me.timeColumnWidth || me.restoreSettings.columnWidth;

        var lockedWidth = Math.floor((me.visibleColumnsWidth / totalWidth) * me.paperWidth);
        var normalWidth = Math.floor((ticks.length * timeColumnWidth / totalWidth) * me.paperWidth);
        var tickWidth   = Math.floor(normalWidth / ticks.length);
        var rowHeight   = (tickWidth / timeColumnWidth) * me.getRowHeight();

        me.view.setRowHeight( rowHeight < me.minRowHeight ? me.minRowHeight : rowHeight );

        component.setWidth(me.paperWidth);
        normalGrid.setWidth(normalWidth);
        lockedGrid.setWidth(lockedWidth);

        me.fitLockedColumnWidth(lockedWidth);

        component.setTimeColumnWidth(tickWidth);
    },


    /**
     * Function that fits locked columns based on the available width.
     *
     * @param {String} totalWidth int indicating the totalWidth available for the locked columns.
     */

    fitLockedColumnWidth : function (totalWidth) {
        var visibleColumns = this.visibleColumns;

        if (visibleColumns.length) {

            var width = totalWidth / visibleColumns.length;

            for (var i = 0; i < visibleColumns.length; i++) {
                visibleColumns[i].column.setWidth(width);
            }

            this._restoreColumnWidth = true;
        }
    },


    restoreComponentState : function () {

        this.callParent(arguments);

        if (this._restoreColumnWidth) {

            var visibleColumns = this.visibleColumns;

            for (var i = 0; i < visibleColumns.length; i++) {
                var cWrap = visibleColumns[i];
                cWrap.column.setWidth(cWrap.width);
                cWrap.column.show();
            }
        }
    }

});
/**
 @class Sch.plugin.Export
 @extends Ext.util.Observable

 A plugin (ptype = 'scheduler_export') for generating PDF/PNG out of a scheduler panel. NOTE: This plugin will make an AJAX request to the server, POSTing
 the HTML to be exported. The {@link #printServer} URL must therefore be on the same domain as your application.

 ##Configuring/usage

 To use this plugin, add it to your scheduler as any other plugin. It is also required to have [PhantomJS][1] and [Imagemagick][2]
 installed on the server. The complete process of setting up a backend for this plugin can be found in the readme file inside export examples
 as well as on our [blog][3]. Note that export is currently not supported if your view (or store) is buffered.

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Export', {
                    // default values
                    printServer: 'server.php'
                })
            ]
        });

 The Scheduler instance will be extended with two new methods:

* {@link #showExportDialog}, which shows export settings dialog

        scheduler.showExportDialog();

* {@link #doExport} which actually performs the export operation using {@link #exportConfig} or provided config object :

        scheduler.doExport({
            format      : "A5",
            orientation : "landscape",
            range       : "complete",
            showHeader  : true,
            exporterId  : "singlepage"
        });


##Export options

 In the current state, plugin gives few options to modify the look and feel of the generated PDF document throught a dialog window :

 {@img scheduler/images/export_dialog.png}

If no changes are made to the form, the {@link #exportConfig} will be used.

###Export Range

 This setting controls the timespan visible on the exported document. Three options are available here :

 {@img scheduler/images/export_dialog_ranges.png}

####Complete schedule

 Whole current timespan will be visible on the exported document.

####Date range

 User can select the start and end dates (from the total timespan of the panel) visible on the exported document.

 {@img scheduler/images/export_dialog_ranges_date.png}

####Current view

 Timespan of the exported document/image will be set to the currently visible part of the time axis. User can control
 the width of the time column and height of row.

 {@img scheduler/images/export_dialog_ranges_current.png}

##Page number

 To add a page number is the header

 {@img scheduler/images/export_page_number.png}


##Export mode

 Choose an exporter. The default exporter is `Multi pages`.

 {@img scheduler/images/export_modes.png}

 Options:

-  `Single page`. Creates an export that fits one single page.

-  `Multi pages`. Creates an export that creates pages in both vertical and horizontal direction.

-  `Multi pages (vertical)`. Creates an export that creates pages in vertical direction.


##Paper Format

 This combo gives control of the size of the generated document/image by choosing one from a list of supported ISO paper sizes : (`A5`, `A4`, `A3`, `Letter`).
 Generated PDF has a fixed DPI value of 72. Dafault format is `A4`.

 {@img scheduler/images/export_dialog_format.png}

###Orientation

 This setting defines the orientation of the generated document/image.

 {@img scheduler/images/export_dialog_orientation.png}

 Default option is the `portrait` (horizontal) orientation :

 {@img scheduler/images/export_dialog_portrait.png}

 Second option is the `landscape` (vertical) orientation :

 {@img scheduler/images/export_dialog_landscape.png}

 ##Custom export styling
 A special "sch-export" CSS class is added to the body of the exported pages so that you can have special
 styles in your exported chart.

 [1]: http://www.phantomjs.org
 [2]: http://www.imagemagick.org
 [3]: http://bryntum.com/blog

 */
Ext.define('Sch.plugin.Export', {
    extend                  : 'Ext.util.Observable',

    alternateClassName      : 'Sch.plugin.PdfExport',

    alias                   : 'plugin.scheduler_export',

    mixins                  : ['Ext.AbstractPlugin', 'Sch.mixin.Localizable'],

    requires        : [
        'Ext.XTemplate',
        'Sch.plugin.exporter.SinglePage',
        'Sch.plugin.exporter.MultiPage',
        'Sch.plugin.exporter.MultiPageVertical'
    ],

    lockableScope           : 'top',

    /**
     * @cfg {Object} pageSizes
     * Definition of all available paper sizes.
     */
    pageSizes               : {
        A5      : {
            width   : 5.8,
            height  : 8.3
        },
        A4      : {
            width   : 8.3,
            height  : 11.7
        },
        A3      : {
            width   : 11.7,
            height  : 16.5
        },
        Letter  : {
            width   : 8.5,
            height  : 11
        },
        Legal   : {
            width   : 8.5,
            height  : 14
        }
    },


    /**
     * @cfg {Number} DPI
     * DPI (Dots per inch) resolution.
     */
    DPI                     : 72,

    /**
     * @cfg {String}
     * URL of the server responsible for running the export steps.
     */
    printServer             : undefined,


    /**
     * @cfg {Number}
     * The timeout in milliseconds to be used for print requests to server.
     */
    timeout                 : 60000,


    /**
     * @cfg {String} headerTpl
     * Template of extracted page header.
     */
    headerTpl               : null,

    /**
     * @cfg {Function} headerTplDataFn
     * If defined provides data for the {@link #headerTpl}.
     * To define the scope please use {@link #headerTplDataFnScope}.
     * @return {Object} Header template data.
     */
    headerTplDataFn        : null,

    /**
     * @cfg {Object} headerTplDataFnScope Scope for the {@link #headerTplDataFn} function.
     */
    headerTplDataFnScope   : null,

    /**
     * @cfg {String} tpl
     * Template of extracted page.
     */
    tpl                     : null,

    /**
     * @cfg {String} footerTpl
     * Template of extracted page footer.
     */
    footerTpl               : null,

    /**
     * @cfg {Function} footerTplDataFn
     * If defined provides data for the {@link #footerTpl}.
     * To define the scope please use {@link #footerTplDataFnScope}.
     * @return {Object} Footer template data.
     */
    footerTplDataFn        : null,

    /**
     * @cfg {Object} footerTplDataFnScope Scope for the {@link #footerTplDataFn} function.
     */
    footerTplDataFnScope   : null,

    /**
     * @cfg {String}
     * Class name of the dialog used to change export settings.
     */
    exportDialogClassName   : 'Sch.widget.ExportDialog',

    /**
     * @cfg {Object}
     * Config object for the {@link #exportDialogClassName}. Use this to override default values for the export dialog.
     */
    exportDialogConfig      : {},

    /**
     * @cfg {Object}
     * Config object to apply to each {@link Sch.plugin.exporter.AbstractExporter exporter} being registered.
     */
    exporterConfig          : null,

    /**
     * @cfg {Object}
     * Default export configuration.
     */
    exportConfig           : {
        format              : "A4",
        orientation         : "portrait",
        range               : "complete",
        showHeader          : true,
        showFooter          : false
    },

    /**
     * @cfg {Boolean} expandAllBeforeExport Only applicable for tree views, set to true to do a full expand prior to the export. Defaults to false.
     */
    expandAllBeforeExport   : false,

    /**
     * @cfg {Boolean} translateURLsToAbsolute `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.
     */
    translateURLsToAbsolute : true,

    /**
     * @cfg {Boolean}
     * If set to true, open new window with the generated document after the operation has finished.
     */
    openAfterExport         : true,

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * before the export plugin extracts data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @param {Object[]} ticks The ticks gathered by plugin to export.
     * @template
     * @method beforeExport
     */
    beforeExport            : Ext.emptyFn,

    /**
     * An empty function by default, but provided so that you can perform a custom action
     * after the export plugin has extracted the data from the scheduler.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler instance
     * @template
     * @method afterExport
     */
    afterExport             : Ext.emptyFn,



    /**
     * @cfg {String}
     * Format of the exported file, selectable from `pdf` or `png`. By default plugin exports panel contents to PDF
     * but PNG file format is also available.
     */
    fileFormat              : 'pdf',

    /**
     * @cfg {String}
     * The exporterId of the default exporter to be used.
     * The corresponding export mode will be selected in {@link Sch.widget.ExportDialog export dialog} by default.
     */
    defaultExporter         : 'multipage',

    /**
     * @cfg {Array[Sch.plugin.exporter.AbstractExporter/Object]}
     * The list of available exporters.
     * If no value is provided the list will be filled automatically (see {@link #buildExporters}).
     */
    exporters               : undefined,

    callbacks               : undefined,

    /**
     * @event hidedialogwindow
     * Fires to hide the dialog window.
     * @param {Object} response Full server response.
     */

    /**
     * @event showdialogerror
     * Fires to show error in the dialog window.
     * @param {Ext.window.Window} dialog The dialog used to change export settings.
     * @param {String} message Error message to show in the dialog window.
     * @param {Object} response Full server response.
     */

    /**
     * @event updateprogressbar
     * Fires when a progressbar of the {@link #exportDialogClassName dialog} should update it's value.
     * @param {Number} value Value (between 0 and 1) to set on the progressbar.
     * @param {Object} [response] Full server response. This argument is specified only when `value` equals to `1`.
     */

    /**
     * @event beforeexport
     * Fires before the exporting is started. Return `false` to cancel exporting.
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} component A scheduler panel to be exported.
     * @param {Object} config Export configuration.
     */

    constructor : function (config) {
        var me              = this;

        config              = config || {};

        me.exportersIndex   = {};

        if (config.exportDialogConfig) {
            Ext.Object.each(this.exportConfig, function (k, v, o) {
                var configK = config.exportDialogConfig[k];
                if (configK) {
                    o[k] = configK;
                }
            });
        }

        me.callParent([ config ]);

        me.setFileFormat(me.fileFormat);

        // if no exporters specified let's set the list of available by default
        if (!me.exporters) {
            me.exporters    = me.buildExporters();
        }

        // instantiate exporters instances in case there were provided just objects w/ xclass
        me.initExporters();

        // listen to exporters events
        me.bindExporters();
    },

    init : function (scheduler) {
        var me                      = this;

        scheduler.showExportDialog  = Ext.Function.bind(me.showExportDialog, me);
        scheduler.doExport          = Ext.Function.bind(me.doExport, me);

        me.scheduler                = scheduler;
    },


    initExporters : function () {
        var me          = this,
            exporters   = me.exporters;

        for (var i = 0; i < exporters.length; i++) {
            if (!(exporters[i] instanceof Sch.plugin.exporter.AbstractExporter)) {
                exporters[i]    = me.createExporter(exporters[i]);
            }
        }
    },


    bindExporters : function () {
        var exporters   = this.exporters;

        for (var i = 0; i < exporters.length; i++) {
            this.bindExporter(exporters[i]);
        }
    },


    bindExporter : function (exporter) {
        var me  = this;

        me.mon(exporter, {
            commitpage  : me.onPageCommit,
            collectrows : me.onRowCollected,
            scope       : me
        });

    },


    unbindExporter : function (exporter) {
        var me  = this;

        me.mun(exporter, {
            commitpage  : me.onPageCommit,
            collectrows : me.onRowCollected,
            scope       : me
        });

    },


    /**
     * @protected
     * Provides the list of available exporter instances.
     * This method is used to build the default state of the list when no {@link #exporters} provided.
     * @returns {Array[Sch.plugin.exporter.AbstractExporter]} List of exporters.
     */
    buildExporters : function () {
        return [ 'Sch.plugin.exporter.SinglePage', 'Sch.plugin.exporter.MultiPage', 'Sch.plugin.exporter.MultiPageVertical' ];
    },

    /**
     * @protected
     * Returns config for an exporter being initialized.
     * Override this to provide custom options for exporters being created.
     */
    getExporterConfig : function (className, config) {
        var me      = this;

        var result  = Ext.apply({
            translateURLsToAbsolute : me.translateURLsToAbsolute,
            expandAllBeforeExport   : me.expandAllBeforeExport,
            DPI                     : me.DPI
        }, me.exporterConfig);

        if (me.headerTpl) result.headerTpl  = me.headerTpl;

        if (me.headerTplDataFn) {
            result.headerTplDataFn          = me.headerTplDataFn;
            result.headerTplDataFnScope     = me.headerTplDataFnScope;
        }

        if (me.tpl) result.tpl              = me.tpl;
        if (me.footerTpl) result.footerTpl  = me.footerTpl;

        if (me.footerTplDataFn) {
            result.footerTplDataFn          = me.footerTplDataFn;
            result.footerTplDataFnScope     = me.footerTplDataFnScope;
        }

        return result;
    },


    // @protected
    createExporter : function (className, config) {
        var me              = this,
            exporterConfig  = me.getExporterConfig(className, config);

        if (Ext.isObject(className)) {
            return Ext.create(Ext.apply(exporterConfig, className));
        } else {
            return Ext.create(className, Ext.apply(exporterConfig, config));
        }
    },


    /**
     * Adds an exporter.
     * @param  {Sch.plugin.exporter.AbstractExporter/String} [exporter] An exporter to add.
     * Might be provided as {@link Sch.plugin.exporter.AbstractExporter} instance or as a class name string plus a configuration object:
     *
     *   plugin.registerExporter('MyExporter', { foo : 'bar' });
     *
     * Can be ommited to use configuration object only:
     *
     *   plugin.registerExporter({ xclass : 'MyExporter', foo : 'bar' });
     *
     * @param  {Object} [config]    A configuration object
     */
    registerExporter : function (exporter, config) {
        if (!(exporter instanceof Sch.plugin.exporter.AbstractExporter)) {
            exporter    = this.createExporter.apply(this, arguments);
        }

        this.exporters.push(exporter);

        this.bindExporter(exporter);
    },


    /**
     * Function that returns an exporter instance based on provided exporterId.
     *
     * @param {String} exporterId string indicating the registered exporter.
     *
     * @return {Sch.plugin.exporter.AbstractExporter} an instance of the exporter.
     */
    getExporter : function (exporterId) {
        if (!exporterId) return;

        var result  = this.exportersIndex[exporterId];
        if (result) return result;

        result      = this.exportersIndex[exporterId] = Ext.Array.findBy(this.exporters, function (i) {
            return i.getExporterId() == exporterId;
        });

        return result;
    },

    /**
     * Function that returns all registered exporters.
     *
     * @return {Object} an Object containing registered exporters.
     */
    getExporters : function () {
        return this.exporters;
    },

    /**
     * Function for setting the {@link #fileFormat} of exporting panel. Can be either `pdf` or `png`.
     *
     * @param {String} format format of the file to set. Can take either `pdf` or `png`.
     */
    setFileFormat : function (format) {
        if (typeof format !== 'string') {
            this.fileFormat = 'pdf';
        } else {
            format = format.toLowerCase();

            if (format === 'png') {
                this.fileFormat = format;
            } else {
                this.fileFormat = 'pdf';
            }
        }
    },

    /**
     * Instantiates and shows a new {@link #exportDialogClassName} class using {@link #exportDialogConfig} config.
     * This popup should give user possibility to change export settings.
     */
    showExportDialog : function() {
        var me   = this,
            view = me.scheduler.getSchedulingView();

        //dialog window is always removed to avoid resetting its layout after hiding
        if (me.win) {
            me.win.destroy();
            me.win = null;
        }

        me.win  = Ext.create(me.exportDialogClassName, {
            plugin                  : me,
            exportDialogConfig      : Ext.apply({
                startDate       : me.scheduler.getStart(),
                endDate         : me.scheduler.getEnd(),
                rowHeight       : view.timeAxisViewModel.getViewRowHeight(),
                columnWidth     : view.timeAxisViewModel.getTickWidth(),
                defaultExporter : me.defaultExporter,
                exporters       : me.exporters,
                exportConfig    : me.exportConfig
            }, me.exportDialogConfig)
        });

        me.win.show();
    },


    getExportConfig : function (config) {
        var me      = this;

        var result      = Ext.apply({
            fileFormat      : me.fileFormat,
            exporterId      : me.defaultExporter,
            beforeExport    : Ext.Function.bind(me.beforeExport, me),
            afterExport     : Ext.Function.bind(me.afterExport, me)
        }, config, me.exportConfig);

        // get effective DPI
        result.DPI              = result.DPI || me.DPI;
        // get page size for provided paper format
        result.pageSize         = Ext.apply({}, me.pageSizes[result.format]);
        // covert page size to pixels
        result.pageSize.width   *= result.DPI;
        result.pageSize.height  *= result.DPI;

        return result;
    },


    /**
     * Function performing the export operation using provided config. After getting data
     * from the scheduler an XHR request to {@link #printServer} will be made with the following JSON encoded data :
     *
     * * `html`        - array of HTML strings containing data of each page
     * * `format`      - paper size of the exported file
     * * `orientation` - orientation of the exported file
     * * `range`       - range of the exported file
     * * `fileFormat`  - file format of the exported file
     *
     * @param {Object} [conf] Config options for exporting. If not provided, {@link #exportConfig} is used. Possible parameters are :
     * @param {String} [conf.format]            - format of the exported document/image, selectable from the {@link #pageSizes} list.
     * @param {String} [conf.orientation]       - orientation of the exported document/image. Either `portrait` or `landscape`.
     * @param {String} [conf.range]             - range of the panel to be exported. Selectable from `complete`, `current`, `date`.
     * @param {Boolean} [conf.showHeader]       - boolean value defining if exported pages should have row/column numbers added in the headers.
     * @param {String} [conf.exporterId]        - string value defining which exporter to use.
     *
     * @param {Function} [callback] Optional function that will be called after successful response from export backend script.
     * @param {Function} [errback] Optional function that will be called if export backend script returns error.
     */
    doExport : function (conf, callback, errback, scope) {

        var me          = this,
            component   = me.scheduler,
            config      = me.getExportConfig(conf);

        me.callbacks     = {
            success     : callback || Ext.emptyFn,
            failure     : errback || Ext.emptyFn,
            scope       : scope || me
        };

        var exporter    = me.exporter = me.getExporter(config.exporterId);

        // if we have exporter
        if (exporter && me.fireEvent('beforeexport', component, exporter, config) !== false) {

            me.mask();

            me.exporter.extractPages(component, config, function (pages) {

                me.fireEvent('updateprogressbar', 0.8, this.L('requestingPrintServer'));

                me.doRequest(pages, config);

            }, me);
        }
    },


    onRowCollected : function (exporter, startIndex, endIndex, total) {
        this.fireEvent('updateprogressbar', 0.2 * (endIndex + 1) / total, Ext.String.format(this.L('fetchingRows'), endIndex + 1, total));
    },


    onPageCommit : function (exporter, page, pageNum, total) {
        total   = Math.max(pageNum, total);
        this.fireEvent('updateprogressbar', 0.2 + 0.6 * pageNum / total, Ext.String.format(this.L('builtPage'), pageNum, total));
    },


    /**
     * @private
     * Function that is called when the exportserver returned success. This function will fire the events updateprogressbar and hidedialogwindow.
     * When provided in doExport the callback success function is called.
     * The exported file will be dialogged when the @openAfterExport property is set to true (default).
     */

    onExportSuccess : function (result) {
        var me          = this,
            win         = me.getWin(),
            callbacks   = me.callbacks,
            fn          = callbacks && callbacks.success,
            scope       = callbacks && callbacks.scope || me;

        //set progress to 100%
        me.fireEvent('updateprogressbar', 1);

        me.unmask();

        fn && fn.apply(scope, arguments);

        setTimeout(function() {
            me.fireEvent('hidedialogwindow', result);

            if (me.openAfterExport) {
                window.open(result.url, 'ExportedPanel');
            }

        }, win ? win.hideTime : 3000);
    },

    /**
     * @private
     * Function that is called when the exportserver returned failure. This function will fire the event showdialogerror.
     * When provided in doExport the callback failure is called.
     *
     * @param {String} message Error message provided with the failure.
     * @param {Object} Response object when the failure is a serverside failure.
     */

    onExportFailure : function (message, result) {
        var me          = this,
            win         = this.getWin(),
            callbacks   = me.callbacks,
            fn          = callbacks && callbacks.failure,
            scope       = callbacks && callbacks.scope || me;

        fn && fn.call(scope, message);

        me.fireEvent('showdialogerror', win, message, result);

        me.unmask();
    },


    /**
     * @protected
     * Launches a request to the {@link #printServer print server}.
     * On return {@link #onRequestSuccess} or {@link #onRequestFailure} will be called with the returned response.
     * @param {Array} exportedPages An array of paginated component content.
     * @param {Object} config Export configuratin.
     */
    doRequest : function (exportedPages, config) {

        var me          = this,
            component   = me.scheduler;

        if (!me.test && !me.debug) {

            if (me.printServer) {

                var ajaxConfig = {
                    type        : 'POST',
                    url         : me.printServer,
                    timeout     : me.timeout,
                    params      : Ext.apply({
                        html        : {
                            array : Ext.JSON.encode(exportedPages)
                        },
                        startDate   : component.getStartDate(),
                        endDate     : component.getEndDate(),
                        format      : me.exporter.getPaperFormat(),
                        orientation : config.orientation,
                        range       : config.range,
                        fileFormat  : me.fileFormat
                    }, this.getParameters()),
                    success     : me.onRequestSuccess,
                    failure     : me.onRequestFailure,
                    scope       : me
                };

                Ext.apply(ajaxConfig, this.getAjaxConfig(ajaxConfig));

                Ext.Ajax.request(ajaxConfig);

            } else {
                me.onExportFailure('Print server URL is not defined, please specify printServer config');
            }

        } else {

            if (me.debug) {
                var pages   = exportedPages || [];

                for (var i = 0, l = pages.length; i < l; i++) {
                    var w = window.open();

                    w.document.write(pages[i].html);
                    w.document.close();
                }
            }

            me.onExportSuccess(me.testResponse || { success : true, url : 'foo', htmlArray : exportedPages });
        }
    },

    /**
     * @protected
     * Runs on request succesful completion.
     * @param  {Object} response Server response.
     */
    onRequestSuccess : function (response) {
        var me  = this,
            result;

        try {
            result = Ext.JSON.decode(response.responseText);
        } catch (e) {
            me.onExportFailure('Wrong server response received');
            return;
        }

        if (result.success) {
            me.onExportSuccess(result);

        } else {
            me.onExportFailure(result.msg, result);
        }
    },

    /**
     * @protected
     * Runs on request failure.
     * @param  {Object} response Server response.
     */
    onRequestFailure : function (response) {
        var me  = this,
            msg = response.status === 200 ? response.responseText : response.statusText;

        me.onExportFailure(msg, response);
    },

    /**
     * @template
     * This method can be used to apply additional parameters to the 'params' property of the export {@link Ext.Ajax XHR} request.
     * By default this method returns an empty object.
     * @return {Object}
     */
    getParameters : function () {
        return {};
    },

    /**
     * This method can be used to return any extra configuration properties applied to the {@link Ext.Ajax#request} call.
     * @template
     * @param {Object} config The proposed Ajax configuration settings. You may read any properties from this object, but modify it at your own risk.
     * @return {Object}
     */
    getAjaxConfig : function (config) {
        return {};
    },

    //Private used to prevent using old reference in the response callbacks
    getWin : function () {
        return this.win || null;
    },

    /*
     * @private
     * Mask the body, hiding panel to allow changing it's parameters in the background.
     */
    mask : function () {
        var mask = Ext.getBody().mask();
        mask.addCls('sch-export-mask');
    },

    //Private.
    unmask : function () {
        Ext.getBody().unmask();
    },

    destroy : function () {
        this.callParent(arguments);

        if (this.win) {
            this.win.destroy();
        }
    }
});
/**
@class Sch.plugin.Lines
@extends Sch.feature.AbstractTimeSpan

Plugin (ptype = 'scheduler_lines') for showing "global" time lines in the scheduler grid. It uses a store to populate itself, records in this store should have the following fields:

- `Date` The date of the line. This date is formatted based on what's configured in the {@link Sch.preset.ViewPreset#displayDateFormat} option of the current "viewPreset".
- `Text` The Text to show when hovering over the line (optional)
- `Cls`  A CSS class to add to the line (optional)

To add this plugin to scheduler:

        var dayStore    = new Ext.data.Store({
            fields  : [ 'Date', 'Text', 'Cls' ],

            data    : [
                {
                    Date        : new Date(2011, 06, 19),
                    Text        : 'Some important day'
                }
            ]
        });


        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Lines', { store : dayStore })
            ]
        });


*/
Ext.define("Sch.plugin.Lines", {
    extend              : "Sch.feature.AbstractTimeSpan",
    alias               : 'plugin.scheduler_lines',

    cls                 : 'sch-timeline',

    /**
     * @cfg {Boolean} showTip 'true' to include a native browser tooltip when hovering over the line.
     */
    showTip             : true,

    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl            : null,
    

    prepareTemplateData : null,
    side                : null,

    init : function(scheduler) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }

        this.side = scheduler.rtl ? 'right' : 'left';

        var innerTpl = this.innerTpl;

        if (!this.template) {
            this.template = new Ext.XTemplate(
                '<tpl for=".">',
                    '<div id="{id}" ' + (this.showTip ? 'title="{[this.getTipText(values)]}" ' : '') + 'class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px">' +
                    (innerTpl ? '{[this.renderInner(values)]}' : '') +
                    '</div>',
                '</tpl>',
                {
                    getTipText : function (values) {
                        return scheduler.getSchedulingView().getFormattedDate(values.Date) + ' ' + (values.Text || "");
                    },

                    renderInner : function(values) {
                        return innerTpl.apply(values);
                    }
                }
            );
        }
        
        this.callParent(arguments);
    },

    generateMarkup : function(isPrint, records) {
        return this.schedulerView.getMode() === 'calendar' ? '' : this.callParent(arguments);
    },

    generateHeaderMarkup : function (isPrint, records) {
        return this.schedulerView.getMode() === 'calendar' ? '' : this.callParent(arguments);
    },

    getElementData : function(viewStart, viewEnd, records) {
        var s = this.store,
            scheduler = this.schedulerView,
            isHorizontal = scheduler.isHorizontal(),
            rs = records || s.getRange(),
            data = [],
            height,
            width,
            region = scheduler.getTimeSpanRegion(viewStart, null, this.expandToFitView),
            record, date, templateData;

        if (Ext.versions.touch){
            height = '100%';
        } else {
            height = isHorizontal ? region.bottom - region.top : 1;
        }

        width = isHorizontal ? 1 : region.right - region.left;

        for (var i = 0, l = rs.length; i < l; i++) {
            record = rs[i];
            date = record.get('Date');

            if (date && Sch.util.Date.betweenLesser(date, viewStart, viewEnd)) {
                var pos = scheduler.getCoordinateFromDate(date);

                templateData = Ext.apply({}, this.getTemplateData(record));
                templateData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                templateData.$cls = this.getElementCls(record, templateData);

                templateData.width = width;
                templateData.height = height;

                if (isHorizontal) {
                    templateData.left = pos;
                } else{
                    templateData.top = pos;
                }
                data.push(templateData);
            }
        }
        
        return data;
    },
    
    
    getHeaderElementData : function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            isHorizontal = this.schedulerView.isHorizontal(),
            data = [],
            record, date, position, templateData;

        records = records || this.store.getRange();

        for (var i = 0, l = records.length; i < l; i++) {
            record = records[i];
            date = record.get('Date');
            
            if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
                position = this.getHeaderElementPosition(date);
                templateData = this.getTemplateData(record);
                
                templateData = Ext.apply({
                    side     : isHorizontal ? this.side : 'top',
                    cls      : this.getHeaderElementCls(record, templateData),
                    position : position
                }, templateData);
                
                // Overwrite id manually as it might exist in the record raw data
                templateData.id = this.getHeaderElementId(record);

                data.push(templateData);
            }
        }
        
        return data;
    }
    
});

/**
@class Sch.plugin.CurrentTimeLine
@extends Sch.plugin.Lines

Plugin (ptype = 'scheduler_currenttimeline') indicating the current date and time as a line in the schedule.

To add this plugin to scheduler:

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            Ext.create('Sch.plugin.CurrentTimeLine', { updateInterval : 30000 })
        ]
    });


*/
Ext.define("Sch.plugin.CurrentTimeLine", {
    extend              : "Sch.plugin.Lines",
    alias               : 'plugin.scheduler_currenttimeline',
    mixins              : ['Sch.mixin.Localizable'],

    requires            : [
        'Ext.data.JsonStore'
    ],

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - tooltipText : 'Current time'
     */

    /**
     * @cfg {Number} updateInterval This value (in ms) defines how often the timeline shall be refreshed. Defaults to every once every minute.
     */
    updateInterval      : 60000,

    showHeaderElements  : true,

    /**
     * @cfg {Boolean} autoUpdate true to automatically update the line position over time. Default value is `true`
     */
    autoUpdate          : true,

    expandToFitView     : true,

    timer               : null,

    init                : function(cmp) {
        // touch scheduler does not support header elements
        if (Ext.getVersion('touch')) this.showHeaderElements = false;
        
        var store = new Ext.data.JsonStore({
            fields  : ['Date', 'Cls', 'Text'],
            data    : [
                { Date : new Date(), Cls : 'sch-todayLine', Text : this.L('tooltipText')}
            ]
        });

        var record = store.first();

        if (this.autoUpdate) {
            this.timer = setInterval(function() {
                record.set('Date', new Date());
            }, this.updateInterval);
        }

        this.store = store;
        this.callParent(arguments);
    },

    destroy       : function() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }

        if (this.store.autoDestroy) {
            this.store.destroy();
        }

        this.callParent(arguments);
    }
});

/**
@class Sch.plugin.DragSelector
@extends Ext.util.Observable

Plugin (ptype = 'scheduler_dragselector') for selecting multiple events by "dragging" an area in the scheduler chart. Currently only enabled **when CTRL is pressed**

{@img scheduler/images/drag-selector.png}

To add this plugin to scheduler:

    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...
    
        resourceStore   : resourceStore,
        eventStore      : eventStore,
    
        plugins         : [
            Ext.create('Sch.plugin.DragSelector')
        ]
    });

*/
Ext.define("Sch.plugin.DragSelector", {
    extend        : "Sch.util.DragTracker",
    alias         : 'plugin.scheduler_dragselector',
    mixins        : ['Ext.AbstractPlugin'],

    requires      : [
        'Sch.util.ScrollManager'
    ],

    lockableScope : 'top',

    schedulerView : null,
    eventData     : null,
    sm            : null,
    proxy         : null,
    bodyRegion    : null,

    constructor : function (cfg) {
        cfg = cfg || {};

        Ext.applyIf(cfg, {
            onBeforeStart : this.onBeforeStart,
            onStart       : this.onStart,
            onDrag        : this.onDrag,
            onEnd         : this.onEnd
        });

        this.callParent(arguments);
    },

    init : function (scheduler) {

        var view = this.schedulerView = scheduler.getSchedulingView();

        view.on({
            afterrender : this.onSchedulingViewRender,
            scope       : this
        });
    },

    onBeforeStart : function (e) {
        // Only react when not clicking event nodes and when CTRL is pressed
        return !e.getTarget('.sch-event') && e.ctrlKey;
    },

    onStart : function (e) {
        var schedulerView = this.schedulerView;

        this.proxy.show();

        this.bodyRegion = schedulerView.getScheduleRegion();

        var eventData = [];

        schedulerView.getEventNodes().each(function (el) {
            eventData[ eventData.length ] = {
                region : el.getRegion(),
                node   : el.dom
            };
        });

        this.eventData = eventData;

        this.sm.deselectAll();

        Sch.util.ScrollManager.activate(schedulerView);
    },

    onDrag : function (e) {
        var sm              = this.sm,
            eventData       = this.eventData,
            dragRegion      = this.getRegion().constrainTo(this.bodyRegion),
            i, ev, len, sel;

        this.proxy.setBox(dragRegion);

        for (i = 0, len = eventData.length; i < len; i++) {
            ev = eventData[i];
            sel = dragRegion.intersect(ev.region);

            if (sel && !ev.selected) {
                ev.selected = true;
                sm.selectNode(ev.node, true);
            } else if (!sel && ev.selected) {
                ev.selected = false;
                sm.deselectNode(ev.node);
            }
        }
    },

    onEnd : function (e) {
        if (this.proxy) {
            this.proxy.setDisplayed(false);
        }

        Sch.util.ScrollManager.deactivate();
    },

    onSchedulingViewRender : function (view) {
        this.sm = view.getEventSelectionModel();

        this.initEl(this.schedulerView.el);

        // the proxy has to be set up immediately after rendering the view, so it will be included in the
        // "fixedNodes" of the grid view and won't be overwritten after refresh
        this.proxy = view.el.createChild({ cls : 'sch-drag-selector' });
    },

    destroy : function () {
        if (this.proxy) Ext.destroy(this.proxy);

        this.callParent(arguments);
    }
});


/**
@class Sch.plugin.EventEditor
@extends Ext.form.Panel

A plugin (ptype = 'scheduler_eventeditor') used to edit event start/end dates as well as any meta data. It inherits from {@link Ext.form.FormPanel} so you can define any fields and use any layout you want.

{@img scheduler/images/event-editor.png}

Normally, this plugin shows the same form for all events. However you can show different forms for different event types. To do that:

- the event type is supposed to be provided as the value of the `EventType` field in the event model.
- in the {@link #fieldsPanelConfig} provide the container with card layout. The children of that container should be the forms which will be used to edit different
event types
- each such form should contain the `EventType` configuration option, matching to the appropriate event type.
- the small top form, containing the start date, start time and duration fields is always shared among all forms.
- this whole behavior can be disabled with the `dynamicForm : false` option.

The overall picture will look like:

    fieldsPanelConfig : {
        xtype       : 'container',

        layout      : 'card',

        items       : [
            // form for "Meeting" EventType
            {
                EventType   : 'Meeting',

                xtype       : 'form',

                items       : [
                    ...
                ]
            },
            // eof form for "Meeting" EventType

            // form for "Appointment" EventType
            {
                EventType   : 'Appointment',

                xtype       : 'form',

                items       : [
                    ...
                ]
            }
            // eof form for "Appointment" EventType
        ]
    }

Note, that you can customize the start date, start time and duration fields with appropriate configuration options: {@link #dateConfig}, {@link #timeConfig}, {@link #durationConfig}


    var eventEditor    = Ext.create('Sch.plugin.EventEditor', {
        ...
        timeConfig      : {
            minValue    : '08:00',
            maxValue    : '18:00'
        },
        ...
    });


    var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
        ...

        resourceStore   : resourceStore,
        eventStore      : eventStore,

        plugins         : [
            eventEditor
        ]
    });


If you include additional components which have floating sub-components, such as combo boxes or date pickers -
you need to decorate them with a special CSS class so the editor will stay open when clicking 'outside' of the editor element.

    var myComboBox = new Ext.form.ComboBox({
        width           : 70,
        ...
    });

    // Tell the editor that this component and its picker are part of the editor, clicking them should not hide the editor.
    myComboBox.getPicker().addCls('sch-event-editor-ignore-click');

 */
Ext.define("Sch.plugin.EventEditor", {
    extend      : "Ext.form.Panel",

    mixins      : [
        'Ext.AbstractPlugin',
        'Sch.mixin.Localizable'
    ],

    alias       : ['widget.eventeditor',  'plugin.scheduler_eventeditor'],

    lockableScope : 'normal',

    requires    : [
        'Sch.util.Date',
        'Ext.util.Region',
        'Ext.form.Label',
        'Ext.form.field.Date',
        'Ext.form.field.Time'
    ],

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - saveText    : 'Save',
            - deleteText  : 'Delete',
            - cancelText  : 'Cancel'
     */

    /**
     * @cfg {Boolean} hideOnBlur True to hide this panel if a click is detected outside the panel (defaults to true)
     */
    hideOnBlur      : true,

    /**
     * This property provides access to the start date field
     * @property {Ext.form.field.Date} startDateField
     */
    startDateField  : null,

    /**
     * This property provides access to the start time field
     * @property {Ext.form.field.Time} startTimeField
     */
    startTimeField  : null,

    /**
     * This property provides access to the duration spinner field
     * @property {Ext.form.field.Number} durationField
     */
    durationField   : null,

    /**
     * @cfg {Object} timeConfig Config for the `startTimeField` constructor.
     */
    timeConfig      : null,

    /**
     * @cfg {Object} dateConfig Config for the `startDateField` constructor.
     */
    dateConfig      : null,

    /**
     * @cfg {Object} durationConfig A custom config object that is used to configure the {@link Ext.form.field.Number duration field}.
     */
    durationConfig  : null,

    /**
     * @cfg {String} durationUnit The unit in which the duration is measured, defaults to Sch.util.Date.HOUR.
     *                            Please see {@link Sch.util.Date} for the possible values.
     */
    durationUnit    : null,

    /**
     * @cfg {String} durationText The text to show after the duration spinner field
     */
    durationText    : null,

    /**
     * @cfg {String} triggerEvent The event that shall trigger showing the editor. Defaults to 'eventdblclick', set to '' or null to disable editing of existing events.
     */
    triggerEvent    : 'eventdblclick',

    /**
     * @cfg {Object} fieldsPanelConfig A panel config representing your fields that is associated with a scheduled event.
     *
     * Example:

        fieldsPanelConfig : {
            layout      : 'form',

            style       : 'background : #fff',
            border      : false,
            cls         : 'editorpanel',
            labelAlign  : 'top',

            defaults    : {
                width : 135
            },

            items       : [
                titleField      = new Ext.form.TextField({
                    name            : 'Title',
                    fieldLabel      : 'Task'
                }),

                locationField   = new Ext.form.TextField({
                    name            : 'Location',
                    fieldLabel      : 'Location'
                })
            ]
        }
     *
     */
    fieldsPanelConfig   : null,

    /**
     * @cfg {String} dateFormat This config parameter is passed to the `startDateField` constructor.
     */
    dateFormat      : 'Y-m-d',

    /**
     * @cfg {String} timeFormat This config parameter is passed to the `startTimeField` constructor.
     */
    timeFormat      : 'H:i',


    cls             : 'sch-eventeditor',
    border          : false,
    shadow          : false,

    /**
     * @cfg {Boolean} dynamicForm True to use several forms. Default is `true`.
     */
    dynamicForm     : true,

    /**
     * @property {Sch.model.Event} eventRecord The current {@link Sch.model.Event} record, which is being edited by the event editor
     */
    eventRecord     : null,

    hidden          : true,
    collapsed       : true,
    currentForm     : null,
    schedulerView   : null,
    resourceRecord  : null,
    preventHeader   : true,
    floating        : true,
    hideMode        : 'offsets',
    ignoreCls       : 'sch-event-editor-ignore-click',
    readOnly        : false, // Cached value of scheduler setting

    layout          : {
        type    : 'vbox',
        align   : 'stretch'
    },

    dragProxyEl     : null,

    /**
     * @cfg {Boolean} constrain Pass `true` to enable the constraining - ie editor panel will not exceed the document edges. This option will disable the animation
     * during the expansion. Default value is `false`.
     */
    constrain           : false,

    /**
     * @event beforeeventdelete
     * Fires before an event is deleted (return false to cancel the operation)
     * @param {Sch.plugin.EventEditor} editor The editor instance
     * @param {Sch.model.Event} eventRecord The record about to be deleted
     */

    /**
     * @event beforeeventsave
     * Fires before an event is saved (return false to cancel the operation)
     * @param {Sch.plugin.EventEditor} editor The editor instance
     * @param {Sch.model.Event} eventRecord The record about to be saved
     */

    constructor : function(config) {
        config              = config || {};
        Ext.apply(this, config);

        this.durationUnit   = this.durationUnit || Sch.util.Date.HOUR;

        this.callParent(arguments);
    },


    initComponent : function() {

        if (!this.fieldsPanelConfig) throw 'Must define a fieldsPanelConfig property';

        Ext.apply(this, {
            fbar            : this.buttons || this.buildButtons(),

            items           : [
                {
                    xtype   : 'container',
                    layout  : 'hbox',
                    height  : 35,
                    border  : false,
                    cls     : 'sch-eventeditor-timefields',

                    items   : this.buildDurationFields()
                },
                Ext.applyIf(this.fieldsPanelConfig, {
                    flex        : 1,
                    activeItem  : 0
                })
            ]
        });

        this.callParent(arguments);
    },


    init : function (grid) {
        // setting the ownerCt helps a possible container of the scheduler (such as a window), to not try to
        // position itself above the editor, since it's in sort of a "child" of the Window component in that case.
        this.ownerCt        = grid;

        this.schedulerView  = grid.getView();
        this.eventStore     = this.schedulerView.getEventStore();

        this.schedulerView.on({
            afterrender     : this.onSchedulerRender,
            dragcreateend   : this.onDragCreateEnd,

            scope           : this
        });

        this.schedulerView.on('eventrepaint', this.onEventRepaint, this);

        if (this.triggerEvent) {
            this.schedulerView.on(this.triggerEvent, this.onActivateEditor, this);
        }

        this.schedulerView.registerEventEditor(this);
    },


    onSchedulerRender : function() {
        this.render(Ext.getBody());

        if (this.hideOnBlur) {
            // Hide when clicking outside panel
            this.mon(Ext.getDoc(), 'mousedown', this.onMouseDown, this);
        }
    },


    /**
     * Activates the editor for the passed event record.
     * @param {Sch.model.Event} eventRecord The record to show in the editor panel
     */
    show : function (eventRecord, alignToEl) {

        var readOnly = this.schedulerView.isReadOnly();

        if (readOnly !== this.readOnly) {
            Ext.Array.forEach(this.query('field'), function(field) {
                field.setReadOnly(readOnly);
            });

            this.saveButton.setVisible(!readOnly);
            this.deleteButton.setVisible(!readOnly);

            this.readOnly = readOnly;
        }

        // Only show delete button if the event belongs to a store
        if (this.deleteButton) {
            this.deleteButton.setVisible(!readOnly && this.eventStore.indexOf(eventRecord) >= 0);
        }

        this.eventRecord = eventRecord;

        // Manually set the duration field value
        this.durationField.setValue(Sch.util.Date.getDurationInUnit(eventRecord.getStartDate(), eventRecord.getEndDate(), this.durationUnit, true));

        var startDate = eventRecord.getStartDate();
        this.startDateField.setValue(startDate);
        this.startTimeField.setValue(startDate);

        // If the scheduler we're attached to is inside a floating component (window etc)
        // we need to make sure we're on top of it at show time.
        var floatingContainer = this.schedulerView.up('[floating=true]');
        if (floatingContainer){
            this.getEl().setZIndex(floatingContainer.getEl().getZIndex() + 1);
            floatingContainer.addCls(this.ignoreCls);
        }

        this.callParent();

        alignToEl = alignToEl || this.schedulerView.getElementsFromEventRecord(eventRecord)[0];

        this.alignTo(alignToEl, this.schedulerView.getMode() == 'horizontal' ? 'bl' : 'tl-tr', this.getConstrainOffsets(alignToEl));

        this.expand(!this.constrain);

        if (this.constrain) {
            this.doConstrain(Ext.util.Region.getRegion(Ext.getBody()));
        }

        var form,
            eventType = eventRecord.get('EventType');

        if (eventType && this.dynamicForm) {
            var fieldsPanel     = this.items.getAt(1),
                forms           = fieldsPanel.query('> component[EventType=' + eventType + ']');

            if (!forms.length)                                  {
                throw "Can't find form for EventType=" + eventType;
            }
            if (!fieldsPanel.getLayout().setActiveItem)         {
                throw "Can't switch active component in the 'fieldsPanel'";
            }

            form = forms[ 0 ];

            if (!(form instanceof Ext.form.Panel))              {
                throw "Each child component of 'fieldsPanel' should be a 'form'";
            }

            fieldsPanel.getLayout().setActiveItem(form);
        } else {
            form = this;
        }

        this.currentForm = form;

        // get the "basicForm" from current form and load it from event record
        form.getForm().loadRecord(eventRecord);
    },

    // Override this to add support for constraining the editor panel to the viewport or scheduler
    getConstrainOffsets : function(eventEl) {
        return [0, 0];
    },

    onSaveClick : function() {
        var me          = this,
            record      = me.eventRecord,
            form        = me.currentForm.getForm();

        if (form.isValid() && me.fireEvent('beforeeventsave', me, record) !== false) {

            var startDate   = me.startDateField.getValue(),
                endDate,
                startTime   = me.startTimeField.getValue(),
                duration    = me.durationField.getValue();

            if (startDate && duration >= 0) {

                if (startTime) {
                    Sch.util.Date.copyTimeValues(startDate, startTime);
                }

                endDate = Sch.util.Date.add(startDate, me.durationUnit, duration);
            } else {
                return;
            }


            if (!me.schedulerView.allowOverlap) {
                var resources = record.getResources(me.eventStore);
                var abort     = false;

                // Manually locate the event resource for new records
                resources = resources.length > 0 ? resources : [me.resourceRecord];

                Ext.each(resources, function(resource) {
                    return abort = !me.schedulerView.isDateRangeAvailable(startDate, endDate, record, resource);
                });

                if (abort) return;
            }

            // Prevent editor realignment while we're closing it
            me.schedulerView.un('eventrepaint', me.onEventRepaint, me);

            me.onBeforeSave(record);

            record.beginEdit();

            form.updateRecord(record);

            record.setStartEndDate(startDate, endDate);

            record.endEdit();

            // Check if me is a new record
            if (me.eventStore.indexOf(me.eventRecord) < 0) {
                if (me.schedulerView.fireEvent('beforeeventadd', me.schedulerView, record) !== false) {
                    me.eventStore.append(record);
                }
            }

            me.onAfterSave(record);

            me.collapse(null, true);

            me.schedulerView.on('eventrepaint', me.onEventRepaint, me);
        }
    },

    /**
     * Template method, intended to be overridden. Called before the event record has been updated.
     * @param {Sch.model.EventRecord} eventRecord The event record
     *
     **/
    onBeforeSave : function(eventRecord) {},

    /**
     * Template method, intended to be overridden. Called after the event record has been updated.
     * @param {Sch.model.EventRecord} eventRecord The event record
     *
     **/
    onAfterSave : function(eventRecord) {},

    onDeleteClick : function() {
        if (this.fireEvent('beforeeventdelete', this, this.eventRecord) !== false) {
            this.eventStore.remove(this.eventRecord);
        }
        this.collapse(null, true);
    },


    onCancelClick : function() {
        this.collapse(null, true);
    },

    buildButtons : function() {

        this.saveButton = new Ext.Button({
            text        : this.L('saveText'),

            scope       : this,
            handler     : this.onSaveClick
        });

        this.deleteButton = new Ext.Button({
            text        : this.L('deleteText'),

            scope       : this,
            handler     : this.onDeleteClick
        });

        this.cancelButton = new Ext.Button({
            text        : this.L('cancelText'),

            scope       : this,
            handler     : this.onCancelClick
        });

        return [ this.saveButton, this.deleteButton, this.cancelButton ];
    },


    buildDurationFields : function() {

        this.startDateField = new Ext.form.field.Date(Ext.apply({
            width           : 90,
            allowBlank      : false,
            format          : this.dateFormat
        }, this.dateConfig || {}));

        this.startDateField.getPicker().addCls(this.ignoreCls);

        this.startTimeField = new Ext.form.field.Time(Ext.apply({
            width           : 70,
            allowBlank      : false,
            format          : this.timeFormat

        }, this.timeConfig || {}));

        this.startTimeField.getPicker().addCls(this.ignoreCls);

        this.durationField = new Ext.form.field.Number(Ext.apply({

            width           : 45,

            value           : 0,

            minValue        : 0,
            allowNegative   : false

        }, this.durationConfig || {}));


        this.durationLabel = new Ext.form.Label({
            text            : this.getDurationText()
        });

        return [ this.startDateField, this.startTimeField, this.durationField, this.durationLabel ];
    },


    onActivateEditor : function(g, evtRecord) {
        this.show(evtRecord);
    },


    onMouseDown : function(e){

        if (
            this.collapsed || e.within(this.getEl()) ||
            // ignore the click on the menus and combo-boxes (which usually floats as the direct child of <body> and
            // leaks through the `e.within(this.getEl())` check

            // if clicks should be ignored for any other element - it should have this class
                e.getTarget('.' + this.ignoreCls, 9) ||
                e.getTarget(this.schedulerView.eventSelector)
        ) {
            return;
        }

        this.collapse();
    },


    onDragCreateEnd : function(s, eventRecord, resourceRecord, e, proxyEl) {
        this.dragProxyEl = proxyEl;

        this.resourceRecord = resourceRecord;

        // Call scheduler template method
        this.schedulerView.onEventCreated(eventRecord);

        this.show(eventRecord, this.dragProxyEl);
    },

    //@OVERRIDE
    hide : function() {
        this.callParent(arguments);
        var dpEl = this.dragProxyEl;

        if (dpEl) {
            dpEl.hide();
        }
    },

    //@OVERRIDE: Always hide drag proxy on collapse
    afterCollapse : function() {
        // currently the header is kept even after collapse, so need to hide the form completely
        this.hide();

        this.callParent(arguments);
    },


    getDurationText : function () {
        if (this.durationText) {
            return this.durationText;
        }

        return Sch.util.Date.getShortNameOfUnit(Sch.util.Date.getNameOfUnit(this.durationUnit));
    },

    // Reposition / update form content if event is moved
    onEventRepaint : function(store, record) {
        if (!this.getCollapsed() && record === this.eventRecord) {
            this.show(record);
        }
    }
});

/**
@class Sch.plugin.EventTools
@extends Ext.Container

A plugin (ptype = 'scheduler_eventtools') showing a tools menu with event actions when the mouse hovers over a rendered event in the timeline.
Each tool can also define a visibleFn, which is called before the tools menu is shown. This allows you to get control over which actions
can be performed on which events.

Sample usage:
    
    plugins : [
        Ext.create('Sch.plugin.EventTools', {
            items : [
                { type: 'details',  handler: onToolClick, tooltip: 'Show Event Details' },
                { type: 'edit',     handler: onToolClick, tooltip: 'Edit Event' },
                { type: 'repeat',   handler: onToolClick, tooltip: 'Repeat Event' },
                { type: 'drop',     handler: onToolClick, tooltip: 'Remove Event', visibleFn: function(model) { return !!model.get('Deletable'); } }
            ]
        })
    ]

*/
Ext.define('Sch.plugin.EventTools', {
    extend          : 'Ext.Container',
    mixins          : ['Ext.AbstractPlugin'],
    lockableScope   : 'top',
    alias           : 'plugin.scheduler_eventtools',

    /**
    * @cfg {Number} hideDelay The menu will be hidden after this number of ms, when the mouse leaves the tools element. 
    */
    hideDelay       : 500,
    
    /**
    * @cfg {String} align The alignment of the tools menu
    */
    align           : 'right',
    
    /**
    * @cfg {Object} defaults The defaults for each action item in the tools menu
    */
    defaults: {
        xtype       : 'tool',
        baseCls     : 'sch-tool',
        overCls     : 'sch-tool-over',
        width       : 20,
        height      : 20,
        visibleFn   : Ext.emptyFn
    },

    // private
    hideTimer   : null,
    
    // private
    lastPosition    : null,
    
    // private
    cachedSize      : null,

    // private
    offset          : { x: 0, y: 1 },

    autoRender      : true,
    floating        : true,
    hideMode        : 'offsets',
    hidden          : true,

    /**
    * Returns the record that this tools menu is currently associated with
    * @return {Sch.model.Event} record The event record
    */
    getRecord : function() {
        return this.record;
    },
     
    init: function (scheduler) {
        if (!this.items) throw 'Must define an items property for this plugin to function correctly';

        // Let client use 'cls' property
        this.addCls('sch-event-tools');

        this.scheduler = scheduler;

        scheduler.on({
            // Suspend during resize
            'eventresizestart'  : this.onOperationStart,
            'eventresizeend'    : this.onOperationEnd,
            
            // Suspend during drag drop
            'eventdragstart'    : this.onOperationStart,
            'eventdrop'         : this.onOperationEnd,
            
            'eventmouseenter'   : this.onEventMouseEnter,
            'eventmouseleave'   : this.onContainerMouseLeave,
            
            scope: this
        });
    },

    onRender: function () {
        this.callParent(arguments);

        this.scheduler.mon(this.el, {
            mouseenter : this.onContainerMouseEnter,
            mouseleave : this.onContainerMouseLeave,
            scope       : this
        });
    },

    onEventMouseEnter: function (sch, model, event) {

        var doShow  = false;
        var visible;
        this.record = model;
        
        this.items.each(function (tool) {
            visible = tool.visibleFn(model) !== false;
            tool.setVisible(visible);

            if (visible) {
                doShow = true;
            }
        }, this);

        if (!doShow) return;

        if (!this.rendered) {
            this.doAutoRender();
        }

        var node    = event.getTarget(sch.eventSelector);
        var box     = Ext.fly(node).getBox();

        this.doLayout();

        // Needs to be done after doLayout
        var size = this.getSize();

        this.lastPosition = [
            event.getXY()[0] - (size.width/2), 
            box.y - size.height - this.offset.y
        ];

        this.onContainerMouseEnter();
    },

    onContainerMouseEnter: function () {
        window.clearTimeout(this.hideTimer);
        this.setPosition.apply(this, this.lastPosition);
        this.show();
    },

    onContainerMouseLeave: function () {
        window.clearTimeout(this.hideTimer);
        this.hideTimer = Ext.defer(this.hide, this.hideDelay, this);
    },

    onOperationStart: function () {
        this.scheduler.un("eventmouseenter", this.onEventMouseEnter, this);
        window.clearTimeout(this.hideTimer);
        this.hide();
    },

    onOperationEnd: function () {
        this.scheduler.on("eventmouseenter", this.onEventMouseEnter, this);
    }
});



/**
 @class Sch.plugin.Pan

 A plugin (ptype = 'scheduler_pan') enabling panning by clicking and dragging in a scheduling view.

 To add this plugin to your scheduler or gantt view:

         var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.Pan', { enableVerticalPan : true })
            ]
        });
 */
Ext.define("Sch.plugin.Pan", {
    extend        : 'Ext.AbstractPlugin',
    alias         : 'plugin.scheduler_pan',
    lockableScope : 'top',

    /**
     * @cfg {Boolean} enableVerticalPan
     * True to allow vertical panning
     */
    enableVerticalPan : true,

    statics : {
        /**
         * @cfg {Number} KEY_SHIFT Constant for shift key
         */
        KEY_SHIFT : 1,

        /**
         * @cfg {Number} KEY_CTRL Constant for ctrl / meta key
         */
        KEY_CTRL : 2,

        /**
         * @cfg {Number} KEY_ALT Constant for alt key
         */
        KEY_ALT : 4,

        /**
         * @cfg {Number} KEY_ALL Constant for all modifier keys (shift, ctrl / meta, alt)
         */
        KEY_ALL : 7
    },

    /**
     * @cfg {Number} disableOnKey Specifies which key should be pressed to disable panning.
     * See {@link #KEY_SHIFT}, {@link #KEY_CTRL}, {@link #KEY_ALT}, {@link #KEY_ALL}.
     * For example to disable panning when shift or ctrl is pressed:

     Ext.create('Sch.plugin.Pan', {
            disableOnKey : Sch.plugin.Pan.KEY_SHIFT + Sch.plugin.Pan.KEY_CTRL
        })

     */
    disableOnKey : 0,

    constructor : function (config) {
        Ext.apply(this, config);
    },

    init : function (pnl) {
        // No need for this plugin on a touch device, Ext JS handles scrolling by default
        if (Ext.supports.Touch) return;

        this.view = pnl.getSchedulingView();

        this.view.on('afterrender', this.onRender, this);
    },

    onRender : function (s) {
        this.view.el.on('mousedown', this.onMouseDown, this);
    },

    onMouseDown : function (e, t) {
        var self = this.self,
            disableOnKey = this.disableOnKey;

        // Ignore event if #disableOnKey is specified and at least one of the
        // functional keys is pressed
        if ((e.shiftKey && (disableOnKey & self.KEY_SHIFT)) ||
            (e.ctrlKey && (disableOnKey & self.KEY_CTRL)) ||
            (e.altKey && (disableOnKey & self.KEY_ALT))) {
            return;
        }

        // ignore clicks on tasks and events
        if (e.getTarget('.' + this.view.timeCellCls, 10) && !e.getTarget(this.view.eventSelector)) {
            this.mouseX = e.getX();
            this.mouseY = e.getY();
            Ext.getBody().on('mousemove', this.onMouseMove, this);
            Ext.getDoc().on('mouseup', this.onMouseUp, this);

            // For IE (and FF if using frames), if you move mouse onto the browser chrome and release mouse button
            // we won't know about it. Next time mouse enters the body, cancel any ongoing pan activity as a fallback.
            if (Ext.isIE || Ext.isGecko) {
                Ext.getBody().on('mouseenter', this.onMouseUp, this);
            }

            // required for some weird chrome bug/behavior, when whole panel was scrolled-out
            e.stopEvent();
        }
    },

    onMouseMove : function (e) {
        e.stopEvent();

        var x = e.getX();
        var y = e.getY();
        var yDelta = 0,
            xDelta = this.mouseX - x;

        if (this.enableVerticalPan) {
            yDelta = this.mouseY - y;
        }

        this.mouseX = x;
        this.mouseY = y;

        this.view.scrollBy(xDelta, yDelta, false);
    },

    onMouseUp : function (e) {
        Ext.getBody().un('mousemove', this.onMouseMove, this);
        Ext.getDoc().un('mouseup', this.onMouseUp, this);

        if (Ext.isIE || Ext.isGecko) {
            Ext.getBody().un('mouseenter', this.onMouseUp, this);
        }
    }
});

/**
@class Sch.plugin.SimpleEditor
@extends Ext.Editor

A plugin (ptype = 'scheduler_simpleeditor') for basic text editing of an event name.

{@img scheduler/images/simple-editor.png}

To add this plugin to scheduler:

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.SimpleEditor', { dataIndex : 'Title' })
            ]
        });


*/
Ext.define("Sch.plugin.SimpleEditor", {
    extend              : "Ext.Editor",
    alias               : 'plugin.scheduler_simpleeditor',

    requires            : [
        "Ext.form.TextField"
    ],

    mixins              : ['Ext.AbstractPlugin', 'Sch.mixin.Localizable'],
    lockableScope       : 'top',
    cls                 : 'sch-simpleeditor',
    allowBlur           : false,

    // private
    delegate            : '.sch-event-inner',

    /**
     * @cfg {String} dataIndex Required. A field, containing the task's title. This field will be updated by the editor. Defaults to the value of the {@link Sch.model.Event#nameField}.
     */
    dataIndex           : null,

    completeOnEnter     : true,
    cancelOnEsc         : true,
    ignoreNoChange      : true,
    height              : 19,
    dragProxyEl         : null,

    /**
     * @cfg {String} newEventText The text to assign as the name for a newly created Event.
     */
    newEventText        : null,

    autoSize            : {
        width   : 'boundEl' // The width will be determined by the width of the boundEl, the height from the editor (21)
    },


    initComponent : function() {
        this.field = this.field || { xtype : 'textfield', selectOnFocus : true };

        this.callParent(arguments);
    },


    init : function(scheduler) {
        this.scheduler = scheduler.getSchedulingView();

        scheduler.on('afterrender', this.onSchedulerRender, this);
        this.scheduler.registerEventEditor(this);

        this.dataIndex = this.dataIndex || this.scheduler.getEventStore().model.prototype.nameField;
    },

    // Programmatically enter edit mode
    edit : function(record, el) {
        el = el || this.scheduler.getElementsFromEventRecord(record)[0];

        this.startEdit(el.child(this.delegate));
        // workaround http://www.sencha.com/forum/showthread.php?296716
        this.realign();

        this.record = record;
        this.setValue(this.record.get(this.dataIndex));
    },


    onSchedulerRender : function(scheduler) {

        this.on({
            startedit   : this.onStartEdit,

            complete    : function(editor, value, original) {
                var record = this.record;
                var eventStore = this.scheduler.eventStore;

                record.set(this.dataIndex, value);

                // Check if this is a new record
                if (eventStore.indexOf(record) < 0) {
                    if (this.scheduler.fireEvent('beforeeventadd', this.scheduler, record) !== false) {
                        eventStore.append(record);
                    }
                }

                this.onAfterEdit();
            },

            canceledit  : this.onAfterEdit,

            hide        : function() {
                if (this.dragProxyEl) {
                    this.dragProxyEl.hide();
                }
            },

            scope       : this
        });

        scheduler.on({
            eventdblclick   : function(s, r, e){
                if (!scheduler.isReadOnly()) {
                    this.edit(r);
                }
            },
            dragcreateend   : this.onDragCreateEnd,
            scope           : this
        });
    },

    onStartEdit  : function() {
        if (!this.allowBlur) {
            // This should be removed when this bug is fixed:
            // http://www.sencha.com/forum/showthread.php?244580-4.1-allowBlur-on-Ext.Editor-not-working
            Ext.getBody().on('mousedown', this.onMouseDown, this);
            this.scheduler.on('eventmousedown', function() { this.cancelEdit(); }, this);
        }
    },

    onAfterEdit  : function() {
        if (!this.allowBlur) {
            Ext.getBody().un('mousedown', this.onMouseDown, this);
            this.scheduler.un('eventmousedown', function() { this.cancelEdit(); }, this);
        }
    },

    onMouseDown : function(e, t) {
        if (this.editing && this.el && !e.within(this.el)) {
            this.cancelEdit();
        }
    },

    onDragCreateEnd : function(s, eventRecord, resourceRecord, e, proxyEl) {
        this.dragProxyEl = proxyEl;

        // Call scheduler template method
        this.scheduler.onEventCreated(eventRecord);

        if (eventRecord.get(this.dataIndex) === '') {
            eventRecord.set(this.dataIndex, this.newEventText || this.L('newEventText'));
        }
        this.edit(eventRecord, this.dragProxyEl);
    }
});

/**
@class Sch.plugin.Zones
@extends Sch.feature.AbstractTimeSpan

Plugin (ptype = 'scheduler_zones') for showing "global" zones in the scheduler grid, these can by styled easily using just CSS.
To populate this plugin you need to pass it a store having `Sch.model.Range` as the model.

{@img scheduler/images/scheduler-grid-horizontal.png}

To add this plugin to scheduler:

        var zonesStore = Ext.create('Ext.data.Store', {
            model   : 'Sch.model.Range',
            data    : [
                {
                    StartDate   : new Date(2011, 0, 6),
                    EndDate     : new Date(2011, 0, 7),
                    Cls         : 'myZoneStyle'
                }
            ]
        });

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...
    
            resourceStore   : resourceStore,
            eventStore      : eventStore,
            
            plugins         : [
                Ext.create('Sch.plugin.Zones', { store : zonesStore })
            ]
        });


*/
Ext.define("Sch.plugin.Zones", {
    extend      : "Sch.feature.AbstractTimeSpan",
    alias       : "plugin.scheduler_zones",

    requires    : [
        'Sch.model.Range'
    ],

    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl            : null,

    cls                 : 'sch-zone',
    side                : null,

    
    init : function (scheduler) {
        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }

        this.side = scheduler.rtl ? 'right' : 'left';

        var innerTpl = this.innerTpl;

        if (!this.template) {
            this.template = new Ext.XTemplate(
                '<tpl for=".">' +
                    '<div id="{id}" class="{$cls}" style="' + this.side + ':{left}px;top:{top}px;height:{height}px;width:{width}px;{style}">' +
                    (innerTpl ? '{[this.renderInner(values)]}' : '') + 
                    '</div>' +
                '</tpl>',
                {
                    renderInner : function(values) {
                        return innerTpl.apply(values);
                    }
                }
            );
        }
        
        
        if (Ext.isString(this.innerHeaderTpl)) {
            this.innerHeaderTpl = new Ext.XTemplate(this.innerHeaderTpl);
        }
        
        this.callParent(arguments);
    },

    
    getElementData : function(viewStart, viewEnd, records, isPrint) {
        var schedulerView   = this.schedulerView,
            data            = [];
        var region          = schedulerView.getTimeSpanRegion(viewStart, viewEnd, this.expandToFitView);
        var record, spanStart, spanEnd, zoneData, width, templateData;
        
        records             = records || this.store.getRange();
            
        for (var i = 0, l = records.length; i < l; i++) {
            record       = records[i];
            spanStart    = record.getStartDate();
            spanEnd      = record.getEndDate();
            templateData = this.getTemplateData(record);

            if (spanStart && spanEnd && Sch.util.Date.intersectSpans(spanStart, spanEnd, viewStart, viewEnd)) {
                zoneData = Ext.apply({}, templateData);

                zoneData.id = this.getElementId(record);
                // using $cls to avoid possible conflict with "Cls" field in the record
                // `getElementCls` will append the "Cls" field value to the class
                zoneData.$cls = this.getElementCls(record, templateData);

                var mode = schedulerView.getMode();

                if (mode === 'calendar') {
                    var timeSpanRegion = schedulerView.getTimeSpanRegion(spanStart, spanEnd);

                    zoneData.left = timeSpanRegion.left;
                    zoneData.top = timeSpanRegion.top;
                    zoneData.height = timeSpanRegion.bottom - timeSpanRegion.top;
                    zoneData.width = timeSpanRegion.right - timeSpanRegion.left;
                }
                else {
                    var startPos = schedulerView.getCoordinateFromDate(Sch.util.Date.max(spanStart, viewStart));
                    var endPos = schedulerView.getCoordinateFromDate(Sch.util.Date.min(spanEnd, viewEnd));

                    if (mode === 'horizontal') {
                        zoneData.left = startPos;
                        zoneData.top = region.top;

                        zoneData.width = isPrint ? 0 : endPos - startPos;
                        zoneData.height = region.bottom - region.top;

                        zoneData.style = isPrint ? ('border-left-width:' + (endPos - startPos) + 'px') : "";
                    } else {
                        zoneData.left = region.left;
                        zoneData.top = startPos;

                        zoneData.height = isPrint ? 0 : endPos - startPos;
                        zoneData.width = region.right - region.left;

                        zoneData.style = isPrint ? ('border-top-width:' + (endPos - startPos) + 'px') : "";
                    }
                }

                data.push(zoneData);
            }
        }
        return data;
    },
    
        
    getHeaderElementId : function(record, isStart) {
        return this.callParent([record]) + (isStart ? '-start' : '-end');
    },
    
    
    /**
     * Return header element class for data record.
     * 
     * @param {Sch.model.Range} record Data record
     * @param {Object} data
     * @param {Boolean} isStart
     * 
     * @return {String}
     */
    getHeaderElementCls : function(record, data, isStart) {
        var clsField = record.clsField || this.clsField;
            
        if (!data) {
            data = this.getTemplateData(record);
        }
        
        return 'sch-header-indicator sch-header-indicator-' + (isStart ? 'start ' : 'end ') +
            this.uniqueCls + ' ' + (data[clsField] || '');
    },
    
    
    getZoneHeaderElementData : function(startDate, endDate, record, isStart) {
        var date = isStart ? record.getStartDate() : record.getEndDate(),
            data = null,
            position, isHorizontal, templateData;
            
        if (date && Sch.util.Date.betweenLesser(date, startDate, endDate)) {
            position     = this.getHeaderElementPosition(date);
            isHorizontal = this.schedulerView.isHorizontal();
            templateData = this.getTemplateData(record);
            
            data = Ext.apply({
                id       : this.getHeaderElementId(record, isStart),
                cls      : this.getHeaderElementCls(record, templateData, isStart),
                isStart  : isStart,
                
                side     : isHorizontal ? this.side : 'top',
                position : position
            }, templateData);
        }
        
        return data;
    },
    
    
    getHeaderElementData : function(records) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            data = [],
            record, startData, endData;
            
        records = records || this.store.getRange();
        
        for (var i = 0, l = records.length; i < l; i++) {
            record = records[i];
            
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true);
            if (startData) {
                data.push(startData);
            }
            
            endData = this.getZoneHeaderElementData(startDate, endDate, record, false);
            if (endData) {
                data.push(endData);
            }
            
        }

        return data;
    },
    
    
    updateZoneHeaderElement : function(el, data) {
        // Reapply CSS classes
        el.dom.className = data.cls;

        if (this.schedulerView.isHorizontal()) {
            this.setElementX(el, data.position);
        } else {
            el.setTop(data.position);
        }
    },
    
    
    updateHeaderElement : function(record) {
        var startDate = this.timeAxis.getStart(),
            endDate = this.timeAxis.getEnd(),
            startEl = Ext.get(this.getHeaderElementId(record, true)),
            endEl   = Ext.get(this.getHeaderElementId(record, false)),
            startData = this.getZoneHeaderElementData(startDate, endDate, record, true),
            endData   = this.getZoneHeaderElementData(startDate, endDate, record, false);
            
        if (!(startEl && endData) || !(endEl && endData)) {
            Ext.destroy(startEl, endEl);
            this.renderHeaderElementsInternal([record]);
        } else {
            if (startEl) {
                if (!startData) {
                    Ext.destroy(startEl);
                } else {
                    this.updateZoneHeaderElement(startEl, startData);
                }
            }
            
            if (endEl) {
                if (!endData) {
                    Ext.destroy(endEl);
                } else {
                    this.updateZoneHeaderElement(endEl, endData);
                }
            }
        }
    }
    
}); 

/**
 @class Sch.plugin.TimeGap
 @extends Sch.plugin.Zones

 Plugin (ptype = 'scheduler_timegap') for highlighting unallocated slots of time for all resources. You can use the `getZoneCls` method to customize the css class of the "gaps".

 {@img scheduler/images/plugin-timegap.png}

 To add this plugin to scheduler:

        var scheduler = Ext.create('Sch.panel.SchedulerGrid', {
            ...

            resourceStore   : resourceStore,
            eventStore      : eventStore,

            plugins         : [
                Ext.create('Sch.plugin.TimeGap', {

                    getZoneCls : function (startDate, endDate) {
                        return 'myGapCls'
                    }
                })
            ]
        });

 */
Ext.define("Sch.plugin.TimeGap", {
    extend : "Sch.plugin.Zones",
    alias  : "plugin.scheduler_timegap",

    requires : [
        'Ext.data.JsonStore'
    ],

    /**
     * An empty function by default, but provided so that you can return a custom CSS class for each unallocated zone area
     * @param {Date} start The start date of the unallocated time slot
     * @param {Date} end The end date of the unallocated time slot
     * @return {String} The CSS class to be applied to the zone element
     */
    getZoneCls : Ext.emptyFn,

    init : function (scheduler) {

        this.store = new Ext.data.JsonStore({
            model : 'Sch.model.Range'
        });

        this.scheduler = scheduler;

        scheduler.mon(scheduler.eventStore, {
            load        : this.populateStore,
            update      : this.populateStore,
            remove      : this.populateStore,
            add         : this.populateStore,
            datachanged : this.populateStore,
            scope       : this
        });

        scheduler.on('viewchange', this.populateStore, this);

        this.schedulerView = scheduler.getSchedulingView();

        this.callParent(arguments);
    },

    populateStore : function (eventStore) {
        var eventsInView = this.schedulerView.getEventsInView(),
            timeGaps = [],
            viewStart = this.scheduler.getStart(),
            viewEnd = this.scheduler.getEnd(),
            l = eventsInView.getCount(),
            cursor = viewStart,
            eventStart,
            index = 0,
            r;

        // Sort by start time
        eventsInView.sortBy(function (r1, r2) {
            return r1.getStartDate() - r2.getStartDate();
        });

        r = eventsInView.getAt(0);

        while (cursor < viewEnd && index < l) {
            eventStart = r.getStartDate();

            if (!Sch.util.Date.betweenLesser(cursor, eventStart, r.getEndDate()) && cursor < eventStart) {
                timeGaps.push(new this.store.model({
                    StartDate : cursor,
                    EndDate   : eventStart,
                    Cls       : this.getZoneCls(cursor, eventStart) || ''
                }));
            }
            cursor = Sch.util.Date.max(r.getEndDate(), cursor);
            index++;
            r = eventsInView.getAt(index);
        }

        // Check if there's a gap between last cursor and view end time
        if (cursor < viewEnd) {
            timeGaps.push(new this.store.model({
                StartDate : cursor,
                EndDate   : viewEnd,
                Cls       : this.getZoneCls(cursor, viewEnd) || ''
            }));
        }

        // Don't refresh twice, the add will cause the zones to redraw
        this.store.removeAll(timeGaps.length > 0);
        this.store.add(timeGaps);
    }
});

/**
@class Sch.plugin.TreeCellEditing
@extends Ext.grid.plugin.CellEditing

A specialized "cell editing" plugin (ptype = 'scheduler_treecellediting'), purposed to correctly work with trees. Add it to your component (scheduler with tree view or gantt)
as usual grid plugin:

    var gantt = Ext.create('Gnt.panel.Gantt', {

        plugins             : [
            Ext.create('Sch.plugin.TreeCellEditing', {
                clicksToEdit: 1
            })
        ],
        ...
    })

This class allows us to do 'complex data editing', which is not supported by the regular CellEditing plugin or the Ext.grid.CellEditor which
 assumes a column is always tied to a single field existing on the grid store model (which is not the case for Gantt, dependencies, assignments etc).
*/
Ext.define('Sch.plugin.TreeCellEditing', {
    extend              : 'Ext.grid.plugin.CellEditing',
    alias               : 'plugin.scheduler_treecellediting',

    lockableScope       : 'locked',

    editorsStarted      : 0,

    init : function (pnl) {
        this._grid      = pnl;

        // This is used to prevent editing of readonly cells
        this.on('beforeedit', this.onMyBeforeEdit, this);

        this.callParent(arguments);
    },


    showEditor : function (ed) {
        var me      = this,
            field   = ed.field;

        if (!ed._cancelEdit) {
            ed._cancelEdit  = ed.cancelEdit;
            ed.cancelEdit   = me.myCancelEdit;
        }

        if (field.setSuppressTaskUpdate) field.setSuppressTaskUpdate(true);
        this.callParent(arguments);
        if (field.setSuppressTaskUpdate) field.setSuppressTaskUpdate(false);
    },

    /*
     * Checks if panel is not locked for editing, and prevents cell edits if needed
     */
    checkReadOnly : function() {
        var pnl = this._grid;

        if (!(pnl instanceof Sch.panel.TimelineTreePanel)) {
            pnl = pnl.up('tablepanel');
        }
        return !pnl.isReadOnly();
    },

    // @OVERRIDE - model set() method, since we need to do more than just a simple update of a Model field in certain editors
    // Check for 'applyChanges' method and call it if exists
    onEditComplete : function(ed, value, startValue) {
        var me = this;

        // if field instance contains applyChanges() method
        // then we delegate saving to it
        // TODO: though this is a dirty code and must be rethought
        if (ed.field.applyChanges) {
            ed.field.applyChanges(ed.field.task || me.context.record);
            // Calling parent with value === startValue makes it not to call record.set() method, we don't need it
            // to be called since changes are already applyed, but leaves all other functionality inplace.
            return me.callParent([ed, value, value]);
        }
        else {
            return me.callParent([ed, value, startValue]);
        }
    },


    myCancelEdit : function () {
        var me      = this,
            field   = me.field;

        if (field && field.applyChanges) {
            var instantUpdate = field.instantUpdate;

            // we force the field to persist "originalValue" back to the task
            field.instantUpdate = true;
            var result = me._cancelEdit.apply(this, arguments);
            field.instantUpdate = instantUpdate;

            return result;

        } else {
            return me._cancelEdit.apply(this, arguments);
        }
    },


    onMyBeforeEdit : function(sender, context) {

        var field               = context.column.getEditor();

        //When an editor is already active we should call completeEdit because else the new task
        //is set before completeEdit is called (in showEditor)
        if (this.editing) {
            this.completeEdit();
        }

        if (field) {
            // if it's a field mixed with TaskField mixin
            if (field.setTask) {
                // then after setTask calling field already has correct value
                field.setTask(context.record);
                context.value = context.originalValue = field.getValue();
            }
        }

        return this.checkReadOnly();
    }

});

/**
@class Sch.plugin.ResourceZones
@extends Sch.feature.AbstractTimeSpan

A plugin (ptype = 'scheduler_resourcezones') for visualizing resource specific meta data such as availability, used internally by the Scheduler.
To use this feature, assign an {@link Sch.data.EventStore eventStore} to the {@link Sch.mixin.SchedulerPanel#cfg-resourceZones resourceZones}  
config on the main Scheduler panel class. Additionally, you can provide the {@link Sch.mixin.SchedulerPanel#cfg-resourceZonesConfig resourceZonesConfig} object
with configuration options.

    {
         xtype           : 'schedulergrid',
         region          : 'center',
         startDate       : new Date(2013, 0, 1),
         endDate         : new Date(2014, 0, 1),
         resourceStore   : new Sch.data.ResourceStore(),
         resourceZones   : new Sch.data.EventStore(), // Meta events such as availabilities can be visualized here
         resourceZonesConfig : {
            innerTpl                : '... customized template here ...'
         },
         eventStore      : new Sch.data.EventStore()  // Regular tasks in this store
    },

Records in the store should be regular {@link Sch.model.Event events} where you can specify the Resource, StartDate, EndDate and Cls (to set a CSS class on the rendered zone).
*/
Ext.define("Sch.plugin.ResourceZones", {
    extend              : 'Sch.plugin.Zones',
    alias               : 'plugin.scheduler_resourcezones',

    /**
     * @cfg {String/Ext.XTemplate} innerTpl A template providing additional markup to render into each timespan element
     */
    innerTpl            : null,

    /**
    * @cfg {Sch.data.EventStore} store (required) The store containing the meta 'events' to be rendered for each resource
    */
    store               : null,

    cls                 : 'sch-resourcezone',

    init : function(scheduler) {
        // unique css class to be able to identify the elements belonging to this instance
        this.uniqueCls = this.uniqueCls || ('sch-timespangroup-' + Ext.id());

        this.scheduler = scheduler;

        scheduler.registerRenderer(this.renderer, this);

        if (Ext.isString(this.innerTpl)) {
            this.innerTpl = new Ext.XTemplate(this.innerTpl);
        }

        var innerTpl = this.innerTpl;

        if (!this.template) {
            this.template = new Ext.XTemplate(
                '<tpl for=".">' +
                    '<div id="' + this.uniqueCls + '-{id}" class="' + this.cls + ' ' + this.uniqueCls + ' {Cls}" style="' + (scheduler.rtl ? 'right' : 'left') + ':{start}px;width:{width}px;top:{start}px;height:{width}px;{style}">' +
                    (innerTpl ? '{[this.renderInner(values)]}' : '') +

                    '</div>' +
                    '</tpl>',
                {
                    renderInner : function(values) {
                        return innerTpl.apply(values);
                    }
                }
            );
        }

        this.storeListeners = {
            load            : this.fullRefresh,
            datachanged     : this.fullRefresh,
            clear           : this.fullRefresh,

            // Ext JS
            add             : this.fullRefresh,
            remove          : this.fullRefresh,
            update          : this.refreshSingle,

            // Sencha Touch
            addrecords      : this.fullRefresh,
            removerecords   : this.fullRefresh,
            updaterecord    : this.refreshSingle,

            scope           : this
        };

        this.store.on(this.storeListeners);
    },

    destroy : function() {
        this.store.un(this.storeListeners);

        this.callParent(arguments);
    },

    fullRefresh : function() {
        this.scheduler.getSchedulingView().refresh();
    },

    renderer : function (val, meta, resource, rowIndex) {
        if (this.scheduler.getOrientation() === 'horizontal' || rowIndex === 0) {
            return this.renderZones(resource);
        }

        return '';
    },

    renderZones : function (resource) {
        var zoneStore = this.store,
            scheduler = this.scheduler,
            viewStart = scheduler.timeAxis.getStart(),
            viewEnd = scheduler.timeAxis.getEnd(),
            data = [],
            zonesForResource = resource.getEvents(zoneStore),
            spanStartDate, spanEndDate;

        for (var i = 0, len = zonesForResource.length; i < len; i++) {
            var record   = zonesForResource[i];

            spanStartDate = record.getStartDate();
            spanEndDate = record.getEndDate();

            // Make sure resource exists in resourceStore (filtering etc)
            if (spanStartDate && spanEndDate &&
                // Make sure this zone is inside current view
                Sch.util.Date.intersectSpans(spanStartDate, spanEndDate, viewStart, viewEnd)
            ) {
                var renderData = scheduler.getSchedulingView()[scheduler.getOrientation()].getEventRenderData(record);
                var start, width;

                if (scheduler.getMode() === 'horizontal') {
                    start = scheduler.rtl ? renderData.right : renderData.left;
                    width = renderData.width;
                } else {
                    start = renderData.top;
                    width = renderData.height;
                }

                data[data.length] = Ext.apply({
                    id      : record.internalId,

                    start   : start,
                    width   : width,

                    Cls     : record.getCls()
                }, record.data);
            }
        }

        return this.template.apply(data);
    },

    refreshSingle : function(store, record) {
        var el = Ext.get(this.uniqueCls + '-' + record.internalId);

        if (el) {
            var scheduler = this.scheduler,
                viewStart = scheduler.timeAxis.getStart(),
                viewEnd = scheduler.timeAxis.getEnd();

            var start       = Sch.util.Date.max(viewStart, record.getStartDate()),
                end         = Sch.util.Date.min(viewEnd, record.getEndDate()),
                cls         = record.getCls();

            var startPos = scheduler.getSchedulingView().getCoordinateFromDate(start);
            var width = scheduler.getSchedulingView().getCoordinateFromDate(end) - startPos;

            // Reapply CSS classes
            el.dom.className = this.cls + ' ' + this.uniqueCls + ' ' + (cls || '');

            el.setStyle({ left : startPos+'px', top : startPos+'px', height : width+'px', width : width+'px' });
        }
    }
});
/**
@class Sch.plugin.HeaderZoom
@extends Sch.util.DragTracker

This plugin (ptype = 'scheduler_headerzoom') enables zooming to a timespan selected using drag drop in the header area of the scheduler panel.

Zooming will be performed to the nearest zooming level that will make all columns to fit in the scheduling view width,
additionally a column width of that zooming level will be slightly adjusted to improve the fit.

After zooming, the selected time span will appear centered in the scheduling view.

**NOTE*: This plugin only supports panels in horizontal orientation.

To add this plugin to scheduler:

        var s1  = new Sch.panel.SchedulerGrid({
            ...
                
            plugins     : [
                new Sch.plugin.HeaderZoom(),

                // or lazy style definition
                'scheduler_headerzoom'
            ]
        })
    
*/
Ext.define("Sch.plugin.HeaderZoom", {
    extend        : "Sch.util.DragTracker",
    mixins        : [ 'Ext.AbstractPlugin' ],
    alias         : 'plugin.scheduler_headerzoom',
    lockableScope : 'top',

    scheduler      : null,
    proxy          : null,
    headerRegion   : null,

    init : function (scheduler) {

        this.scheduler      = scheduler;

        this.onModeChange();

        scheduler.on('modechange', this.onModeChange, this);
    },
    
    onOrientationChange : function () {
        return this.onModeChange.apply(this, arguments);
    },
    
    onModeChange   : function () {
        var timeAxisColumn = this.scheduler.down('timeaxiscolumn');
        
        if (timeAxisColumn) {
            
            if (timeAxisColumn.rendered) {
                this.onTimeAxisColumnRender(timeAxisColumn);
            } else {
                timeAxisColumn.on({
                    afterrender : this.onTimeAxisColumnRender,
                    scope       : this
                });
            }
        }
    },

    onTimeAxisColumnRender : function (column) {
        this.proxy = column.el.createChild({ cls : 'sch-drag-selector' });

        this.initEl(column.el);
    },

    
    onStart : function (e) {
        this.proxy.show();

        this.headerRegion   = this.scheduler.normalGrid.headerCt.getRegion();
    },

    
    onDrag : function (e) {
        var headerRegion    = this.headerRegion;
        var dragRegion      = this.getRegion().constrainTo(headerRegion);
        
        dragRegion.top      = headerRegion.top;
        dragRegion.bottom   = headerRegion.bottom;

        this.proxy.setBox(dragRegion);
    },

    
    onEnd : function (e) {
        if (this.proxy) {
            this.proxy.setDisplayed(false);

            var scheduler   = this.scheduler;
            var timeAxis    = scheduler.timeAxis;
            var region      = this.getRegion();
            var unit        = scheduler.getSchedulingView().timeAxisViewModel.getBottomHeader().unit;
            var range       = scheduler.getSchedulingView().getStartEndDatesFromRegion(region);
            
            scheduler.zoomToSpan({
                start   : timeAxis.floorDate(range.start, false, unit, 1),
                end     : timeAxis.ceilDate(range.end, false, unit, 1)
            });
        }
    },

    
    destroy : function () {
        if (this.proxy) {
            Ext.destroy(this.proxy);

            this.proxy = null;
        }

        this.callParent(arguments);
    }
});
/**

@class Sch.plugin.CellPlugin
@extends Ext.AbstractPlugin
@mixin Ext.util.Observable

This plugin allow user to navigate through cells using arrow keys or simple clicking, creating/editing events
and perform selection. Plugin is built on "1 cell - 1 event" logic and tested over that,
using this plugin under different conditions may lead to unpredictable results.

NOTES:
1) supports only horizontal view
2) Tested mainly for 'table' event layout, 'horizontal' works, but you may experience some glitches

*/
Ext.define('Sch.plugin.CellPlugin', {
    extend          : 'Ext.AbstractPlugin',
    alias           : 'plugin.scheduler_cellplugin',

    requires        : ['Ext.form.field.Base'],

    mixins          : {
        observable      : 'Ext.util.Observable'
    },

    /**
     * @cfg {String} frameCls CSS class of the plugin container div.
     */
    frameCls        : 'sch-cellplugin-highlighter',

    /**
     * @cfg {Ext.Template/Ext.XTemplate} frameTemplate A template providing markup for plugin.
     */
    frameTemplate   : new Ext.Template([
        '<div class="{cls} active" style="width: {width}px; height: {height}px;">',
            '<div class="sch-cellplugin-border sch-cellplugin-border-horizontal sch-cellplugin-border-top"></div>',
            '<div class="sch-cellplugin-border sch-cellplugin-border-horizontal sch-cellplugin-border-bottom"></div>',
            '<div class="sch-cellplugin-border sch-cellplugin-border-vertical sch-cellplugin-border-left"></div>',
            '<div class="sch-cellplugin-border sch-cellplugin-border-vertical sch-cellplugin-border-right"></div>',
        '</div>'
    ]),

    /**
     * @cfg {String/Object/Ext.form.field.Field} editor Configuration for the {@link Sch.field.CellEditor}.
     *
     * Examples:
     *
     *      @example
     *      // Simple string config:
     *      var plugin1 = new Sch.plugin.CellPlugin({
     *          editor  : 'Ext.form.field.Text'
     *      });
     *
     *      // {@link Sch.field.CellEditor} config
     *      var plugin2 = new Sch.plugin.CellPlugin({
     *          editor  : {
     *              dateFormat  : 'H:i',
     *              divider     : ' '
     *          }
     *      });
     *
     *      // Custom field
     *      Ext.define('MyEditor', {
     *          extend  : 'Ext.form.field.Trigger'
     *      });
     *
     *      var plugin3 = new Sch.plugin.CellPlugin({
     *          editor  : new MyEditor()
     *      });
     *
     */
    editor          : 'Sch.field.CellEditor',

    /**
     * @cfg {Boolean} singleClickEditing If true editing mode will be set on plugin on a single click in the cell.
     */
    singleClickEditing  : true,

    /**
     * @cfg {Integer} dblClickTimeout Timeout required to catch cell double click event if {@link #singleClickEditing} is true
     */
    dblClickTimeout : 100,

    clickTimer      : [],

    editing         : false,

    /**
     * @property {Object} context Object containing information about current selection. Isn't used for navigation purposes.
     * @property {Date} context.startDate Start date of selected tick
     * @property {Date} context.endDate End date of selected tick
     * @property {Sch.model.Resource} context.resource Selected resource
     * @private
     */
    context         : {},

    /**
     * @property {Object[]} selContext Array of {@link #context} objects for multiple selection. Doesn't contain
     * currently selected cell.
     * @private
     */
    selContext      : [],

    /**
     * @event cellclick
     * Fires when cell click performed and not intercepted by double click. Return false to prevent handling.
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Integer} tickIndex Current tick
     * @param {Integer} resourceIndex Current resource
     */

    /**
     * @event celldblclick
     * Fires when cell double click performed. Return false to prevent handling.
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Integer} tickIndex Current tick
     * @param {Integer} resourceIndex Current resource
     */

    /**
     * @event beforeselect
     * Fires before cell is selected. Return false to prevent selection.
     *
     * @param {Sch.view.TimelineGridView} view Scheduling view
     * @param {Sch.model.Resource} resource Currently selected resource
     * @param {Date} startDate Current tick start date
     * @param {Date} endDate Current tick end date
     */

    /**
     * @event select
     * Fires after cell is selected.
     *
     * @param {Sch.view.TimelineGridView} view Scheduling view
     * @param {Sch.model.Resource} resource Currently selected resource
     * @param {Date} startDate Current tick start date
     * @param {Date} endDate Current tick end date
     */

    /**
     * @event selectionchange
     * Fires after {@link #select} event.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */

    /**
     * @event beforecelledit
     * Fires before cell enters editing mode. Return false to prevent editing.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */

    /**
     * @event begincelledit
     * Fires after {@link #select} event.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */

    /**
     * @event beforecompletecelledit
     * Fires before cell enters editing mode. Return false to continue editing cell.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */

    /**
     * @event completecelledit
     * Fires before cell enters editing mode. Return false to continue editing cell.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */

    /**
     * @event beforecancelcelledit
     * Fires before cell editing is cancelled. Return false to continue editing cell.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */

    /**
     * @event cancelcelledit
     * Fires after cell editing is cancelled.
     *
     * @param {Sch.plugin.CellPlugin} this Plugin instance
     * @param {String} value Editor value
     * @param {Object[]} selection Current selection
     * @param {Sch.model.Resource} selection.resource Currently selected resource
     * @param {Date} selection.startDate Current tick start date
     * @param {Date} selection.endDate Current tick end date
     */

    constructor : function (cfg) {
        Ext.apply(this, cfg || {}, {
            context         : {},
            editing         : false,

            tickIndex       : null,
            resource        : null,
            startDate       : null,

            // index of currently selected event in cell
            eventIndexInCell    : -1,
            // currently selected event
            eventRecord         : null
        });

        this.mixins.observable.constructor.call(this);

        this.callParent(arguments);
    },

    init  : function (scheduler) {
        var me          = this;
        me.view         = scheduler.getSchedulingView();

        me.lockedView   = scheduler.lockedGrid.getView();
        // disable default grid key navigation to handle multiple cell events

        // HACK keynav couldn't be disabled using config http://www.sencha.com/forum/showthread.php?296161
        scheduler.getNavigationModel().setPosition = Ext.emptyFn;

        me.timeAxisViewModel    = scheduler.timeAxisViewModel;

        me.tickCount    = scheduler.timeAxis.getCount();
        me.rowsCount    = scheduler.resourceStore.getCount();

        me.keyNav = new Ext.util.KeyNav({
            target: scheduler.lockedGrid.view,
            eventName: 'itemkeydown',
            processEvent: function(view, record, node, index, event) {
                return event;
            },
            ignoreInputFields: true,
            up      : this.onKeyUp,
            down    : this.onKeyDown,
            right   : this.onKeyRight,
            left    : this.onKeyLeft,
            tab     : this.onKeyTab,
            enter   : this.onKeyEnter,
            esc     : this.onKeyEsc,
            scope   : this
        });

        if (me.view.bufferedRenderer) {
            me.view.on('afterrender', function () {
                me.view.el.on('scroll', me.onViewScroll, me);
            }, me, { single : true });

            me.mon(me.view, 'itemadd', me.onItemAdd, me);
        }

        me.mon(scheduler, {
            headerclick         : me.onContainerClick,
            zoomchange          : me.destroyHighlighter,
            scope               : me
        });

        me.mon(me.view, {
            containerclick      : me.onContainerClick,
            scheduleclick       : me.onCellClick,
            scheduledblclick    : me.onCellDblClick,
            eventclick          : me.onEventClick,
            eventdblclick       : me.onEventDblClick,
            // in case editor doesn't allow 'keydown' events we listem them on view
            containerkeydown    : me.onEditorKeyDown,
            groupcollapse       : me.onGroupCollapse,
            groupexpand         : me.onGroupExpand,
            scope               : me
        });

        me.mon(me.timeAxisViewModel, {
            update              : me.onViewModelUpdate,
            scope               : me
        });

        me.mon(me.view.timeAxis, {
            beforereconfigure   : me.onBeforeReconfigure,
            scope               : me
        });

        me.mon(me.view.resourceStore, {
            load                : me.onResourceLoad,
            add                 : me.onResourceAdd,
            remove              : me.onResourceRemove,
            clear               : me.destroyHighlighter,
            scope               : me
        });

        me.mon(me.view.eventStore, {
            load                : me.destroyHighlighter,
            scope               : me
        });

        me.mon(me.lockedView, {
            cellclick           : me.onLockedCellClick,
            beforeitemkeydown   : me.onBeforeItemKeyDown,
            scope               : me
        });
    },

    onEditorKeyDown : function (view, e, eOpts) {
        switch (e.getKey()) {
            case e.TAB    :
                e.preventDefault();

                if (e.shiftKey) {
                    this.moveLeft(e);
                } else {
                    this.moveRight(e);
                }
                break;
            case e.ENTER  :
                this.onEditorKeyEnter();
                break;
            case e.ESC    :
                this.cancelEdit(e);
                break;
            default : break;
        }
    },

    onEditorKeyEnter    : function () {
        if (this.completeEdit()) {
            this.beginEditBelow();
        } else {
            this.showEditorInCell(this.getEventOrCell(this.context, true));
        }
    },

    destroy : function () {
        this.keyNav.destroy();
    },

    destroyHighlighter  : function () {
        var me = this;

        me.clearSelection();
        me.containerEl && me.containerEl.destroy();

        delete me.containerEl;
        delete me.startDate;
        delete me.resource;
        delete me.resourceIndex;
        delete me.eventRecord;

        delete me.tickIndex;
    },

    onGroupCollapse     : function () {
        var me = this;

        me.rowsCount = me.view.getNodes().length;

        if (me.getResourceIndex() === -1) {
            me.destroyHighlighter();
        } else {
            me.refreshCell();
        }
    },

    onGroupExpand       : function () {
        var me = this;

        me.rowsCount = me.view.getNodes().length;
        me.refreshCell();
    },

    onViewScroll        : function () {
        var me = this;

        if (me.containerEl) {
            var node        = Ext.get(me.view.getNodeByRecord(me.resource));
            if (node) {
                me.containerEl.setY(node.getY() - 1);
            }
        }
    },

    onItemAdd    : function () {
        var me      = this;

        if (!me.resource) return;

        var node = me.view.getNodeByRecord(me.resource);

        // record is rendered to view
        if (node) {
            me.containerEl.show();
        } else {
            me.containerEl.hide();
        }
    },

    getResourceIndex    : function (resource) {
        var me      = this;
        resource    = resource || me.resource;

        // dataSource.indexOf will return index of this record in main store
        // we need index of this record in dataSource store, so we add 'data' property
        return me.view.dataSource.data.indexOf(resource);
    },

    getResource         : function (resourceIndex) {
        return this.view.dataSource.getAt(resourceIndex);
    },

    onResourceLoad      : function (store, records, successful) {
        if (successful) {
            this.rowsCount  = records.length;
        }
    },

    onResourceAdd       : function (store, records) {
        this.rowsCount += records.length;

        this.refreshCell();
    },

    onResourceRemove    : function (store, records, index, isMove) {
        var me = this;

        me.rowsCount = store.getCount();

        // if all rows are removed we should also remove box
        if (me.rowsCount === 0) {
            me.destroyHighlighter();
        }
        // TODO: also check if selection should be partially removed

        // currently selected row is removed
        if (Ext.Array.indexOf(records, me.resource) !== -1) {
            me.destroyHighlighter();
        }

        me.refreshCell();
    },

    onBeforeReconfigure : function (timeAxis) {
        // save editor position only if it wasn't saved before
        if (!this.startDate && Ext.isNumber(this.tickIndex)) {
            this.startDate = timeAxis.getAt(this.tickIndex).getStartDate();
        }
    },

    onLockedCellClick : function (lockedView, td, cellIndex, record, tr, rowIndex, e) {
        this.showEditorInCell({
            tickIndex       : this.tickIndex || 0,
            resourceIndex   : rowIndex,
            eventIndexInCell: 0
        }, e);
    },

    // this method is responsible for type-away behavior
    onBeforeItemKeyDown : function (lockedView, record, item, index, e, eOpts) {
        if (!e.isSpecialKey()) {
            this.beginEdit();
        }
    },

    onViewModelUpdate : function (timeAxisViewModel) {
        var me          = this,
            timeAxis    = timeAxisViewModel.timeAxis;

        me.tickCount    = timeAxis.getCount();

        // if selection was active before reconfigure we should try to show editor
        if (me.startDate) {
            var newTick     = timeAxis.getTickFromDate(me.startDate);

            if (newTick >= 0) {
                // remove saved editor position
                delete me.startDate;

                me.tickIndex = newTick;

                if (!me.containerEl) {
                    me.renderElement();
                }
                me.refreshCell();
            } else {
                me.containerEl.destroy();
                delete me.containerEl;

                me.clearSelection();
            }
        } else {
            me.refreshCell();
        }
    },

    refreshCell         : function () {
        var me      = this;
        var width   = me.timeAxisViewModel.getTickWidth();

        if (me.containerEl) {
            me.containerEl.setWidth(width);
            me.containerEl.setLeft(width);

            me.showEditorInCell({
                tickIndex       : me.tickIndex,
                resourceIndex   : me.getResourceIndex()
            });
        }

        if (me.editor instanceof Ext.form.field.Base) {
            me.editor.setMaxWidth(width);
        }
    },

    clearSelection      : function () {
        var me = this;

        me.view.getSecondaryCanvasEl().select('.' + me.frameCls + '.clone').remove();
        me.selContext = [];
    },

    addSelection        : function () {
        var me          = this;

        // cloning container element leads to id issues in IE9
        var clone       = me.frameTemplate.apply({
            cls     : me.frameCls,
            width   : me.containerEl.getWidth(),
            height  : me.containerEl.getHeight()
        });
        clone = Ext.get(Ext.DomHelper.append(me.containerEl.parent(), clone));

        clone.setStyle('top', me.containerEl.getStyle('top'));
        clone.setStyle('left', me.containerEl.getStyle('left'));

        clone.removeCls('active');
        clone.addCls('clone');

        me.selContext.push(Ext.apply({}, me.context));
    },

    renderElement       : function () {
        var me = this;

        me.containerEl          = me.view.getSecondaryCanvasEl();

        var width               = me.timeAxisViewModel.getTickWidth();
        var height              = me.timeAxisViewModel.getViewRowHeight();

        var el                  = me.frameTemplate.apply({
            cls     : me.frameCls,
            width   : width,
            height  : height
        });

        me.containerEl = Ext.get(Ext.DomHelper.append(me.containerEl, el));

        var defaultCfg = {
            height      : height,
            maxHeight   : height,
            width       : width,
            maxWidth    : width,
            renderTo    : me.containerEl
        };

        if (Ext.isObject(me.editor) && !(me.editor instanceof Ext.Base)) {
            me.editor = Ext.create(Ext.apply(defaultCfg, me.editor, { xclass : 'Sch.field.CellEditor' }));
        } else if (Ext.isString(me.editor)) {
            me.editor = Ext.create(me.editor, defaultCfg);
        } else {
            // editor is instance of form.field.Base
            me.containerEl.appendChild(me.editor.el);
        }
    },

    // for correct work we should always keep focus on elements in locked grid
    onContainerClick    : function () {
        var me = this;

        if (me.lockedView.getSelectionModel().getSelection().length > 0) {
            // focus row from locked grid only if one is selected and we are not editing cell
            if (me.editor.isVisible && me.editor.isVisible()) {
                me.lockedView.getFocusEl().focus();
            }
        }
    },

    onCellClick : function (view, date, rowIndex, resource, e) {
        var me = this;

        me.clickTimer.push(setTimeout(function () {
            me.handleCellClick(view, date, rowIndex, resource, e);
        }, me.dblClickTimeout));
    },

    handleCellClick     : function (view, date, rowIndex, resource, e) {
        var me = this;

        var colIndex    = Math.floor(me.view.timeAxis.getTickFromDate(date));

        if (me.fireEvent('cellclick', me, colIndex, rowIndex) !== false) {
            me.showEditorInCell({
                tickIndex       : colIndex,
                resourceIndex   : rowIndex
            }, e);

            if (me.singleClickEditing) {
                me.beginEdit();
            }
        }
    },

    onCellDblClick      : function (view, date, rowIndex, resource, e) {
        Ext.each(this.clickTimer, function (timer) {
            clearTimeout(timer);
        });

        this.handleCellDblClick(view, date, rowIndex, resource, e);
    },

    handleCellDblClick  : function (view, date, rowIndex, resource, e) {
        var me = this;

        var colIndex    = Math.floor(me.view.timeAxis.getTickFromDate(date));

        if (me.fireEvent('celldblclick', me, colIndex, rowIndex) !== false) {
            me.showEditorInCell({
                tickIndex       : colIndex,
                resourceIndex   : rowIndex
            }, e);
            me.beginEdit();
        }
    },

    onEventClick        : function (view, eventRecord, e) {
        var me      = this;
        var date    = me.view.getDateFromDomEvent(e);
        var col     = Math.floor(me.view.timeAxis.getTickFromDate(date));
        // in case of grouped view we can't lookup indices in main store
        var row     = me.view.dataSource.data.indexOf(eventRecord.getResource());

        me.showEditorInCell({
            tickIndex       : col,
            resourceIndex   : row,
            eventRecord     : eventRecord
        }, e);
    },

    onEventDblClick     : function (view, eventRecord, e) {
        var me      = this;
        var date    = me.view.getDateFromDomEvent(e);
        var col     = Math.floor(me.view.timeAxis.getTickFromDate(date));
        // in case of grouped view we can't lookup indices in main store
        var row     = me.view.dataSource.data.indexOf(eventRecord.getResource());

        me.showEditorInCell({
            tickIndex       : col,
            resourceIndex   : row,
            eventRecord     : eventRecord
        }, e);
        me.beginEdit();
    },

    // resource record is optional param
    showEditorInCell    : function (params, e) {
        var me      = this;

        var col     = 'tickIndex' in params ? params.tickIndex : me.tickIndex;
        var row     = 'resourceIndex' in params ? params.resourceIndex : me.resourceIndex;

        if (col === -1 || row === -1) return;

        var tick        = me.view.timeAxis.getAt(col);
        var startDate   = tick.getStartDate();
        var endDate     = tick.getEndDate();
        // in case view is configured with grouping feature
        // and there is at least one collapsed group
        // we have to lookup resources like this
        var resource    = me.view.dataSource.getAt(row);

        // user clicked on locked cell or normal cell (only if event layout is not table)
        if (e && e.type === 'click' && !params.eventRecord) {
            params.eventRecord = me.getCellEvents({
                startDate   : startDate,
                endDate     : endDate,
                resource    : resource
            }).getAt(0);
        }

        if (me.fireEvent('beforeselect', me, resource, startDate, endDate, params.eventRecord) === false) {
            return;
        }

        me.onBeforeSelect(e);

        if (!me.containerEl) {
            me.renderElement();
        } else {
            if (e && e.ctrlKey) {
                me.addSelection();
            } else {
                me.clearSelection();
            }
        }

        Ext.apply(me.context, {
            startDate       : startDate,
            endDate         : endDate,
            resource        : resource
        });

        if (params.eventRecord) {
            me.context.eventRecord = params.eventRecord;
        } else {
            delete me.context.eventRecord;
        }

        me.tickIndex    = col;
        me.resource     = resource;
        me.resourceIndex = row;
        me.eventIndexInCell   = params.eventIndexInCell;

        if (params.eventRecord) {
            me.alignEditorWithRecord(params.eventRecord, params.resource);
        } else {
            me.alignEditorWithCell();
        }

        me.onAfterSelect(e);

        me.fireEvent('select', me, resource, startDate, endDate);
        // TODO: append check for actual selection change
        me.fireEvent('selectionchange', me, me.getSelection());
    },

    alignEditorWithRecord   : function(eventRecord, resourceRecord) {
        var me = this;

        // some enhancements to make box visible
        // TODO: use z-index or wrap box around event body
        var els = me.view.getElementsFromEventRecord(eventRecord, resourceRecord),
            box = els[0].getBox();
        box.y--;
        box.x--;
        me.alignEditor(box);
    },

    alignEditorWithCell : function () {
        var me = this;

        var node = Ext.get(me.view.getRowByRecord(me.resource));
        node && me.alignEditor({
            left    : me.timeAxisViewModel.getTickWidth() * me.tickIndex,
            y       : node.getTop() - 1,
            height  : node.getHeight(),
            width   : me.timeAxisViewModel.getTickWidth()
        });
    },

    alignEditor : function (box) {
        var me = this;

        me.containerEl.setY(box.y);
        // 'x' key is passed when box is positioned using event element - absolute coordinates
        if ('x' in box) {
            me.containerEl.setX(box.x);
        } else {
            me.containerEl.setLeft(box.left);
        }

        me.containerEl.setWidth(box.width);
        me.containerEl.setHeight(box.height);

        if (Ext.isIE8m) {
            me.containerEl.setHeight(box.height + 1);
            // top border is hidden in some cases, this style is fixing that
            me.containerEl.setStyle('padding-top', 1);
            me.containerEl.select('.sch-cellplugin-border-top').setStyle('top', 1);
            // height/width is inherited in IE8 bug display is buggy
            me.containerEl.select('.sch-cellplugin-border-vertical').setHeight(box.height);
            me.containerEl.select('.sch-cellplugin-border-horizontal').setWidth(box.width);
        } else if (Ext.isChrome) {
            // chrome 43 is buggy too, height isn't inherited correctly
            me.containerEl.select('.sch-cellplugin-border-vertical').setHeight(box.height);
        }

        me.containerEl.show();
    },

    getSelection    : function () {
        return this.selContext.concat(this.context);
    },

    /**
     * @method getEventRecord
     * Accepts current context (selected cell) and should always return one event record.
     * @param {Object} context
     * @param {Sch.model.Resource} context.resource Selected resource
     * @param {Date} context.startDate Current cell start date
     * @param {Date} context.endDate Current cell end date
     * @return {Sch.model.Event}
     */
    getEventRecord  : function (context) {
        return context.eventRecord;
    },

    /**
     * @method getResourceRecord
     * Accepts current context (selected cell) and should always return one resource record.
     * @param {Object} context
     * @param {Sch.model.Resource} context.resource Selected resource
     * @param {Date} context.startDate Current cell start date
     * @param {Date} context.endDate Current cell end date
     * @return {Sch.model.Resource}
     */
    getResourceRecord : function (context) {
        return context.resource;
    },

    onKeyUp : function (e) {
        this.moveUp(e);
    },

    onKeyDown   : function (e) {
        this.moveDown(e);
    },

    onKeyLeft   : function (e) {
        this.moveLeft(e);
    },

    onKeyRight  : function (e) {
        this.moveRight(e);
    },

    onKeyTab    : function (e) {
        if (e.shiftKey) {
            this.moveLeft(e);
        } else {
            this.moveRight(e);
        }
    },

    onKeyEnter  : function () {
        this.beginEdit();
    },

    onKeyEsc    : function () {
        this.destroyHighlighter();
    },

    findPreviousIndex   : function (e) {
        var me      = this;
        var index   = me.getResourceIndex();

        var prevRecord = me.view.walkRecs(me.resource, -1);

        if (prevRecord !== me.resource) {
            return me.getResourceIndex(prevRecord);
        } else {
            return -1;
        }
    },

    findNextIndex       : function (e) {
        var me      = this;
        var index   = me.getResourceIndex();

        var prevRecord = me.view.walkRecs(me.resource, 1);

        if (prevRecord !== me.resource) {
            return me.getResourceIndex(prevRecord);
        } else {
            return -1;
        }
    },

    getCellEvents   : function (context) {
        var me  = this;
        context = context || me.context;

        if (context.resourceIndex === -1 || context.tickIndex === -1) {
            return new Ext.util.MixedCollection();
        }

        var events = me.view.eventStore.queryBy(function (event) {
            return event.getResourceId() === context.resource.getId() &&
                   event.getStartDate()  >=  context.startDate &&
                   event.getStartDate()  <   context.endDate;
        });

        events.sortBy(function (a, b) {
            var aEl = me.view.getElementsFromEventRecord(a, context.resource)[0],
                bEl = me.view.getElementsFromEventRecord(b, context.resource)[0];

            return aEl.getY() < bEl.getY() ? -1 : 1;
        });

        return events;
    },

    getAbove    : function (context) {
        var me  = this,
            newEventIndex;

        context = context || me.context;

        // if event was clicked, we don't know relative index, have to calculate it
        if (context.eventRecord && me.eventIndexInCell == null) {
            me.eventIndexInCell = me.getCellEvents(context).indexOf(context.eventRecord);
        }

        // if box is currently on event in cell, check if we can just reduce the index
        if (me.eventIndexInCell > 0) {
            newEventIndex = me.eventIndexInCell - 1;

            return {
                eventIndexInCell    : newEventIndex,
                eventRecord         : me.getCellEvents(context).getAt(newEventIndex)
            };
        }

        var newResourceIndex = me.findPreviousIndex();

        // last expanded resource, cannot move down
        if (newResourceIndex === -1) {
            // have to return special index to exit routine later
            return { resourceIndex : -1 };
        }

        return me.getEventOrCell(Ext.applyIf({
            resourceIndex   : newResourceIndex
        }, context), true);
    },

    getBelow    : function (context) {
        var me  = this;

        context = context || me.context;

        // if event was clicked, we don't know relative index, have to calculate it
        if (context.eventRecord && me.eventIndexInCell == null) {
            me.eventIndexInCell = me.getCellEvents(context).indexOf(context.eventRecord);
        }

        if (me.eventIndexInCell >= 0) {
            var events  = me.getCellEvents(context);
            var newEventIndex = me.eventIndexInCell + 1;
            // we still have some events in cell
            if (events.getCount() > newEventIndex) {
                return {
                    eventIndexInCell    : newEventIndex,
                    eventRecord         : events.getAt(newEventIndex)
                };
            }
        }

        var newResourceIndex = me.findNextIndex();

        // last expanded resource, cannot move down
        if (newResourceIndex === -1) {
            return { resourceIndex : -1 };
        }

        return me.getEventOrCell(Ext.applyIf({
            resourceIndex   : newResourceIndex
        }, context));
    },

    /**
     * @method getEventOrCell
     * Moving box in horizontal direction should select first event in cell, or whole cell.
     * Method requires not only conventional context for next cell, but also new tickIndex and resourceIndex -
     * to avoid unnesessary lookups.
     * @param {Object} context Current {@link #context} updated with two optional properties:
     * @param {Integer} [context.tickIndex] Tick index of new cell. If not provided - current is used.
     * @param {Integer} [context.resourceIndex] Resource index of new cell. If not provided - current is used.
     * @param {Boolean} [pickLast=false] Pass true if you want to pick last event of cell
     *
     * @return {Object} Navigation params
     * @return {Integer} [return.tickIndex] New tick index, if box moved horizontally
     * @return {Integer} [return.resourceIndex] New resource index, if box moved vertically
     * @return {Integer} [return.eventIndexInCell] Index of the event to be selected, or null if cell is empty
     * @return {Sch.model.Event} [return.eventRecord] First/last event in cell or null, if there's no events
     * @private
     */
    getEventOrCell    : function (context, pickLast) {
        var me                  = this,
            eventIndexInCell    = -1,
            eventRecord         = null,
            tickIndex           = me.tickIndex,
            resourceIndex       = me.resourceIndex;

        // if tickIndex was provided, we have to update context for getCellEvents method
        if ('tickIndex' in context) {
            tickIndex = context.tickIndex;
            var tick = me.view.timeAxis.getAt(tickIndex);
            context.startDate   = tick.getStartDate();
            context.endDate     = tick.getEndDate();
        }

        if ('resourceIndex' in context) {
            resourceIndex = context.resourceIndex;
            context.resource = me.view.dataSource.getAt(resourceIndex);
        }

        var events = me.getCellEvents(context);
        if (events.getCount()) {
            if (pickLast === true) {
                eventIndexInCell = events.getCount() - 1;
                eventRecord = events.getAt(eventIndexInCell);
            } else {
                eventIndexInCell = 0;
                eventRecord = events.getAt(0);
            }
        }

        return {
            tickIndex           : tickIndex,
            resourceIndex       : resourceIndex,
            eventIndexInCell    : eventIndexInCell,
            eventRecord         : eventRecord
        };
    },

    getPrevious : function (context) {
        var me  = this;

        context = context || me.context;

        var resourceIndex = me.getResourceIndex();

        if (me.tickIndex > 0) {
            return me.getEventOrCell(Ext.applyIf({
                tickIndex   : me.tickIndex - 1
            }, context));
        } else {
            return me.getEventOrCell(Ext.applyIf({
                tickIndex       : me.tickCount - 1,
                resourceIndex   : me.findPreviousIndex()
            }, context));
        }
    },

    getNext     : function (context) {
        var me  = this;

        context = context || me.context;

        if (me.tickIndex < me.tickCount - 1) {
            return me.getEventOrCell(Ext.applyIf({
                tickIndex       : ++me.tickIndex,
                resourceIndex   : me.getResourceIndex()
            }, context));
        } else {
            return me.getEventOrCell(Ext.applyIf({
                tickIndex       : 0,
                resourceIndex   : me.findNextIndex()
            }, context));
        }
    },

    moveUp      : function (e) {
        var me = this;

        if (!me.containerEl) {
            return;
        }

        me.showEditorInCell(me.getAbove(), e);
    },

    moveDown    : function (e) {
        var me = this;

        if (!me.containerEl) {
            return;
        }

        me.showEditorInCell(me.getBelow(), e);
    },

    moveLeft    : function (e) {
        var me = this;

        if (!me.containerEl) {
            return;
        }

        me.showEditorInCell(me.getPrevious(), e);
    },

    moveRight   : function (e) {
        var me = this;

        if (!me.containerEl) {
            return;
        }

        me.showEditorInCell(me.getNext(), e);
    },

    expandResourceRow   : function (height) {
        var me = this;

        var resourceNode = Ext.get(me.view.getNodeByRecord(me.context.resource));
        var box = resourceNode.getBox();

        var record = me.getCellEvents().last();
        if (record) {
            var eventBox = me.view.getElementsFromEventRecord(record, me.context.resource)[0].getBox();

            if (Math.abs(eventBox.bottom - box.bottom) <= height) {
                resourceNode.setHeight(box.height + height);
                Ext.get(me.lockedView.getNodeByRecord(me.context.resource)).setHeight(box.height + height);

                me.__oldHeight = box.height;

                return box.bottom;
            } else {
                return eventBox.bottom;
            }
        }
    },

    collapseResourceRow : function () {
        var me = this;

        if (me.__oldHeight) {
            Ext.get(me.view.getNodeByRecord(me.context.resource)).setHeight(me.__oldHeight);
            Ext.get(me.lockedView.getNodeByRecord(me.context.resource)).setHeight(me.__oldHeight);

            delete me.__oldHeight;
        }
    },

    beginEditBelow  : function () {
        var me  = this;

        if (!me.containerEl) {
            return;
        }

        delete me.context.eventRecord;

        me.beginEdit();

        var height = me.timeAxisViewModel.getViewRowHeight();

        var bottom = me.expandResourceRow(height);

        me.alignEditor({
            left    : me.timeAxisViewModel.getTickWidth() * me.tickIndex,
            y       : bottom,
            width   : me.timeAxisViewModel.getTickWidth(),
            height  : height
        });
    },

    beginEdit   : function () {
        var me      = this;

        if (!me.containerEl) {
            return;
        }

        // such event makes sense only if user is provided with selection information
        // e.g. he selected readonly cell
        if (me.fireEvent('beforecelledit', me, me.getSelection()) === false) {
            return;
        }

        me.editing      = true;

        me.editor.startDate = me.context.startDate;
        me.editor.bottomUnit = Sch.util.Date.getSubUnit(me.timeAxisViewModel.getBottomHeader().unit);

        me.containerEl.select('.sch-cellplugin-border').hide();
        // set z-index in order to intercept clicks in editor
        me.containerEl.setStyle('z-index', 1);

        var event       = me.getEventRecord(me.context),
            resource    = me.getResourceRecord(me.context);

        if (event) {
            var date        = Ext.Date;

            // TODO: this should be implemented in editor, not here
            var format      = Ext.isArray(me.editor.dateFormat) ? me.editor.dateFormat[0] : me.editor.dateFormat;
            var startDate   = date.format(event.getStartDate(), format);
            var endDate     = date.format(event.getEndDate(), format);

            me.editor.record = event;

            me.editor.setValue([startDate, endDate].join(me.editor.divider));

            me.editor.recordNode = me.view.getElementsFromEventRecord(event, resource)[0];
            Ext.fly(me.editor.recordNode).hide();
        }

        me.editor.show();
        me.editor.setWidth(me.editor.getMaxWidth());
        me.editor.focus();

        me.fireEvent('begincelledit', me, me.getSelection());
    },

    cancelEdit      : function () {
        var me          = this;

        var value       = me.editor.getValue();
        var selection   = me.getSelection();

        if (me.fireEvent('beforecancelcelledit', me, value, selection) === false) {
            return;
        }

        me.stopEditing();

        me.fireEvent('cancelcelledit', me, value, selection);
    },

    completeEdit    : function () {
        var me          = this,
            addNewLine  = false;

        // plugin is not in editing mode
        if (!me.editing || !me.containerEl) {
            return;
        }

        var value = me.editor.getValue();
        var selection = me.getSelection();

        if (me.fireEvent('beforecompletecelledit', me, value, selection) === false) {
            return;
        }

        if (value && me.editor.isValid()) {
            var record  = me.editor.record;

            var UD      = Sch.util.Date;
            var unit    = UD.getSubUnit(me.timeAxisViewModel.getBottomHeader().unit);

            var dates   = me.editor.getDates(value);

            var startDate   = dates[0];
            var endDate     = dates[1];

            if (record) {
                record.setStartEndDate(startDate, endDate);
                delete me.editor.record;
            } else {
                var newRecord = new me.view.eventStore.model({
                    StartDate   : startDate,
                    EndDate     : endDate,
                    ResourceId  : me.context.resource.getId()
                });

                me.view.onEventCreated(newRecord);

                me.view.eventStore.add(newRecord);
            }

            addNewLine = true;
        }

        me.stopEditing();

        me.fireEvent('completecelledit', me, value, selection);

        return addNewLine;
    },

    // resets value, restores view to state before editing
    stopEditing     : function () {
        var me = this;

        if (me.editor.recordNode) {
            Ext.fly(me.editor.recordNode).show();
            delete me.editor.recordNode;
        }

        me.collapseResourceRow();

        me.editor.setValue('');

        me.editing  = false;
        me.clearSelection();

        me.containerEl.select('.sch-cellplugin-border').show();
        me.containerEl.setStyle('z-index', 'auto');
        me.editor.hide();

        var node = me.lockedView.getRowByRecord(me.resource);
        // TODO: in IE if locked grid will have more than 1 column this can mess scroll position
        node && Ext.fly(node).down('td').focus();
    },

    onBeforeSelect  : function (e) {
        var me = this;

        e && e.isNavKeyPress && e.isNavKeyPress() && me.clearSelection();

        me.restoreEditing = me.editing;
        me.editing && me.completeEdit();
    },

    onAfterSelect   : function (e) {
        var me = this;

        me.lockedView.getSelectionModel().select(me.resource);
        me.lockedView.getNodeByRecord(me.resource).focus();

        me.editor.setValue('');

        // we don't want to enable editing back if we changed cell using click
        // but also we want to enable editing using showEditorInCell(col, row, true) function
        if (me.restoreEditing && (e === true || e && e.isNavKeyPress())) {
            me.beginEdit();
        }
        me.restoreEditing = false;

        me.containerEl.scrollIntoView(me.view.getEl());
    }
});

/**
@class Sch.field.CellEditor
@extend Ext.form.field.Text

This class is used as an input element for {@link Sch.plugin.CellPlugin} plugin. Expect user to type values 
of the following format: {startDate}{divider}{endDate}. Both start and end dates have same format defined by
{@link #dateFormat} property. Divider is also configurable via {@link #divider} property.

NOTE: make sure divider isn't a part of date format. e.g. if dateFormat is set to 'H:i', divider cannot be colon character (:).
Otherwise it will lead to wrong results. 
 */
Ext.define('Sch.field.CellEditor', {
    extend          : 'Ext.form.field.Text',
    alias           : 'widget.celleditorfield',
    
    hidden          : true,

    enableKeyEvents : true,
    
    /**
     * @cfg {String} divider Character used for join/split value. e.g. 10-12 will be split to [10,12].
     */
    divider         : '-',
    
    /**
     * @cfg {String/String[]} dateFormat Date {@link Ext.Date.format} for parsing start/end dates from input value. 
     * If array is provided editor will return first succesfull parsed results.
     */
    dateFormat      : 'H',
    
    /**
     * Special implementation of {@link Ext.form.field.Field#getErrors} method. Checks if input value could be split
     * into two dates according to {@link #divider} and {@link #dateFormat} properties. 
     * @param {String} value
     * @return {String[]}
     */
    getErrors       : function (value) {
        var me      = this,
            result  = me.callParent(arguments);
                    
        if (value == null) return result;
        
        var dates   = this.getDates(value);
        
        if (!dates[0]) {
            result.push('Start date is incorrect');
        }
        
        if (!dates[1]) {
            result.push('End date is incorrect');
        }
        
        if (dates[1] - dates[0] < 0) {
            result.push('Start date is less then end date');
        }
        
        return result;
    },
    
    /**
     * This method parses start/end dates from user input. 
     * @param {String} value
     * @return {Date[]}
     */
    getDates    : function (value) {
        var me      = this;
        
        var values  = value.split(me.divider);
        var start, end;
        
        if (Ext.isArray(me.dateFormat)) {
            for (var i = 0; i < me.dateFormat.length; i++) {
                start   = start || Ext.Date.parse(values[0], me.dateFormat[i]);
                end     = end || Ext.Date.parse(values[1], me.dateFormat[i]); 
            }
        } else {
            start   = Ext.Date.parse(values[0], me.dateFormat);
            end     = Ext.Date.parse(values[1], me.dateFormat);
        }
        
        if (!start || !end) {
            return [];
        }
        
        if (me.record) {
            start   = Sch.util.Date.mergeDates(me.record.getStartDate(), start, me.bottomUnit);
            end     = Sch.util.Date.mergeDates(me.record.getEndDate(), end, me.bottomUnit);
        } else {
            start   = Sch.util.Date.mergeDates(me.startDate, start, me.bottomUnit);
            end     = Sch.util.Date.mergeDates(me.startDate, end, me.bottomUnit);
        }
        
        return [start, end];
    }
});
/**
@class Sch.widget.ResizePicker
@private
@extends Ext.Panel

Size picker widget for changing column width/rows height.

*/
Ext.define('Sch.widget.ResizePicker', {
    extend          : 'Ext.Panel',
    alias           : 'widget.dualrangepicker',
    width           : 200,
    height          : 200,
    border          : true,
    collapsible     : false,
    bodyStyle       : 'position:absolute; margin:5px',

    verticalCfg     : {
        height      : 120,
        value       : 24,
        increment   : 2,
        minValue    : 20,
        maxValue    : 80,
        reverse     : true,
        disabled    : true
    },

    horizontalCfg   : {
        width       : 120,
        value       : 100,
        minValue    : 25,
        increment   : 5,
        maxValue    : 200,
        disable     : true
    },

    initComponent : function () {
        var me = this;

        //me.addEvents('change', 'changecomplete', 'select');

        me.horizontalCfg.value  = me.dialogConfig.columnWidth;
        me.verticalCfg.value    = me.dialogConfig.rowHeight;
        me.verticalCfg.disabled = me.dialogConfig.scrollerDisabled || false;

        me.dockedItems = [
            me.vertical     = new Ext.slider.Single(Ext.apply({
                dock        : 'left',
                style       : 'margin-top:10px',
                vertical    : true,
                listeners   : {
                    change          : me.onSliderChange,
                    changecomplete  : me.onSliderChangeComplete,
                    scope           : me
                }
            }, me.verticalCfg)),

            me.horizontal   = new Ext.slider.Single(Ext.apply({
                dock        : 'top',
                style       : 'margin-left:28px',
                listeners   : {
                    change          : me.onSliderChange,
                    changecomplete  : me.onSliderChangeComplete,
                    scope           : me
                }
            }, me.horizontalCfg))
        ];

        me.callParent(arguments);
    },

    afterRender : function () {
        var me = this;

        me.addCls('sch-ux-range-picker');
        me.valueHandle = this.body.createChild({
            cls : 'sch-ux-range-value',
            cn  : {
                tag: 'span'
            }
        });
        me.valueSpan = this.valueHandle.down('span');

        var dd = new Ext.dd.DD(this.valueHandle);

        Ext.apply(dd, {
            startDrag   : function () {
                me.dragging = true;
                this.constrainTo(me.body);
            },
            onDrag      : function () {
                me.onHandleDrag.apply(me, arguments);
            },
            endDrag     : function () {
                me.onHandleEndDrag.apply(me, arguments);
                me.dragging = false;
            },
            scope       : this
        });

        this.setValues(this.getValues());
        this.callParent(arguments);

        this.body.on('click', this.onBodyClick, this);
    },

    onBodyClick: function (e, t) {
        var xy = [e.getXY()[0] - 8 - this.body.getX(), e.getXY()[1] - 8 - this.body.getY()];

        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));

        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
        this.onSliderChangeComplete();
    },

    getAvailableWidth: function () {
        return this.body.getWidth() - 18;
    },

    getAvailableHeight: function () {
        return this.body.getHeight() - 18;
    },

    onHandleDrag: function () {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
    },

    onHandleEndDrag: function () {
        this.setValues(this.getValuesFromXY([this.valueHandle.getLeft(true), this.valueHandle.getTop(true)]));
    },

    getValuesFromXY: function (xy) {
        var xFraction = xy[0] / this.getAvailableWidth();
        var yFraction = xy[1] / this.getAvailableHeight();

        var horizontalVal = Math.round((this.horizontalCfg.maxValue - this.horizontalCfg.minValue) * xFraction);
        var verticalVal = Math.round((this.verticalCfg.maxValue - this.verticalCfg.minValue) * yFraction) + this.verticalCfg.minValue;

        return [horizontalVal + this.horizontalCfg.minValue, verticalVal];
    },

    getXYFromValues: function (values) {
        var xRange = this.horizontalCfg.maxValue - this.horizontalCfg.minValue;
        var yRange = this.verticalCfg.maxValue - this.verticalCfg.minValue;

        var x = Math.round((values[0] - this.horizontalCfg.minValue) * this.getAvailableWidth() / xRange);

        var verticalVal = values[1] - this.verticalCfg.minValue;
        var y = Math.round(verticalVal * this.getAvailableHeight() / yRange);

        return [x, y];
    },

    updatePosition: function () {
        var values = this.getValues();
        var xy = this.getXYFromValues(values);

        this.valueHandle.setLeft(Ext.Number.constrain(xy[0], 0, this.getAvailableWidth()));
        if (this.verticalCfg.disabled){
            this.valueHandle.setTop(this.dialogConfig.rowHeight);
        } else {
            this.valueHandle.setTop(Ext.Number.constrain(xy[1], 0, this.getAvailableHeight()));
        }

        this.positionValueText();
        this.setValueText(values);
    },

    positionValueText: function () {
        var handleTop = this.valueHandle.getTop(true);
        var handleLeft = this.valueHandle.getLeft(true);

        this.valueSpan.setLeft(handleLeft > 30 ? -30 : 10);
        this.valueSpan.setTop(handleTop > 10 ? -20 : 20);
    },

    setValueText: function(values){
        if (this.verticalCfg.disabled) values[1] = this.dialogConfig.rowHeight;
        this.valueSpan.update('[' + values.toString() + ']');
    },

    setValues: function (values) {
        this.horizontal.setValue(values[0]);

        if (this.verticalCfg.reverse) {
            if (!this.verticalCfg.disabled) this.vertical.setValue(this.verticalCfg.maxValue + this.verticalCfg.minValue - values[1]);
        } else {
            if (!this.verticalCfg.disabled) this.vertical.setValue(values[1]);
        }

        if (!this.dragging) {
            this.updatePosition();
        }
        this.positionValueText();

        this.setValueText(values);
    },

    getValues: function () {
        if (!this.verticalCfg.disabled) {
            var verticalVal = this.vertical.getValue();

            if (this.verticalCfg.reverse) {
                verticalVal = this.verticalCfg.maxValue - verticalVal + this.verticalCfg.minValue;
            }

            return [this.horizontal.getValue(), verticalVal];

        }

        return [this.horizontal.getValue()];
    },

    onSliderChange: function () {
        this.fireEvent('change', this, this.getValues());

        if (!this.dragging) {
            this.updatePosition();
        }
    },

    onSliderChangeComplete: function () {
        this.fireEvent('changecomplete', this, this.getValues());
    },

    afterLayout: function () {
        this.callParent(arguments);
        this.updatePosition();
    }
});

/**
 @class Sch.widget.ExportDialogForm
 @private
 @extends Ext.form.Panel

 Form for {@link Sch.widget.ExportDialog}. This is a private class and can be overriden by providing `formPanel` option to
 {@link Sch.plugin.Export#cfg-exportDialogConfig exportDialogConfig}.
 */
Ext.define('Sch.widget.ExportDialogForm', {
    extend      : 'Ext.form.Panel',
    requires    : [
        'Ext.data.Store',
        'Ext.XTemplate',
        'Ext.ProgressBar',
        'Ext.form.field.ComboBox',
        'Ext.form.field.Date',
        'Ext.form.FieldContainer',
        'Ext.form.field.Checkbox',
        'Sch.widget.ResizePicker'
    ],

    border      : false,
    bodyPadding : '10 10 0 10',
    autoHeight  : true,

    initComponent : function () {
        var me = this;

        me.fieldDefaults    = Ext.applyIf(me.fieldDefaults || {}, {
            labelAlign      : 'left',
            labelWidth      : 120,
            anchor          : '99%'
        });

        me.items            = me.createFields();

        me.items.push(me.progressBar || me.createProgressBar());

        me.callParent(arguments);

        // trigger fields `change` listeners to enable/disable related fields
        me.onRangeChange(null, me.dialogConfig.exportConfig.range);
        me.onExporterChange(me.exportersField, me.exportersField.getValue());

        me.on({
            hideprogressbar     : me.hideProgressBar,
            showprogressbar     : me.showProgressBar,
            updateprogressbar   : me.updateProgressBar,
            scope               : me
        });
    },

    isValid : function () {
        var me  = this;
        if (me.rangeField.getValue() === 'date') return me.dateFromField.isValid() && me.dateToField.isValid();

        return true;
    },

    getValues : function (asString, dirtyOnly, includeEmptyText, useDataValues) {
        var result      = this.callParent(arguments);

        result.showHeader = !!result.showHeader;
        result.showFooter = !!result.showFooter;

        var cellSize    = this.resizePicker.getValues();
        if (!asString) {
            result.cellSize = cellSize;
        } else {
            result += '&cellSize[0]='+cellSize[0]+'&cellSize[1]='+cellSize[1];
        }

        return result;
    },

    createFields : function () {
        var me                  = this,
            cfg                 = me.dialogConfig,
            beforeLabelTextTpl  = '<table class="sch-fieldcontainer-label-wrap"><td width="1" class="sch-fieldcontainer-label">',
            afterLabelTextTpl   = '<td><div class="sch-fieldcontainer-separator"></div></table>',
            items = [];

        me.rangeField       = new Ext.form.field.ComboBox({
            value           : cfg.exportConfig.range,
            triggerAction   : 'all',
            cls             : 'sch-export-dialog-range',
            forceSelection  : true,
            editable        : false,
            fieldLabel      : cfg.rangeFieldLabel,
            name            : 'range',
            queryMode       : 'local',
            displayField    : 'name',
            valueField      : 'value',
            store           : new Ext.data.Store({
                fields  : ['name', 'value'],
                data    : [
                    { name : cfg.completeViewText,  value : 'complete' },
                    { name : cfg.dateRangeText,     value : 'date' },
                    { name : cfg.currentViewText,   value : 'current' }
                ]
            }),
            listeners      : {
                change  : me.onRangeChange,
                scope   : me
            }
        });

        // col/row resizer
        me.resizePicker     = new Sch.widget.ResizePicker({
            dialogConfig    : cfg,
            margin          : '10 20'
        });

        me.resizerHolder    = new Ext.form.FieldContainer({
            fieldLabel          : cfg.scrollerDisabled ? cfg.adjustCols : cfg.adjustColsAndRows,
            labelAlign          : 'top',
            hidden              : true,
            labelSeparator      : '',
            beforeLabelTextTpl  : beforeLabelTextTpl,
            afterLabelTextTpl   : afterLabelTextTpl,
            layout              : 'vbox',
            defaults            : {
                flex        : 1,
                allowBlank  : false
            },
            items               : [me.resizePicker]
        });

        // from date
        me.dateFromField = new Ext.form.field.Date({
            fieldLabel  : cfg.dateRangeFromText,
            baseBodyCls : 'sch-exportdialogform-date',
            name        : 'dateFrom',
            format      : cfg.dateRangeFormat || Ext.Date.defaultFormat,
            allowBlank  : false,
            maxValue    : cfg.endDate,
            minValue    : cfg.startDate,
            value       : cfg.startDate
        });

        // till date
        me.dateToField = new Ext.form.field.Date({
            fieldLabel  : cfg.dateRangeToText,
            name        : 'dateTo',
            format      : cfg.dateRangeFormat || Ext.Date.defaultFormat,
            baseBodyCls : 'sch-exportdialogform-date',
            allowBlank  : false,
            maxValue    : cfg.endDate,
            minValue    : cfg.startDate,
            value       : cfg.endDate
        });

        // date fields holder
        me.datesHolder  = new Ext.form.FieldContainer({
            fieldLabel          : cfg.specifyDateRange,
            labelAlign          : 'top',
            hidden              : true,
            labelSeparator      : '',
            beforeLabelTextTpl  : beforeLabelTextTpl,
            afterLabelTextTpl   : afterLabelTextTpl,
            layout              : 'vbox',
            defaults            : {
                flex        : 1,
                allowBlank  : false
            },
            items               : [me.dateFromField, me.dateToField]
        });

        if (cfg.showHeaderField) {
            me.showHeaderField  = new Ext.form.field.Checkbox({
                fieldLabel      : me.dialogConfig.showHeaderLabel,
                cls             : 'sch-export-dialog-header',
                name            : 'showHeader',
                checked         : !!cfg.exportConfig.showHeader,
                checkedValue    : true,
                uncheckedValue  : false
            });
        }

        if (cfg.showFooterField) {
            me.showFooterField  = new Ext.form.field.Checkbox({
                fieldLabel      : me.dialogConfig.showFooterLabel,
                cls             : 'sch-export-dialog-footer',
                name            : 'showFooter',
                checked         : !!cfg.exportConfig.showFooter,
                checkedValue    : true,
                uncheckedValue  : false
            });
        }

        me.exportersField = new Ext.form.field.ComboBox({
            value           : cfg.defaultExporter,
            triggerAction   : 'all',
            cls             : 'sch-export-dialog-exporter',
            forceSelection  : true,
            editable        : false,
            fieldLabel      : cfg.exportersFieldLabel,
            name            : 'exporterId',
            queryMode       : 'local',
            displayField    : 'name',
            valueField      : 'value',
            store           : me.buildExporterStore(cfg.exporters),
            listeners      : {
                change  : me.onExporterChange,
                scope   : me
            }
        });

        me.formatField = new Ext.form.field.ComboBox({
            value          : cfg.exportConfig.format,
            triggerAction  : 'all',
            forceSelection : true,
            editable       : false,
            fieldLabel     : cfg.formatFieldLabel,
            name           : 'format',
            queryMode      : 'local',
            store          : cfg.pageFormats || ["A5", "A4", "A3", "Letter", "Legal"]
        });

        var orientationLandscapeCls = cfg.exportConfig.orientation === "portrait" ? 'class="sch-none"' : '',
            orientationPortraitCls = cfg.exportConfig.orientation === "landscape" ? 'class="sch-none"' : '';

        me.orientationField = new Ext.form.field.ComboBox({
            value          : cfg.exportConfig.orientation,
            triggerAction  : 'all',
            componentCls   : 'sch-exportdialogform-orientation',
            forceSelection : true,
            editable       : false,
            fieldLabel     : me.dialogConfig.orientationFieldLabel,
            afterSubTpl    : new Ext.XTemplate('<span id="sch-exportdialog-imagePortrait" ' + orientationPortraitCls +
                '></span><span id="sch-exportdialog-imageLandscape" ' + orientationLandscapeCls + '></span>'),
            name           : 'orientation',
            displayField   : 'name',
            valueField     : 'value',
            queryMode      : 'local',
            store          : new Ext.data.Store({
                fields : ['name', 'value'],
                data   : [
                    { name : cfg.orientationPortraitText, value : 'portrait' },
                    { name : cfg.orientationLandscapeText, value : 'landscape' }
                ]
            }),
            listeners      : {
                change : function (field, newValue) {
                    switch (newValue) {
                        case 'landscape':
                            Ext.fly('sch-exportdialog-imagePortrait').toggleCls('sch-none');
                            Ext.fly('sch-exportdialog-imageLandscape').toggleCls('sch-none');
                            break;
                        case 'portrait':
                            Ext.fly('sch-exportdialog-imagePortrait').toggleCls('sch-none');
                            Ext.fly('sch-exportdialog-imageLandscape').toggleCls('sch-none');
                            break;
                    }
                }
            }
        });

        items.push(me.rangeField);
        items.push(me.resizerHolder);
        items.push(me.datesHolder);
        items.push(me.exportersField);
        items.push(me.formatField);
        items.push(me.orientationField);

        if (cfg.showHeaderField) {
            items.push(me.showHeaderField);
        }

        if (cfg.showFooterField) {
            items.push(me.showFooterField);
        }

        return items;
    },

    // Builds a store to be used for the `Export mode` combobox
    // @param {Object}
    // @return {Ext.data.Store}
    buildExporterStore : function (exporters) {

        var data    = [];

        for (var i = 0, l = exporters.length; i < l; i++) {
            var exporter    = exporters[i];

            data.push({
                name        : exporter.getName(),
                value       : exporter.getExporterId()
            });
        }

        return Ext.create('Ext.data.Store', {
            fields  : ['name' , 'value'],
            data    : data
        });
    },

    createProgressBar : function () {
        return this.progressBar = new Ext.ProgressBar({
            text    : this.config.progressBarText,
            animate : true,
            hidden  : true,
            margin  : '4px 0 10px 0'
        });
    },

    onRangeChange : function (field, newValue) {
        switch (newValue) {
            case 'complete':
                this.datesHolder.hide();
                this.resizerHolder.hide();
                break;
            case 'date':
                this.datesHolder.show();
                this.resizerHolder.hide();
                break;
            case 'current':
                this.datesHolder.hide();
                this.resizerHolder.show();
                this.resizePicker.expand(true);
                break;
        }
    },

    /**
     * @protected
     * This method is called after user selects an export mode in the corresponding field.
     * @param  {Ext.form.field.Field} field Reference to the form field
     * @param  {String} exporterId Selected exporter identifier
     */
    onExporterChange : function (field, exporterId) {

        switch (exporterId) {
            case  'singlepage':
                this.disableFields(true);
                break;
            default :
                this.disableFields(false);
        }

    },

    disableFields : function (value) {
        var me = this;

        if (me.showHeaderField) {
            me.showHeaderField.setDisabled(value);
        }

        me.formatField.setDisabled(value);
        me.orientationField.setDisabled(value);
    },


    showProgressBar : function () {
        if (this.progressBar) this.progressBar.show();
    },

    hideProgressBar : function () {
        if (this.progressBar) this.progressBar.hide();
    },

    updateProgressBar : function (value, text) {

        if (this.progressBar) {

            this.progressBar.updateProgress(value);

            if (text) {
                this.progressBar.updateText(text);
            }

        }
    }
});

/**
 @class Sch.widget.ExportDialog
 @private
 @extends Ext.window.Window

 Widget for export options.

 */
Ext.define('Sch.widget.ExportDialog', {
    alternateClassName  : 'Sch.widget.PdfExportDialog',
    extend              : 'Ext.window.Window',
    requires            : ['Sch.widget.ExportDialogForm'],
    mixins              : ['Sch.mixin.Localizable'],
    alias               : "widget.exportdialog",

    //Panel settings. Overridable with {@link Sch.plugin.Export#cfg-exportDialogConfig}
    modal               : false,
    width               : 350,
    cls                 : 'sch-exportdialog',
    frame               : false,
    layout              : 'fit',
    draggable           : true,
    padding             : 0,
    myConfig            : null,

    //Private
    plugin              : null,

    /**
     * @cfg {Ext.Component} buttonsPanel Component with buttons controlling export.
     */
    buttonsPanel        : null,

    /**
     * @cfg {Object} buttonsPanelScope
     * The scope for the {@link #buttonsPanel}
     */
    buttonsPanelScope   : null,

    /**
     * @cfg {Ext.Component} progressBar Progress bar component.
     */
    progressBar         : null,

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

            - generalError                : 'An error occured, try again.',
            - title                       : 'Export Settings',
            - formatFieldLabel            : 'Paper format',
            - orientationFieldLabel       : 'Orientation',
            - rangeFieldLabel             : 'Export range',
            - showHeaderLabel             : 'Add page number',
            - showFooterLabel             : 'Add footer',
            - orientationPortraitText     : 'Portrait',
            - orientationLandscapeText    : 'Landscape',
            - completeViewText            : 'Complete schedule',
            - currentViewText             : 'Current view',
            - dateRangeText               : 'Date range',
            - dateRangeFromText           : 'Export from',
            - pickerText                  : 'Resize column/rows to desired value',
            - dateRangeToText             : 'Export to',
            - exportButtonText            : 'Export',
            - cancelButtonText            : 'Cancel',
            - progressBarText             : 'Exporting...',
            - exportToSingleLabel         : 'Export as single page'
     */

    /**
     * @cfg {String} dateRangeFormat Valid date format to be used by the date ranges fields.
     */
    dateRangeFormat : '',

    /**
     * @cfg {Boolean} showHeaderField Indicates if showHeaderField is visible in the exportdialog.
     */
    showHeaderField : true,

    /**
     * @cfg {Boolean} showFooterField Indicates if showFooterField is visible in the exportdialog.
     */
    showFooterField : false,

    constructor : function (config) {
        Ext.apply(this, config.exportDialogConfig);

        this.plugin = config.plugin;

        this.title = this.L('title');

        //store fields texts in the config object for further use by form
        this.myConfig = Ext.apply({
            progressBarText             : this.L('progressBarText'),
            dateRangeToText             : this.L('dateRangeToText'),
            pickerText                  : this.L('pickerText'),
            dateRangeFromText           : this.L('dateRangeFromText'),
            dateRangeText               : this.L('dateRangeText'),
            currentViewText             : this.L('currentViewText'),
            formatFieldLabel            : this.L('formatFieldLabel'),
            orientationFieldLabel       : this.L('orientationFieldLabel'),
            rangeFieldLabel             : this.L('rangeFieldLabel'),
            showHeaderLabel             : this.L('showHeaderLabel'),
            showFooterLabel             : this.L('showFooterLabel'),
            exportersFieldLabel         : this.L('exportersFieldLabel'),
            orientationPortraitText     : this.L('orientationPortraitText'),
            orientationLandscapeText    : this.L('orientationLandscapeText'),
            completeViewText            : this.L('completeViewText'),
            adjustCols                  : this.L('adjustCols'),
            adjustColsAndRows           : this.L('adjustColsAndRows'),
            specifyDateRange            : this.L('specifyDateRange'),
            dateRangeFormat             : this.dateRangeFormat,
            exportConfig                : this.exportConfig,
            showHeaderField             : this.showHeaderField,
            showFooterField             : this.showFooterField,
            pageFormats                 : this.getPageFormats()
        }, config.exportDialogConfig);

        this.callParent(arguments);
    },

    getPageFormats : function () {
        var pageSizes   = this.plugin.pageSizes,
            sizes       = [];

        Ext.Object.each(pageSizes, function (key, value) {
            sizes.push({
                width   : value.width,
                height  : value.height,
                name    : key
            });
        });

        // let's sort page sizes by width
        sizes.sort(function (a, b) { return a.width - b.width; });

        var result = [];

        for (var i = 0; i < sizes.length; i++) {
            result.push(sizes[i].name);
        }

        return result;
    },

    initComponent : function () {
        var me          = this,
            listeners   = {
                hidedialogwindow    : me.destroy,
                showdialogerror     : me.showError,
                updateprogressbar   : function (value, text) {

                    if (arguments.length == 2) {
                        me.fireEvent('updateprogressbar', value, undefined);
                    }
                    else {
                        me.fireEvent('updateprogressbar', value, text);
                    }

                },
                scope               : this
            };

        me.form         = me.buildForm(me.myConfig);

        Ext.apply(this, {
            items : me.form,
            fbar  : me.buildButtons(me.buttonsPanelScope || me)
        });

        me.callParent(arguments);

        me.plugin.on(listeners);
    },

    afterRender : function () {
        var me = this;

        me.relayEvents(me.form.resizePicker, ['change', 'changecomplete', 'select']);

        me.form.relayEvents(me, ['updateprogressbar', 'hideprogressbar', 'showprogressbar']);

        me.callParent(arguments);
    },

    /**
     * Create Dialog's buttons.
     *
     * @param {Object} buttonsScope Scope for the buttons.
     * @return {Object} buttons Object containing buttons for Exporting/Cancelling export.
     */
    buildButtons : function (buttonsScope) {
        return [
            {
                xtype   : 'button',
                scale   : 'medium',
                text    : this.L('exportButtonText'),
                handler : function () {
                    if (this.form.isValid()) {
                        this.fireEvent('showprogressbar');

                        var config          = this.form.getValues();
                        //exporter combo returns a exporterId
                        config.exporterId   = config.exporterId;

                        // convert strings to dates before passing date range to doExport method
                        var dateFormat      = this.dateRangeFormat || Ext.Date.defaultFormat;

                        if (config.dateFrom && !Ext.isDate(config.dateFrom)) {
                            config.dateFrom = Ext.Date.parse(config.dateFrom, dateFormat);
                        }

                        if (config.dateTo && !Ext.isDate(config.dateTo)) {
                            config.dateTo   = Ext.Date.parse(config.dateTo, dateFormat);
                        }

                        this.plugin.doExport(config);
                    }
                },
                scope   : buttonsScope
            },
            {
                xtype   : 'button',
                scale   : 'medium',
                text    : this.L('cancelButtonText'),
                handler : function () {
                    this.destroy();
                },
                scope   : buttonsScope
            }
        ];
    },

    /**
     * Build the {@link Sch.widget.ExportDialogForm} for the dialog window.
     *
     * @param {Object} config Config object for the form, containing field names and values.
     * @return {Sch.widget.ExportDialogForm} form
     */
    buildForm : function (config) {
        return new Sch.widget.ExportDialogForm({
            progressBar  : this.progressBar,
            dialogConfig : config
        });
    },

    /**
     * @private
     * Displays error message in the dialog. When it's called, both form and buttons are hidden.
     * @param {Sch.widget.ExportDialog} dialog Dialog window or null
     * @param {String} error (optional) Text of the message that will be displayed in the dialog. If not provided, {@link #generalError}
     * will be used.
     */
    showError : function (dialog, error) {
        var me = dialog,
            text = error || me.L('generalError');

        me.fireEvent('hideprogressbar');
        Ext.Msg.alert('', text);
    }
});

/**
@class Sch.feature.ColumnLines
@extends Sch.plugin.Lines

A simple feature adding column lines (to be used when using the SingleTimeAxis column).

*/
Ext.define("Sch.feature.ColumnLines", {
    extend : 'Sch.plugin.Lines',

    requires : [
        'Ext.data.JsonStore'
    ],
    
    
    cls                     : 'sch-column-line',
    
    showTip                 : false,
    
    timeAxisViewModel       : null,
    
    renderingDoneEvent      : 'columnlinessynced',

    
    init : function (panel) {
        this.timeAxis           = panel.getTimeAxis();
        this.timeAxisViewModel  = panel.timeAxisViewModel;
        this.panel              = panel;

        this.store = new Ext.data.JsonStore({
            fields   : [ 'Date' ]
        });

        this.callParent(arguments);

        panel.on({
            modechange          : this.populate,
            destroy             : this.onHostDestroy,
            scope               : this
        });

        this.timeAxisViewModel.on('update', this.populate, this);
        
        this.populate();
    },

    onHostDestroy : function() {
        this.timeAxisViewModel.un('update', this.populate, this);
    },

    populate: function() {
        this.store.setData(this.getData());
    },
    
    getElementData : function() {
        var sv = this.schedulerView;

        if (sv.isHorizontal() && sv.store.getCount() > 0) {
            return this.callParent(arguments);
        }

        return [];
    },

    getData : function() {
        var panel = this.panel,
            ticks = [];

        if (panel.isHorizontal()) {
            var timeAxisViewModel   = this.timeAxisViewModel;
            var linesForLevel       = timeAxisViewModel.columnLinesFor;
            var hasGenerator        = !!(timeAxisViewModel.headerConfig && timeAxisViewModel.headerConfig[linesForLevel].cellGenerator);

            if (hasGenerator) {
                var cells = timeAxisViewModel.getColumnConfig()[linesForLevel];

                for (var i = 1, l = cells.length; i < l; i++) {
                    ticks.push({ Date : cells[i].start });
                }
            } else {
                // Highlight column lines that match the next higher header row
                var nextLevelUp,
                    nextHigherLevelTicks,
                    colConfig = timeAxisViewModel.getColumnConfig(),
                    nextLevelCachedDates;

                if (linesForLevel === 'bottom')      nextLevelUp = "middle";
                else if (linesForLevel === 'middle') nextLevelUp = "top";

                nextHigherLevelTicks = colConfig[nextLevelUp];

                if (nextHigherLevelTicks) {
                    var headerConfig = timeAxisViewModel.headerConfig;

                    if (headerConfig[nextLevelUp].increment !== headerConfig[linesForLevel].increment ||
                        headerConfig[nextLevelUp].unit !== headerConfig[linesForLevel].unit) {
                        nextLevelCachedDates = {};

                        Ext.Array.forEach(nextHigherLevelTicks, function(tick) {
                            nextLevelCachedDates[tick.start.getTime()] = 1;
                        });
                    }
                }

                timeAxisViewModel.forEachInterval(linesForLevel, function(start, end, i) {

                    if (i > 0) {
                        ticks.push({
                            Date : start,
                            Cls  : nextLevelCachedDates && nextLevelCachedDates[start.getTime()] ? 'sch-column-line-solid' : ''
                        });
                    }

                });
            }
        }

        return ticks;
    }
});
/**
 @class Sch.template.Event

 */
Ext.define("Sch.template.Event", {
    extend : 'Ext.XTemplate',

    eventPrefix   : null,

    // 'none', 'start', 'end' or 'both'
    resizeHandles : null,
    resizeTpl     : '<div class="sch-resizable-handle sch-resizable-handle-{0}"></div>',

    constructor   : function (config) {

        Ext.apply(this, config);

        var startResizeHandles = (this.resizeHandles === 'start' || this.resizeHandles === 'both' ? '<div class="sch-resizable-handle sch-resizable-handle-start"></div>' : '');
        var endResizeHandles = (this.resizeHandles === 'end' || this.resizeHandles === 'both' ? '<div class="sch-resizable-handle sch-resizable-handle-end"></div>' : '');

        this.callParent([
            '<tpl for=".">' +
                '<div unselectable="on" tabindex="-1" id="' + this.eventPrefix + '{id}" style="right:{right}px;left:{left}px;top:{top}px;height:{height}px;width:{width}px;{style}" class="sch-event ' + Ext.baseCSSPrefix + 'unselectable {internalCls} {cls}">' +
                    startResizeHandles +
                    '<div unselectable="on" class="sch-event-inner {iconCls}">' +
                        '{body}' +
                    '</div>' +
                    endResizeHandles +
                '</div>' +
            '</tpl>'
        ]);
    }

});

/**
@class Sch.mixin.AbstractTimelineView
@private

A base mixin for giving to the consuming view "time line" functionality.
This means that the view will be capable to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/
Ext.define("Sch.mixin.AbstractTimelineView", {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.view.Horizontal'
    ],

    /**
    * @cfg {String} selectedEventCls
    * A CSS class to apply to an event in the view on mouseover (defaults to 'sch-event-selected').
    */
    selectedEventCls : 'sch-event-selected',

    // private
    readOnly            : false,
    horizontalViewClass : 'Sch.view.Horizontal',

    //    can not "declare" it here, because will conflict with the default value from  SchedulerView
    //    verticalViewClass   : null,

    timeCellCls         : 'sch-timetd',
    timeCellSelector    : '.sch-timetd',

    eventBorderWidth        : 1,

    timeAxis            : null,
    timeAxisViewModel   : null,

    eventPrefix         : null,

    rowHeight           : null,
//    can not "declare" it here, because will conflict with the default value from  SchedulerView
//    barMargin           : null,

    // deprecated
    orientation         : 'horizontal',
    mode                : 'horizontal',

    horizontal          : null,
    vertical            : null,

    secondaryCanvasEl   : null,

    panel               : null,

    displayDateFormat   : null,

    // Accessor to the Ext.Element for this view
    el                  : null,

    constructor : function (config) {
        if (config && config.orientation) {
            config.mode = this.mode = config.orientation;
        }
        this.callParent([config]);
    },

    _initializeTimelineView         : function() {
        if (this.horizontalViewClass) {
            this.horizontal = Ext.create(this.horizontalViewClass, { view : this });
        }

        if (this.verticalViewClass) {
            this.vertical = Ext.create(this.verticalViewClass, { view : this });
        }

        if (this.calendarViewClass) {
            this.calendar = Ext.create(this.calendarViewClass, { view : this });
        }

        this.eventPrefix = (this.eventPrefix || this.getId()) + '-';
    },

    getTimeAxisViewModel : function () {
        return this.timeAxisViewModel;
    },

    /**
    * Method to get a formatted display date
    * @private
    * @param {Date} date The date
    * @return {String} The formatted date
    */
    getFormattedDate: function (date) {
        return Ext.Date.format(date, this.getDisplayDateFormat());
    },

    /**
    * Method to get a formatted end date for a scheduled event, the grid uses the "displayDateFormat" property defined in the current view preset.
    * @private
    * @param {Date} endDate The date to format
    * @param {Date} startDate The start date
    * @return {String} The formatted date
    */
    getFormattedEndDate: function (endDate, startDate) {
        var format = this.getDisplayDateFormat();

        if (
            // If time is midnight,
            endDate.getHours() === 0 && endDate.getMinutes() === 0 &&

            // and end date is greater then start date
            !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate()) &&

            // and UI display format doesn't contain hour info (in this case we'll just display the exact date)
            !Sch.util.Date.hourInfoRe.test(format.replace(Sch.util.Date.stripEscapeRe, ''))
        ) {
            // format the date inclusively as 'the whole previous day'.
            endDate = Sch.util.Date.add(endDate, Sch.util.Date.DAY, -1);
        }

        return Ext.Date.format(endDate, format);
    },

    // private
    getDisplayDateFormat: function () {
        return this.displayDateFormat;
    },

    // private
    setDisplayDateFormat: function (format) {
        this.displayDateFormat = format;
    },


    /**
    * This function fits the schedule area columns into the available space in the grid.
    * @param {Boolean} preventRefresh `true` to prevent a refresh of view
    */
    fitColumns: function (preventRefresh) { // TODO test
        if (this.mode === 'horizontal') {
            this.getTimeAxisViewModel().fitToAvailableWidth(preventRefresh);
        } else {
            var w = Math.floor((this.panel.getWidth() - Ext.getScrollbarSize().width - 1) / this.headerCt.getColumnCount());
            this.setColumnWidth(w, preventRefresh);
        }
    },

    /**
     * Returns the Ext.Element representing an event record.
     *
     * @param {Sch.model.Event} eventRecord An event record
     * @param {Sch.model.Resource} [resourceRecord] A resource record
     *
     * @return {Ext.Element|null} The Ext.Element representing the event record
     * @deprecated Please use {@link #getElementsFromEventRecord}.
     */
    getElementFromEventRecord: function(eventRecord, resourceRecord) {
        var me = this,
            result;

        result = me.getElementsFromEventRecord(eventRecord, resourceRecord);

        if (result.length === 0) {
            result = null;
        }
        else if (result.length == 1) {
            result = result[0]; // We return Ext.Element as given in the method documentation
        }
        // TODO: Get rid of this else if branch, backward compatible behaviour
        else if (me.mode == 'calendar') {
            result = result[0];
        }
        else {
            Ext.Error.raise("The method getElementFromEventRecord() is deprecated, it can't handle the situation when several DOM elements correspond to a single event record, please use getElementsFromEventRecord() method instead!");
        }

        return result;
    },

    /**
     * Returns all the Ext.Element(s) representing an event record.
     *
     * @param {Sch.model.Event} eventRecord An event record
     * @param {Sch.model.Resource} [resourceRecord] A resource record
     *
     * @privateparam {Number} [index] Index used to distinguish DOM nodes corresponding to same event/resource but rendered on different columns inside calendar view.
     * @privateparam {Boolean [raw=false] Whether to return HTMLElements instead of Ext.Element
     *
     * @return {[Ext.Element|HTMLElement]} The Ext.Element(s) representing the event record
     */
    getElementsFromEventRecord: function(eventRecord, resourceRecord, index, raw) {
        var me = this,
            query;

        raw = raw || false;

        if (resourceRecord && (index !== null && index !== undefined)) {
            query = '[id^=' + me.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-' + index +']';
        }
        else if (resourceRecord) {
            query = '[id^=' + me.eventPrefix + eventRecord.internalId + '-' + resourceRecord.internalId + '-]';
        }
        else {
            query = '[id^=' + me.eventPrefix + eventRecord.internalId + '-]';
        }

        return me.getEl().query(query, raw);
    },

    /**
    * Gets the start and end dates for an element Region
    * @param {Ext.util.Region} region The region to map to start and end dates
    * @param {String} roundingMethod The rounding method to use
    * @returns {Object} an object containing start/end properties
    */
    getStartEndDatesFromRegion: function (region, roundingMethod, allowPartial) {
        return this[this.mode].getStartEndDatesFromRegion(region, roundingMethod, allowPartial);
    },


    /**
    * Returns the current time resolution object, which contains a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    getTimeResolution: function () {
        return this.timeAxis.getResolution();
    },

    /**
    * Sets the current time resolution, composed by a unit identifier and an increment count.
    * @return {Object} The time resolution object
    */
    setTimeResolution: function (unit, increment) {
        this.timeAxis.setResolution(unit, increment);

        // View will have to be updated to support snap to increment
        if (this.getTimeAxisViewModel().snapToIncrement) {
            this.refreshKeepingScroll();
        }
    },

    /**
    * <p>Returns the event id for a DOM id </p>
    * @private
    * @param {String} id The id of the DOM node
    * @return {String} An event record (internal) id
    */
    getEventIdFromDomNodeId: function (id) {
        // id format is "PREFIX"-eventid-resourceid[-part]
        return id.substring(this.eventPrefix.length).split('-')[0];
    },

    /**
     * Returns a resource id for a DOM id
     * @private
     * @param {String} id An id of an event DOM node
     * @return {String} A resource record (internal) id
     */
    getResourceIdFromDomNodeId : function(id) {
        // id format is "PREFIX"-eventid-resourceid[-part]
        return id.substring(this.eventPrefix.length).split('-')[1];
    },

    /**
    *  Gets the time for a DOM event such as 'mousemove' or 'click'
    *  @param {Ext.EventObject} e, the EventObject instance
    *  @param {String} roundingMethod (optional), 'floor' to floor the value or 'round' to round the value to nearest increment
    *  @returns {Date} The date corresponding to the EventObject x coordinate
    */
    getDateFromDomEvent : function(e, roundingMethod) {
        return this.getDateFromXY(e.getXY(), roundingMethod);
    },

    /**
    * [Experimental] Returns the pixel increment for the current view resolution.
    * @return {Number} The width increment
    */
    getSnapPixelAmount: function () {
        return this.getTimeAxisViewModel().getSnapPixelAmount();
    },

    /**
    * Controls whether the scheduler should snap to the resolution when interacting with it.
    * @param {Boolean} enabled true to enable snapping when interacting with events.
    */
    setSnapEnabled: function (enabled) {
        this.getTimeAxisViewModel().setSnapToIncrement(enabled);
    },

    /**
    * Sets the readonly state which limits the interactivity (resizing, drag and drop etc).
    * @param {Boolean} readOnly The new readOnly state
    */
    setReadOnly: function (readOnly) {
        this.readOnly = readOnly;
        this[readOnly ? 'addCls' : 'removeCls'](this._cmpCls + '-readonly');
    },

    /**
    * Returns true if the view is currently readOnly.
    * @return {Boolean} readOnly
    */
    isReadOnly: function () {
        return this.readOnly;
    },


    /**
    * Sets the current orientation.
    * @param {String} orientation Either 'horizontal' or 'vertical'
    * @deprecated
    */
    setOrientation  : function () {
        this.setMode.apply(this, arguments);
    },

    /**
    * Sets the current mode.
    * @param {String} mode Either 'horizontal', 'vertical' or 'calendar'
    */
    setMode : function (mode) {
        this.mode                   = mode;
        this.timeAxisViewModel.mode = mode;
    },

    /**
    * Returns the current view orientation
    * @return {String} The view orientation ('horizontal' or 'vertical')
    * @deprecated
    */
    getOrientation  : function () {
        return this.getMode.apply(this, arguments);
    },

    /**
    * Returns the current view mode
    * @return {String} The view mode ('horizontal', 'vertical' or 'calendar')
    */
    getMode: function () {
        return this.mode;
    },

    isHorizontal : function() {
        return this.getMode() === 'horizontal';
    },


    isVertical : function() {
        return !this.isHorizontal();
    },

    /**
    * Gets the date for an XY coordinate
    * @param {Array} xy The page X and Y coordinates
    * @param {String} roundingMethod The rounding method to use
    * @param {Boolean} local, true if the coordinate is local to the scheduler view element
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromXY: function (xy, roundingMethod, local) {
        return this[this.mode].getDateFromXY(xy, roundingMethod, local);
    },

    /**
    * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.
    * @param {Number} coordinate The X or Y coordinate
    * @param {String} roundingMethod The rounding method to use
    * @param {Boolean} local, true if the coordinate is local to the scheduler view element
    * @returns {Date} the Date corresponding to the xy coordinate
    */
    getDateFromCoordinate: function (coord, roundingMethod, local) {
        if (!local) {
            coord = this[this.mode].translateToScheduleCoordinate(coord);
        }
        return this.timeAxisViewModel.getDateFromPosition(coord, roundingMethod);
    },

    /**
    * Gets the date for the passed X coordinate.
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Number} x The X coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the x coordinate
    * @abstract
    */
    getDateFromX: function (x, roundingMethod) {
        return this.getDateFromCoordinate(x, roundingMethod);
    },

    /**
    * Gets the date for the passed Y coordinate
    * If the coordinate is not in the currently rendered view, -1 will be returned.
    * @param {Number} y The Y coordinate
    * @param {String} roundingMethod The rounding method to use
    * @returns {Date} the Date corresponding to the y coordinate
    * @abstract
    */
    getDateFromY: function (y, roundingMethod) {
        return this.getDateFromCoordinate(y, roundingMethod);
    },

    /**
    *  Gets the x or y coordinate relative to the scheduling view element, or page coordinate (based on the 'local' flag)
    *  If the coordinate is not in the currently rendered view, -1 will be returned.
    *  @param {Date} date the date to query for
    *  @param {Boolean} local true to return a coordinate local to the scheduler view element (defaults to true)
    *  @returns {Number} the x or y position representing the date on the time axis
    */
    getCoordinateFromDate: function (date, local) {
        var pos = this.timeAxisViewModel.getPositionFromDate(date);

        if (local === false) {
            pos = this[this.mode].translateToPageCoordinate(pos);
        }

        return Math.round(pos);
    },

    /**
    *  Gets the x coordinate relative to the scheduling view element, or page coordinate (based on the 'local' flag)
    *  @param {Date} date the date to query for
    *  @param {Boolean} local true to return a coordinate local to the scheduler view element (defaults to false)
    *  @returns {Array} the XY coordinates representing the date
    */
    getXFromDate: function (date, local) {
        return this.getCoordinateFromDate(date, local);
    },

    /**
    *  Gets xy coordinates relative to the scheduling view element, or page coordinates (based on the 'local' flag)
    *  @param {Date} xy the page X and Y coordinates
    *  @param {Boolean} local true to return a coordinate local to the scheduler view element
    *  @returns {Array} the XY coordinates representing the date
    */
    getYFromDate: function (date, local) {
        return this.getCoordinateFromDate(date, local);
    },

    /**
    *  Returns the distance in pixels the for time span in the view.
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Number} The distance in pixels
    */
    getTimeSpanDistance: function (startDate, endDate) {
        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);
    },

    /**
    *  Returns the region for a "global" time span in the view. Coordinates are relative to element containing the time columns
    *  @param {Date} startDate The start date of the span
    *  @param {Date} endDate The end date of the span
    *  @return {Ext.util.Region} The region for the time span
    */
    getTimeSpanRegion: function (startDate, endDate) {
        return this[this.mode].getTimeSpanRegion(startDate, endDate);
    },

    /**
    * Gets the Ext.util.Region represented by the schedule and optionally only for a single resource. The view will ask the scheduler for
    * the resource availability by calling getResourceAvailability. By overriding that method you can constrain events differently for
    * different resources.
    * @param {Sch.model.Resource} resourceRecord (optional) The resource record
    * @param {Sch.model.Event} eventRecord (optional) The event record
    * @return {Ext.util.Region} The region of the schedule
    */
    getScheduleRegion: function (resourceRecord, eventRecord) {
        return this[this.mode].getScheduleRegion(resourceRecord, eventRecord);
    },

    // Returns the region of the table element containing the rows of the schedule
    getTableRegion : function () {
        throw 'Abstract method call';
    },

    // Returns the table element containing the rows of the schedule
    getRowNode: function (resourceRecord) {
        throw 'Abstract method call';
    },

    getRecordForRowNode : function(node) {
        throw 'Abstract method call';
    },

    /**
    * Method to get the currently visible date range in a scheduling view. Please note that it only works when the schedule is rendered.
    * @return {Object} object with `startDate` and `endDate` properties.
    */
    getVisibleDateRange: function () {
        return this[this.mode].getVisibleDateRange();
    },

    /**
     * Method to set the new columnWidth. The new width is passed in the case of a horizontal mode as tickWidth, resourceColumnWidth in the case of a vertical mode
     * and as calendarColumnWidth in the case of a calendar mode.
     * @param {Number} width The new width value
     * @param {Boolean} preventRefresh true to skip refreshing the view
     */
    setColumnWidth: function (width, preventRefresh) {
        this[this.mode].setColumnWidth(width, preventRefresh);
    },

    findRowByChild : function(t) {
        throw 'Abstract method call';
    },

    /**
    * Sets the amount of margin to keep between bars and rows.
    * @param {Number} margin The new margin value
    * @param {Boolean} preventRefresh true to skip refreshing the view
    */
    setBarMargin: function (margin, preventRefresh) {
        this.barMargin = margin;

        if (!preventRefresh) {
            this.refreshKeepingScroll();
        }
    },

    /**
     * Returns the current row height used by the view (only applicable in a horizontal view)
     * @return {Number} The row height
     */
    getRowHeight: function () {
        return this.timeAxisViewModel.getViewRowHeight();
    },

    /**
    * Sets the row height of the timeline
    * @param {Number} height The height to set
    * @param {Boolean} preventRefresh `true` to prevent view refresh
    */
    setRowHeight: function (height, preventRefresh) {
        this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
    },

    /**
    * Refreshes the view and maintains the scroll position.
    */
    refreshKeepingScroll : function() {
        throw 'Abstract method call';
    },

    /**
     * Scrolls the view vertically
     * @param {Number} y The y-value to scroll to
     * @param {Boolean/Object} animate An animation config, or true/false
     */
    scrollVerticallyTo : function(y, animate) {
        throw 'Abstract method call';
    },

    /**
     * Scrolls the view horizontally
     * @param {Number} x The x-value to scroll to
     * @param {Boolean/Object} animate An animation config, or true/false
     */
    scrollHorizontallyTo : function(x, animate) {
        throw 'Abstract method call';
    },

    /**
     * Returns the current vertical scroll value
     */
    getVerticalScroll : function() {
        throw 'Abstract method call';
    },

    /**
     * Returns the current horizontal scroll value
     */
    getHorizontalScroll : function() {
        throw 'Abstract method call';
    },

    // This method should be implemented by the consuming class
    getEl : Ext.emptyFn,


    // returns a secondary canvas el - the el to be used for drawing column lines, zones etc
    getSecondaryCanvasEl : function () {
        if (!this.rendered) throw 'Calling this method too early';

        if (!this.secondaryCanvasEl) {
            this.secondaryCanvasEl = (this.scrollerEl || this.getEl()).createChild({ cls : 'sch-secondary-canvas' });
        }
        return this.secondaryCanvasEl;
    },

    /**
     * Returns the current viewport scroll position as an object with left/top properties.
     */
    getScroll : function() {
        throw 'Abstract method call';
    },

    getOuterEl : function() {
        return this.getEl();
    },

    getRowContainerEl : function() {
        return this.getEl();
    },

    getScheduleCell : function(row, col) {
        return this.getCellByPosition({ row : row, column : col});
    },


    getScrollEventSource : function () {
        return this.getEl();
    },

    getViewportHeight : function () {
        return this.getEl().getHeight();
    },

    getViewportWidth : function () {
        return this.getEl().getWidth();
    },

    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     */
    getViewportCenterDate: function(){
        var scroll     = this.getScroll(),
            xy;

        if (this.getMode() === 'vertical') {
            xy                 = [ 0, scroll.top + this.getViewportHeight() / 2 ];
        } else {
            xy                 = [ scroll.left + this.getViewportWidth() / 2, 0 ];
        }

        return this.getDateFromXY(xy, null, true);
    },

    getDateConstraints : Ext.emptyFn
});


Ext.apply(Sch, {
    /*PKGVERSION*/VERSION : '3.0.6'
});

/**
@class Sch.mixin.TimelineView

A base mixin for {@link Ext.view.View} classes, giving to the consuming view the "time line" functionality.
This means that the view will be capable to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

By itself this mixin is not enough for correct rendering. The class, consuming this mixin, should also consume one of the
{@link Sch.view.Horizontal}, {@link Sch.view.Vertical} or {@link Sch.view.Calendar} mixins, which provides the implementation of some mode-specfic methods.

Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

*/
Ext.define("Sch.mixin.TimelineView", {
    extend : 'Sch.mixin.AbstractTimelineView',

    requires : [
        'Ext.tip.ToolTip',
        'Sch.patches.TouchScroll',
        'Sch.patches.PartnerScroll',
        'Sch.patches.View',
        'Sch.patches.TableView',
        'Sch.patches.Collection',
        'Sch.patches.ToolTip'
    ],

    tip : null,

    /**
    * @cfg {String} overScheduledEventClass
    * A CSS class to apply to each event in the view on mouseover (defaults to 'sch-event-hover').
    */
    overScheduledEventClass: 'sch-event-hover',

    ScheduleBarEvents    : [
        "mousedown",
        "mouseup",
        "click",
        "dblclick",
        "contextmenu"
    ],

    ResourceRowEvents      : [
        "keydown",
        "keyup"
    ],

    // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations
    preventOverCls      : false,

    /**
     * @event beforetooltipshow
     * Fires before the event tooltip is shown, return false to suppress it.
     * @param {Sch.mixin.SchedulerPanel} scheduler The scheduler object
     * @param {Sch.model.Event} eventRecord The event record corresponding to the rendered event
     */

    /**
     * @event columnwidthchange
     * @private
     * Fires after the column width has changed
     */

    _initializeTimelineView : function() {
        this.callParent(arguments);

        this.on('destroy', this._onDestroy, this);
        this.on('afterrender', this._onAfterRender, this);
        this.panel.on('viewready', this._onViewReady, this);

        this.setMode(this.mode);

        this.enableBubble('columnwidthchange');

        this.addCls("sch-timelineview");

        if (this.readOnly) {
            this.addCls(this._cmpCls + '-readonly');
        }

        this.addCls(this._cmpCls);

        if (this.eventAnimations) {
            this.addCls('sch-animations-enabled');
        }

    },

    handleScheduleBarEvent: function(e, eventBarNode){
        this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecord(eventBarNode), e);
    },

    handleResourceRowEvent: function (e, resourceRowNode) {
        this.fireEvent(this.scheduledEventName + e.type, this, this.resolveEventRecordFromResourceRow(resourceRowNode), e);
    },

    // private, clean up
    _onDestroy: function () {
        if (this.tip) {
            this.tip.destroy();
        }
    },

    _onViewReady : function () {
        // If device support touch events ext is going to wrap node container in a special scroller element.
        // That will place secondary canvas element on a second position in view.
        if (this.touchScroll) {
            this.getSecondaryCanvasEl().insertBefore(this.getNodeContainer());
        }
    },


    _onAfterRender : function () {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }

        if (this.tooltipTpl) {
            if (typeof this.tooltipTpl === 'string') {
                this.tooltipTpl = new Ext.XTemplate(this.tooltipTpl);
            }
            this.el.on('mousemove', this.setupTooltip, this, { single : true });
        }

        var bufferedRenderer    = this.bufferedRenderer;

        if (bufferedRenderer) {
            this.patchBufferedRenderingPlugin(bufferedRenderer);
            this.patchBufferedRenderingPlugin(this.lockingPartner.bufferedRenderer);
        }

        this.on('bufferedrefresh', this.onBufferedRefresh, this, { buffer : 10 });

        this.setupTimeCellEvents();

        // The `secondaryCanvasEl` needs to be setup early, for the underlying gridview to know about it
        // and not remove it on later 'refresh' calls.
        var el = this.getSecondaryCanvasEl();

        // Simple smoke check to make sure CSS has been included correctly on the page
        if (el.getStyle('position').toLowerCase() !== 'absolute') {
            var context = Ext.Msg || window;

            context.alert('ERROR: The CSS file for the Bryntum component has not been loaded.');
        }

        var eventBarListeners = {
            delegate    : this.eventSelector,
            scope       : this
        };

        var resourceRowListeners = {
            delegate    : this.rowSelector,
            scope       : this
        };

        Ext.Array.forEach(this.ScheduleBarEvents, function(name) { eventBarListeners[name] = this.handleScheduleBarEvent; }, this);
        Ext.Array.forEach(this.ResourceRowEvents, function(name) { resourceRowListeners[name] = this.handleResourceRowEvent; }, this);

        this.el.on(eventBarListeners);
        this.el.on(resourceRowListeners);
    },


    patchBufferedRenderingPlugin : function (plugin) {
        var me                      = this;
        var oldSetBodyTop           = plugin.setBodyTop;

        // @OVERRIDE Overriding buffered renderer plugin
        plugin.setBodyTop           = function (bodyTop, calculatedTop) {
            var val                 = oldSetBodyTop.apply(this, arguments);

            me.fireEvent('bufferedrefresh', this);

            return val;
        };
    },


    onBufferedRefresh : function() {
        var el              = this.body.dom;
        if (!el) return;

        var style           = el.style;

        if (Ext.isIE9m) {
            this.getSecondaryCanvasEl().dom.style.top = this.body.dom.style.top;
        } else {
            var transform       = style.transform || style.msTransform || style.webkitTransform;

            var match;

            if (transform) {
                match           = /\(-?\d+px,\s*(-?\d+px),\s*(-?\d+)px\)/.exec(transform);
            }

            if (match) {
                this.getSecondaryCanvasEl().dom.style.top = transform ? match[ 1 ] : el.style.top;
            }
        }
    },

    setMouseOverEnabled : function(enabled) {
        this[enabled ? "mon" : "mun"](this.el, {
            mouseover : this.onEventMouseOver,
            mouseout  : this.onEventMouseOut,
            delegate  : this.eventSelector,
            scope     : this
        });
    },

    // private
    onEventMouseOver: function (e, t) {
        if (t !== this.lastItem && !this.preventOverCls) {
            this.lastItem = t;

            Ext.fly(t).addCls(this.overScheduledEventClass);

            var eventModel      = this.resolveEventRecord(t);

            // do not fire this event if model cannot be found
            // this can be the case for "sch-dragcreator-proxy" elements for example
            if (eventModel) this.fireEvent('eventmouseenter', this, eventModel, e);
        }
    },

    // private
    onEventMouseOut: function (e, t) {
        if (this.lastItem) {
            if (!e.within(this.lastItem, true, true)) {
                Ext.fly(this.lastItem).removeCls(this.overScheduledEventClass);

                this.fireEvent('eventmouseleave', this, this.resolveEventRecord(this.lastItem), e);
                delete this.lastItem;
            }
        }
    },

    // Overridden since locked grid can try to highlight items in the unlocked grid while it's loading/empty
    highlightItem: function(item) {
        if (item) {
            var me = this;
            me.clearHighlight();
            me.highlightedItem = item;
            Ext.fly(item).addCls(me.overItemCls);
        }
    },

    // private
    setupTooltip: function () {
        var me = this,
            tipCfg = Ext.apply({
                delegate    : me.eventSelector,
                target      : me.el,
                anchor      : 'b',
                rtl         : me.rtl,

                show : function() {
                    Ext.ToolTip.prototype.show.apply(this, arguments);

                    // Some extra help required to correct alignment (in cases where event is in part outside the scrollable area
                    // https://www.assembla.com/spaces/bryntum/tickets/626#/activity/ticket:
                    if (this.triggerElement && me.getMode() === 'horizontal') {
                        this.setX(this.targetXY[0] - 10);

                        var box = Ext.fly(this.triggerElement).getBox();
                        var newY = box.top - this.getHeight() - 10;

                        // if tip won't be fully visible, move it to bottom edge
                        this.setY(newY < 0 ? box.bottom + 10 : newY);
                    }
                }
            }, me.tipCfg);

        me.tip = new Ext.ToolTip(tipCfg);

        me.tip.on({
            beforeshow: function (tip) {
                if (!tip.triggerElement || !tip.triggerElement.id) {
                    return false;
                }

                var record = this.resolveEventRecord(tip.triggerElement);

                if (!record || this.fireEvent('beforetooltipshow', this, record) === false) {
                    return false;
                }

                var dataForTip = this.getDataForTooltipTpl(record, tip.triggerElement),
                    tooltipString;

                if (!dataForTip) return false;

                tooltipString = this.tooltipTpl.apply(dataForTip);

                if (!tooltipString) return false;

                tip.update(tooltipString);
            },

            scope: this
        });
        
        if (Ext.supports.Touch) {
            // https://www.sencha.com/forum/showthread.php?301307-single-event-listener-isn-t-unbound
            me.el.un({
                touchmove   : me.setupTooltip,
                mousemove   : me.setupTooltip,
                scope       : me
            });
        }
    },

    getHorizontalTimeAxisColumn : function () {
        if (!this.timeAxisColumn) {
            this.timeAxisColumn = this.headerCt.down('timeaxiscolumn');

            if (this.timeAxisColumn) {
                this.timeAxisColumn.on('destroy', function() {
                    this.timeAxisColumn = null;
                }, this);
            }
        }

        return this.timeAxisColumn;
    },

    /**
    * Template method to allow you to easily provide data for your {@link Sch.mixin.TimelinePanel#tooltipTpl} template.
     * @param {Sch.model.Range} event The event record corresponding to the HTML element that triggered the tooltip to show.
     * @param {HTMLElement} triggerElement The HTML element that triggered the tooltip.
     * @return {Object} The data to be applied to your template, typically any object or array.
    */
    getDataForTooltipTpl : function(record, triggerElement) {
        return Ext.apply({
            _record : record
        }, record.data);
    },

    /**
     * Refreshes the view and maintains the scroll position.
     */
    refreshKeepingScroll : function() {

        Ext.suspendLayouts();

        this.saveScrollState();

        this.refresh();

        // we have to resume layouts before scroll in order to let element receive its new width after refresh
        Ext.resumeLayouts(true);

        // If el is not scrolled, skip setting scroll state (can be a costly DOM operation)
        // This speeds up initial rendering
        // HACK: reading private scrollState property in Ext JS superclass
        // infinite scroll requires the restore scroll state always
        if (this.scrollState.left !== 0 || this.scrollState.top !== 0 || this.infiniteScroll) {
            this.restoreScrollState();
        }
    },

    setupTimeCellEvents: function () {
        this.mon(this.el, {
            // `handleScheduleEvent` is an abstract method, defined in "SchedulerView" and "GanttView"
            click       : this.handleScheduleEvent,
            dblclick    : this.handleScheduleEvent,
            contextmenu : this.handleScheduleEvent,

            pinch       : this.handleScheduleEvent,
            pinchstart  : this.handleScheduleEvent,
            pinchend    : this.handleScheduleEvent,
            scope       : this
        });
    },

    getTableRegion: function () {
        var tableEl = this.el.down('.' + Ext.baseCSSPrefix + 'grid-item-container');

        // Also handle odd timing cases where the table hasn't yet been inserted into the dom
        return (tableEl || this.el).getRegion();
    },

    // Returns the row element for a given row record
    getRowNode: function (resourceRecord) {
        return this.getNodeByRecord(resourceRecord);
    },

    findRowByChild : function(t) {
        return this.findItemByChild(t);
    },

    getRecordForRowNode : function(node) {
        return this.getRecord(node);
    },

    /**
    * Refreshes the view and maintains the resource axis scroll position.
    */
    refreshKeepingResourceScroll : function() {
        var scroll = this.getScroll();

        this.refresh();

        if (this.getMode() === 'horizontal') {
            this.scrollVerticallyTo(scroll.top);
        } else {
            this.scrollHorizontallyTo(scroll.left);
        }
    },

    scrollHorizontallyTo : function(x, animate) {
        var el = this.getEl();

        if (el && Ext.supports.Touch) {
            this.setScrollX(x);
        }
        else if (el) {
            el.scrollTo('left', Math.max(0, x), animate);
        }
    },

    scrollVerticallyTo : function(y, animate) {
        var el = this.getEl();

        if (el && Ext.supports.Touch) {
            this.setScrollY(y);
        }
        else if (el) {
           el.scrollTo('top', Math.max(0,  y), animate);
        }
    },

    getVerticalScroll : function() {
        var el = this.getEl();
        return el.getScroll().top;
    },

    getHorizontalScroll : function() {
        var el = this.getEl();
        return el.getScroll().left;
    },

    getScroll : function() {
        var me = this;

        return {
            top  : me.getScrollY(),
            left : me.getScrollX()
        };
    },

    handleScheduleEvent : function () {},

    // A slightly modified Ext.Element#scrollIntoView method using an offset for the edges
    scrollElementIntoView: function(el, hscroll, animate, highlight, edgeOffset, callback, scope) {

        var me              = this,
            dom             = el.dom,
            container       = Ext.getDom(me.getEl()),
            offsets         = el.getOffsetsTo(container),
            scroll          = me.getScroll(),
            left            = offsets[0] + scroll.left,
            top             = offsets[1] + scroll.top,
            bottom          = top + dom.offsetHeight,
            right           = left + dom.offsetWidth,

            ctClientHeight  = container.clientHeight,
            ctScrollTop     = parseInt(scroll.top, 10),
            ctScrollLeft    = parseInt(scroll.left, 10),
            ctBottom        = ctScrollTop + ctClientHeight,
            ctRight         = ctScrollLeft + container.clientWidth,

            newPosX,
            newPosY;

        edgeOffset = edgeOffset === null || edgeOffset === undefined ? 20 : edgeOffset;

        if (dom.offsetHeight > ctClientHeight || top < ctScrollTop) {
            newPosY = top - edgeOffset;
        }
        else if (bottom > ctBottom) {
            newPosY = bottom - ctClientHeight + edgeOffset;
        }

        if (hscroll !== false && dom.offsetWidth > container.clientWidth || left < ctScrollLeft) {
            newPosX = left - edgeOffset;
        }
        else if (hscroll !== false && right > ctRight) {
            newPosX = right - container.clientWidth + edgeOffset;
        }

        animate   = animate   === true && {} || animate;
        highlight = highlight === true && {} || highlight;
        scope     = scope || me;

        if (animate && highlight) {
            animate.listeners = Ext.apply(animate.listeners || {}, {
                'afteranimate' : function() {
                    highlight.listeners = Ext.apply(highlight.listeners || {}, {
                        'afteranimate' : function() {
                            callback && callback.call(scope);
                            callback = null;
                        }
                    });
                    Ext.fly(dom).highlight(null, highlight);
                }
            });
        }
        else if (animate) {
            animate.listeners = Ext.apply(animate.listeners, {
                'afteranimate' : function() {
                    callback && callback.call(scope);
                    callback = null;
                }
            });
        }
        else if (highlight) {
            highlight.listeners = Ext.apply(highlight.listeners || {}, {
                'afteranimate' : function() {
                    callback && callback.call(scope);
                    callback = null;
                }
            });
        }

        newPosY !== undefined && me.setScrollY(newPosY, animate);
        newPosX !== undefined && me.setScrollX(newPosX, animate);

        !animate && highlight && Ext.fly(dom).highlight(null, highlight);

        !animate && !highlight && callback && callback.call(scope);
    },

    disableViewScroller : function(disabled) {
        var scroller = this.getScrollable();

        if (scroller) {
            scroller.setDisabled(disabled);
        }
    }
});

/**

@class Sch.view.TimelineGridView
@extends Ext.grid.View
@mixin Sch.mixin.TimelineView

A grid view class, that consumes the {@link Sch.mixin.TimelineView} mixin. Used internally.

*/

Ext.define('Sch.view.TimelineGridView', {
    extend                  : 'Ext.grid.View',
    mixins                  : [ 'Sch.mixin.TimelineView' ],

    infiniteScroll          : false,

    bufferCoef              : 5,
    bufferThreshold         : 0.2,

    // the scrolLeft position, as Date (not as pixels offset)
    cachedScrollLeftDate    : null,
    boxIsReady              : false,

    ignoreNextHorizontalScroll      : false,


    constructor : function (config) {
        this.callParent(arguments);

        // setup has to happen in the "afterrender" event, because at that point, the view is not "ready" yet
        // so we can freely change the start/end dates of the timeaxis and no refreshes will happen
        if (this.infiniteScroll) {
            this.on('boxready', this.setupInfiniteScroll, this);
        }

        if(this.timeAxisViewModel) {
            this.relayEvents(this.timeAxisViewModel, ['columnwidthchange']);
        }
    },

    setupInfiniteScroll : function () {
        var planner                 = this.panel.ownerCt;
        this.cachedScrollLeftDate   = planner.startDate || this.timeAxis.getStart();

        // check if it's touch microsoft
        if (Ext.supports.Touch && Ext.os.is.Windows) {
            var headerScroll    = this.panel.headerCt.scrollable;
            var viewScroll      = this.scrollable;

            // When scroll is done, Ext throws special event called 'idle'
            // Touch scroller handles that event and performs scroll to [0, 0]
            // Our 'scroll' event handler remembers new view start date and keeps it in memory
            // Disabling this handler seemingly doesn't break anything in case of infinite scroll enabled

            // Try unsubscribing from event. If there's an exception, do nothing
            try {
                Ext.GlobalEvents.un('idle', headerScroll.onIdle, headerScroll);
                Ext.GlobalEvents.un('idle', viewScroll.onIdle, viewScroll);
            }
            catch (e) {
                Ext.log('Cannot unsubscribe required listener, zooming may be broken');
            }
        }

        var me                      = this;

        planner.calculateOptimalDateRange = function (centerDate, panelSize, nextZoomLevel, span) {
            if (span) {
                return span;
            }

            var preset      = Sch.preset.Manager.getPreset(nextZoomLevel.preset);

            return me.calculateInfiniteScrollingDateRange(
                // me.ol.dom.scrollLeft can differ for obvious reasons thus method can return different result for same arguments
                // better user centerDate
                //me.getDateFromCoordinate(me.el.dom.scrollLeft, null, true),
                centerDate,
                preset.getBottomHeader().unit,
                nextZoomLevel.increment,
                nextZoomLevel.width
            );
        };

        // setup scroll/resize listeners
        this.bindInfiniteScrollListeners();
    },


    bindInfiniteScrollListeners : function () {
        if (this.scrollManager) {
            this.scrollManager.scroller.on('scroll', this.onHorizontalScroll, this);
        } else {
            this.el.on('scroll', this.onHorizontalScroll, this);
        }

        // this event is fired immediately after `afterrender`
        this.on('resize', this.onSelfResize, this);
    },


    unbindInfiniteScrollListeners : function () {
        if (this.scrollManager) {
            this.scrollManager.scroller.un('scroll', this.onHorizontalScroll, this);
        } else {
            this.el.un('scroll', this.onHorizontalScroll, this);
        }

        this.un('resize', this.onSelfResize, this);
    },


    onHorizontalScroll : function () {
        if (this.ignoreNextHorizontalScroll || this.cachedScrollLeftDate) {
            this.ignoreNextHorizontalScroll = false;
            return;
        }

        var dom         = this.el.dom,
            width       = this.getWidth(),
            left        = this.getScroll().left,
            scrollWidth = this.scrollManager ? this.scrollManager.scroller.getMaxPosition().x : dom.scrollWidth,
            limit       = width * this.bufferThreshold * this.bufferCoef;

        // if scroll violates limits let's shift timespan
        if ((scrollWidth - left - width < limit) || left < limit) {
            this.shiftToDate(this.getDateFromCoordinate(left, null, true));

            // Make sure any scrolling which could have been triggered by the Bryntum ScrollManager (drag drop of task),
            // is cancelled
            this.el.stopAnimation();
        }
    },


    refresh : function () {
        this.callParent(arguments);

        // `scrollStateSaved` will mean that refresh happens as part of `refreshKeepingScroll`,
        // which already does `restoreScrollState`, which includes `restoreScrollLeftDate`
        if (this.infiniteScroll && !this.scrollStateSaved && this.boxIsReady) {
            this.restoreScrollLeftDate();
        }
    },


    onSelfResize : function (view, width, height, oldWidth, oldHeight) {
        this.boxIsReady = true;

        // TODO this should be optimized to not perform any operations as long as view size doesn't increase
        // enough to pass the buffer limits
        if (width !== oldWidth) {
            // When size increases - we should maintain the left visible date in the component to not confuse the user
            this.shiftToDate(this.cachedScrollLeftDate || this.getVisibleDateRange().startDate, this.cachedScrollCentered);
        }
    },


    restoreScrollLeftDate : function () {
        if (this.cachedScrollLeftDate && this.boxIsReady) {
            this.ignoreNextHorizontalScroll     = true;

            this.scrollToDate(this.cachedScrollLeftDate);

            this.cachedScrollLeftDate           = null;
        }
    },


    scrollToDate : function (toDate) {
        this.cachedScrollLeftDate           = toDate;

        if (this.cachedScrollCentered){
            this.panel.ownerCt.scrollToDateCentered(toDate);
        } else {
            this.panel.ownerCt.scrollToDate(toDate);
        }

        var scrollLeft                      = this.getScroll().left;

        // the `onRestoreHorzScroll` method in Ext.panel.Table is called during Ext.resumeLayouts(true) (in the `refreshKeepingScroll`)
        // and messes up the scrolling position (in the called `syncHorizontalScroll` method).
        // Overwrite the property `syncHorizontalScroll` is using to read the scroll position, so that no actual change will happen
        this.panel.scrollLeftPos            = scrollLeft;

        // the previous line however, breaks the header sync, doing that manually
        this.headerCt.el.dom.scrollLeft     = scrollLeft;
    },


    saveScrollState : function () {
        this.scrollStateSaved       = this.boxIsReady;

        this.callParent(arguments);
    },


    restoreScrollState : function () {
        this.scrollStateSaved       = false;

        // if we have scroll date then let's calculate left-coordinate by this date
        // and top-coordinate we'll get from the last saved scroll state
        if (this.infiniteScroll && this.cachedScrollLeftDate) {
            this.restoreScrollLeftDate();

            this.el.dom.scrollTop = this.scrollState.top;

            return;
        }

        this.callParent(arguments);
    },


    // `calculateOptimalDateRange` already exists in Zoomable plugin
    calculateInfiniteScrollingDateRange : function (srollLeftDate, unit, increment, tickWidth) {
        var timeAxis            = this.timeAxis;
        var viewWidth           = this.getWidth();

        tickWidth               = tickWidth || this.timeAxisViewModel.getTickWidth();
        increment               = increment || timeAxis.increment || 1;
        unit                    = unit || timeAxis.unit;

        var DATE                = Sch.util.Date;

        var bufferedTicks       = Math.ceil(viewWidth * this.bufferCoef / tickWidth);

        return {
            start   : timeAxis.floorDate(DATE.add(srollLeftDate, unit, -bufferedTicks * increment), false, unit, increment),
            end     : timeAxis.ceilDate(DATE.add(srollLeftDate, unit, Math.ceil((viewWidth / tickWidth + bufferedTicks) * increment)), false, unit, increment)
        };
    },


    shiftToDate : function (scrollLeftDate, scrollCentered) {
        var newRange            = this.calculateInfiniteScrollingDateRange(scrollLeftDate);

        // we set scroll date here since it will be required during timeAxis.setTimeSpan() call
        this.cachedScrollLeftDate   = scrollLeftDate;
        this.cachedScrollCentered   = scrollCentered;

        // this will trigger a refresh (`refreshKeepingScroll`) which will perform `restoreScrollState` and sync the scrolling position
        this.timeAxis.setTimeSpan(newRange.start, newRange.end);
    },


    destroy : function () {
        if (this.infiniteScroll && this.rendered) this.unbindInfiniteScrollListeners();

        this.callParent(arguments);
    }

});

/**

@class Sch.mixin.AbstractSchedulerView
@private

A mixin for {@link Ext.view.View} classes, providing "scheduling" functionality to the consuming view. A consuming class
should have already consumed the {@link Sch.mixin.TimelineView} mixin.

Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

*/
Ext.define('Sch.mixin.AbstractSchedulerView', {
    requires                : [
        'Sch.model.Assignment',
        'Sch.template.Event',
        'Sch.eventlayout.Horizontal',
        'Sch.view.Vertical',
        'Sch.eventlayout.Vertical'
    ],

    _cmpCls                 : 'sch-schedulerview',
    scheduledEventName      : 'event',
    eventTemplateClass      : 'Sch.template.Event',

    // The template instance responsible for rendering the event bars
    eventTpl                : null,

    /**
    * @cfg {Number} barMargin
    * Controls how much space to leave between the event bars and the row borders.
    */
    barMargin               : 1,

    /**
    * @cfg {Boolean} constrainDragToResource Set to true to only allow dragging events within the same resource.
    */
    constrainDragToResource : false,

    // Provided by panel
    allowOverlap            : null,
    readOnly                : null,

    altColCls               : 'sch-col-alt',

    /**
    * @cfg {Boolean} dynamicRowHeight
    * True to layout events without overlapping, meaning the row height will be dynamically calculated to fit any overlapping events.
    */
    dynamicRowHeight        : true,

    /**
    * @cfg {Boolean} managedEventSizing
    * True to size events based on the rowHeight and barMargin settings. Set this to false if you want to control height and top properties via CSS instead.
    */
    managedEventSizing      : true,

    /**
    * @cfg {Boolean} eventAnimations
    * True to animate event updates, currently only used in vertical mode in CSS3 enabled browsers.
    */
    eventAnimations         : true,

    /**
     * @cfg {String} horizontalLayoutCls
     * The class name responsible for the horizontal event layout process. Override this to take control over the layout process.
     */
    horizontalLayoutCls     : 'Sch.eventlayout.Horizontal',


    horizontalEventSorterFn     : null,
    /**
     * @cfg {Function} horizontalEventSorterFn
     *
     *  Override this method to provide a custom sort function to sort any overlapping events. By default,
     *  overlapping events are laid out based on the start date. If the start date is equal, events with earlier end date go first.
     *
     *  Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event a is placed above event b.
     *
     horizontalEventSorterFn : function (a, b) {

            var startA = a.getStartDate(), endA = a.getEndDate();
            var startB = b.getStartDate(), endB = b.getEndDate();

            var sameStart = (startA - startB === 0);

            if (sameStart) {
                return endA > endB ? -1 : 1;
            } else {
                return (startA < startB) ? -1 : 1;
            }
        }
     *
     * @param  {Sch.model.Event} a
     * @param  {Sch.model.Event} b
     * @return {Int}
     */

    /**
     * @cfg {String} verticalLayoutCls
     * The class name responsible for the vertical event layout process. Override this to take control over the layout process.
     */

    verticalLayoutCls       : 'Sch.eventlayout.Vertical',

    /**
     * @cfg {Function} verticalEventSorterFn
     * Override this method to provide a custom sort function to sort any overlapping events. By default,
     * overlapping events are laid out based on the start date. If the start date is equal, events with earlier end date go first.
     *
     * If this function returns -1, then event a is placed above event b.
     * See also {@link #horizontalEventSorterFn} for a description.
     * @param {Sch.model.Event} a
     * @param {Sch.model.Event} b
     * @return {Int}
     */

    verticalEventSorterFn     : null,

    eventCls                : 'sch-event',

    verticalViewClass       : 'Sch.view.Vertical',

    eventStore              : null,
    resourceStore           : null,
    eventLayout             : null,

    /**
     * @event eventrepaint
     * Fires after an event has been repainted by the view.
     * @param {Sch.mixin.AbstractSchedulerView} view The view instance
     * @param {Sch.model.Event} event
     * @param {HTMLElement} node The updated DOM representation of the event
     */

    _initializeSchedulerView        : function() {
        var horLayoutCls = Ext.ClassManager.get(this.horizontalLayoutCls);
        var vertLayoutCls = Ext.ClassManager.get(this.verticalLayoutCls);

        this.eventSelector = '.' + this.eventCls;

        this.eventLayout = {};

        if (horLayoutCls) {

            this.eventLayout.horizontal = new horLayoutCls(
                Ext.apply(
                    // this is required for table layout
                    { timeAxisViewModel : this.timeAxisViewModel },
                    {
                        bandIndexToPxConvertFn    : this.horizontal.layoutEventVertically,
                        bandIndexToPxConvertScope : this.horizontal
                    },
                    this.horizontalEventSorterFn ? { sortEvents: this.horizontalEventSorterFn } : {}
                )
            );
        }

        if (vertLayoutCls) {
            this.eventLayout.vertical = new vertLayoutCls(
                Ext.apply(
                    {},
                    { view : this },
                    this.verticalEventSorterFn ? { sortEvents: this.verticalEventSorterFn } : {}
                )
            );
        }

        this.store              = this.store || this.resourceStore;
        this.resourceStore      = this.resourceStore || this.store;
    },

    generateTplData: function (event, resourceRecord, columnIndex) {
        var renderData = this[this.mode].getEventRenderData(event, resourceRecord, columnIndex),
            start       = event.getStartDate(),
            end         = event.getEndDate(),
            internalCls = event.getCls() || '';

        internalCls += ' sch-event-resizable-' + event.getResizable();

        if (event.dirty)                    internalCls += ' sch-dirty ';
        if (renderData.endsOutsideView)     internalCls += ' sch-event-endsoutside ';
        if (renderData.startsOutsideView)   internalCls += ' sch-event-startsoutside ';
        if (this.eventBarIconClsField)      internalCls += ' sch-event-withicon ';
        if (event.isDraggable() === false)  internalCls += ' sch-event-fixed ';
        if (end - start === 0)              internalCls += ' sch-event-milestone ';

        // in calendar mode event can be rendered in miltiple columns yet it remains the same
        // to distinguish them we append resource index to element id
        renderData.id          = event.internalId + '-' + resourceRecord.internalId + (this.getMode() === 'calendar' ? ('-' + columnIndex) : '-x' /* this is important for getElement(s)FromEventRecord() */);
        renderData.internalCls = internalCls;
        renderData.start       = start;
        renderData.end         = end;
        renderData.iconCls     = event.data[this.eventBarIconClsField] || '';
        renderData.event       = event;

        if (this.eventRenderer) {
            // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate
            var value = this.eventRenderer.call(this.eventRendererScope || this, event, resourceRecord, renderData, columnIndex);
            if (Ext.isObject(value) && this.eventBodyTemplate) {
                renderData.body = this.eventBodyTemplate.apply(value);
            } else {
                renderData.body = value;
            }
        } else if (this.eventBodyTemplate) {
            // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.
            renderData.body = this.eventBodyTemplate.apply(event.data);
        } else if (this.eventBarTextField) {
            // User has specified a field in the data model to read from
            renderData.body = event.data[this.eventBarTextField] || '';
        }
        return renderData;
    },

    /**
    * Resolves the resource based on a dom element
    * @param {HtmlElement} node The HTML element
    * @return {Sch.model.Resource} The resource corresponding to the element, or null if not found.
    */
    resolveResource: function (node) {
        var me = this;
        return me[me.mode].resolveResource(node);
    },

    /**
    * Gets the Ext.util.Region representing the passed resource and optionally just for a certain date interval.
    * @param {Sch.model.Resource} resourceRecord The resource record
    * @param {Date} startDate A start date constraining the region
    * @param {Date} endDate An end date constraining the region
    * @return {Ext.util.Region} The region of the resource
    */
    getResourceRegion: function (resourceRecord, startDate, endDate) {
        return this[this.mode].getResourceRegion(resourceRecord, startDate, endDate);
    },

    /**
    * <p>Returns the event record for a DOM element </p>
    * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
    * @return {Sch.model.Event|Null} The event record
    */
    resolveEventRecord: function (el) {
        // Normalize to DOM node
        el = el.dom ? el.dom : el;

        if (!(Ext.fly(el).is(this.eventSelector))) {
            el = Ext.fly(el).up(this.eventSelector);
        }

        return el && this.getEventRecordFromDomId(el.id);
    },

    // TODO: Get rid of this, make it in inline?, move it to mixins/SchedulerView
    resolveEventRecordFromResourceRow: function (el) {
        var me = this,
            sm = me.getEventSelectionModel(),
            resource,
            event;

        el = el.dom ? el.dom : el;
        resource = me.getRecord(el);

        return sm.getFirstSelectedEventForResource(resource);
    },


    /**
    * Returns an assignment record for a DOM element
    *
    * @param {HTMLElement/Ext.Element} el The DOM node or Ext Element to lookup
    * @return {Sch.model.Assignment|Null} The assignment record
    */
    resolveAssignmentRecord : function(el) {
        var me = this,
            assignmentStore = me.eventStore.getAssignmentStore(),
            assignment = null,
            event,
            resource;

        if (assignmentStore) {
            el = el.dom && el.dom || el;
            event = me.getEventRecordFromDomId(el.id);
            resource = me.getResourceRecordFromDomId(el.id);
            if (event && resource) {
                assignment = assignmentStore.getAssignmentForEventAndResource(event, resource);
            }
        }

        return assignment;
    },

    /**
    * <p>Returns the event record for a DOM id </p>
    * @param {String} id The id of the DOM node
    * @return {Sch.model.Event} The event record
    */
    getEventRecordFromDomId: function(id) {
        id = this.getEventIdFromDomNodeId(id);
        return this.eventStore.getModelByInternalId(id);
    },

    /**
     * Returns a resource record for a DOM id
     * @param {String} id An id of an event DOM node
     * @return {Sch.model.Resource} A resource record
     */
    getResourceRecordFromDomId : function(id) {
        id = this.getResourceIdFromDomNodeId(id);
        return this.eventStore.getResourceStore().getByInternalId(id);
    },

    /**
    * Checks if a date range is allocated or not for a given resource.
    * @param {Date} start The start date
    * @param {Date} end The end date
    * @param {Sch.model.Event} excludeEvent An event to exclude from the check (or null)
    * @param {Sch.model.Resource} resource The resource
    * @return {Boolean} True if the timespan is available for the resource
    */
    isDateRangeAvailable: function (start, end, excludeEvent, resource) {
        return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);
    },

    /**
    * Returns events that are (partly or fully) inside the timespan of the current view.
    * @return {Ext.util.MixedCollection} The collection of events
    */
    getEventsInView: function () {
        var viewStart = this.timeAxis.getStart(),
            viewEnd = this.timeAxis.getEnd();

        return this.eventStore.getEventsInTimeSpan(viewStart, viewEnd);
    },

    /**
    * Returns the current set of rendered event nodes
    * @return {Ext.CompositeElement} The collection of event nodes
    */
    getEventNodes: function () {
        return this.getEl().select(this.eventSelector);
    },

    onEventCreated: function (newEventRecord) {
        // Empty but provided so that you can override it to supply default record values etc.
    },

    getEventStore: function () {
        return this.eventStore;
    },

    registerEventEditor: function (editor) {
        this.eventEditor = editor;
    },

    getEventEditor: function () {
        return this.eventEditor;
    },

    // Call mode specific implementation
    onEventUpdate: function (store, model, operation) {
        this[this.mode].onEventUpdate(store, model, operation);
    },

    // Call mode specific implementation
    onEventAdd: function (s, recs) {
        // TreeStore 'insert' and 'append' events pass a single Model instance, not an array
        if (!Ext.isArray(recs)) recs = [recs];

        this[this.mode].onEventAdd(s, recs);
    },

    // Call mode specific implementation
    onAssignmentAdd : function(store, assignments) {
        var me = this;

        Ext.Array.forEach(assignments, function(assignment) {
            var resource = assignment.getResource();
            resource && me.repaintEventsForResource(resource);
        });
    },

    onAssignmentUpdate : function(store, assignment) {
        var me            = this,
            oldResourceId = assignment.previous && assignment.previous[assignment.resourceIdField],
            newResourceId = assignment.getResourceId(),
            oldResource,
            newResource;

        if (oldResourceId) {
            oldResource = me.resourceStore.getModelById(oldResourceId);
            me.repaintEventsForResource(oldResource);
        }

        if (newResourceId) {
            newResource = me.resourceStore.getModelById(newResourceId);
            me.repaintEventsForResource(newResource);
        }
    },

    onAssignmentRemove : function(store, assignments) {
        var me = this;

        Ext.Array.forEach(assignments, function(assignment) {
            var resourceId = assignment.getResourceId();
            var resource = resourceId && me.resourceStore.getModelById(resourceId);
            resource && me.repaintEventsForResource(resource);
        });
    },

    // Call orientation specific implementation
    onEventRemove: function (s, recs) {
        this[this.mode].onEventRemove(s, recs);
    },

    bindEventStore: function (eventStore, initial) {

        var me = this;
        var listenerCfg = {
            scope       : me,
            refresh     : me.onEventDataRefresh,

            // Sencha Touch
            addrecords      : me.onEventAdd,
            updaterecord    : me.onEventUpdate,
            removerecords   : me.onEventRemove,

            // Ext JS
            add         : me.onEventAdd,
            update      : me.onEventUpdate,
            remove      : me.onEventRemove,

            // If the eventStore is a TreeStore
            nodeinsert  : me.onEventAdd,
            nodeappend  : me.onEventAdd
        };

        // In case there is an assigment store used
        var assignmentListenerCfg = {
            scope       : me,
            refresh     : me.onEventDataRefresh,
            load        : me.onEventDataRefresh,
            update      : me.onAssignmentUpdate,
            add         : me.onAssignmentAdd,
            remove      : me.onAssignmentRemove
        };

        // Sencha Touch fires "refresh" when clearing the store. Avoid double repaints
        if (!Ext.versions.touch) {
            listenerCfg.clear = me.onEventDataRefresh;
        }

        if (!initial && me.eventStore) {
            me.eventStore.setResourceStore(null);

            if (eventStore !== me.eventStore && me.eventStore.autoDestroy) {
                me.eventStore.destroy();
            }
            else {
                if (me.mun) {
                    me.mun(me.eventStore, listenerCfg);

                    var oldAssignmentStore = me.eventStore.getAssignmentStore && me.eventStore.getAssignmentStore();

                    if (oldAssignmentStore) {
                        me.mun(oldAssignmentStore, assignmentListenerCfg);
                    }
                } else {
                    me.eventStore.un(listenerCfg);
                }
            }

            if (!eventStore) {
                me.eventStore = null;
            }
        }
        if (eventStore) {
            eventStore = Ext.data.StoreManager.lookup(eventStore);

            if (me.mon) {
                me.mon(eventStore, listenerCfg);
            } else {
                eventStore.on(listenerCfg);
            }

            me.eventStore = eventStore;

            eventStore.setResourceStore(me.resourceStore);

            var assignmentStore = eventStore.getAssignmentStore && eventStore.getAssignmentStore();

            if (assignmentStore) {
                me.mon(assignmentStore, assignmentListenerCfg);
            }
        }

        if (eventStore && !initial) {
            me.refresh();
        }
    },

    onEventDataRefresh: function () {
        this.refreshKeepingScroll();
    },

    // invoked by the selection model to maintain visual UI cues
    onEventBarSelect: function (record) {
        var me = this,
            event,
            resource;

        if (record instanceof Sch.model.Assignment) {
            event = record.getEvent();
            resource = record.getResource();
        }
        else {
            event = record;
            resource = null;
        }

        Ext.Array.forEach(me.getElementsFromEventRecord(event, resource), function(el) {
            el.addCls(me.selectedEventCls);
        });
    },

    // invoked by the selection model to maintain visual UI cues
    onEventBarDeselect: function (record) {
        var me = this,
            event,
            resource;

        if (record instanceof Sch.model.Assignment) {
            event = record.getEvent();
            resource = record.getResource();
        }
        else {
            event = record;
            resource = null;
        }

        event && Ext.Array.forEach(me.getElementsFromEventRecord(event, resource), function(el) {
            el.removeCls(me.selectedEventCls);
        });
    },

    refresh : function() {
        throw 'Abstract method call';
    },

    /**
    * Refreshes the events for a single resource
    * @param {Sch.model.Resource} resource
    */
    repaintEventsForResource : function (record) {
        throw 'Abstract method call';
    },

    /**
     * Refreshes all events in the scheduler view
     */
    repaintAllEvents : function () {
        this.refreshKeepingScroll();
    },

    /**
     * Scrolls an event record into the viewport.
     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.
     *
     * @param {Sch.model.Event} eventRec, the event record to scroll into view
     * @param {Boolean/Object} highlight, either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     * @param {Boolean/Object} animate, either `true/false` or an animation config object used to scroll the element
     *
     * @deprecated
     */
    scrollEventIntoView: function (eventRec, highlight, animate, callback, scope) {
        var me = this,
            resources = eventRec.getResources();

        resources.length && me.scrollResourceEventIntoView(resources[0], eventRec, null, highlight, animate, callback, scope);
    },

    /**
     * Scrolls a resource event record into the viewport.
     *
     * If the resource store is a tree store, this method will also expand all relevant parent nodes
     * to locate the event.
     *
     * @param {Sch.model.Resource} resourceRec A resource record an event record is assigned to
     * @param {Sch.model.Event} eventRec    An event record to scroll into view
     * @param {Number} index                DOM node index, applicable only for Calendar view mode
     * @param {Boolean/Object} highlight    Either `true/false` or a highlight config object used to highlight the element after scrolling it into view
     * @param {Boolean/Object} animate      Either `true/false` or an animation config object used to scroll the element
     */
    scrollResourceEventIntoView : function(resourceRec, eventRec, index, highlight, animate, callback, scope) {
        var me = this,
            eventStart = eventRec.getStartDate(),
            eventEnd   = eventRec.getEndDate(),
            currentTimeSpanRange,
            el;

        // Make sure resource is visible if it's part of a TreeStore
        if (Ext.data.TreeStore && me.resourceStore instanceof Ext.data.TreeStore) {
            resourceRec.bubble(function(node) { node.expand(); });
        }

        // Make sure event is within current time axis time span
        if (!me.timeAxis.dateInAxis(eventStart) || !me.timeAxis.dateInAxis(eventEnd)) {
            currentTimeSpanRange = me.timeAxis.getEnd() - me.timeAxis.getStart();
            me.timeAxis.setTimeSpan(
                new Date(eventStart.valueOf() - currentTimeSpanRange / 2),
                new Date(eventEnd.getTime()   + currentTimeSpanRange / 2)
            );
            // HACK:
            // After a time axis change, the header is resized and Ext JS TablePanel reacts to the size change.
            // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
            me.up('panel').scrollTask.cancel();
        }

        // Scrolling
        me.panel.ownerCt.ensureVisible(resourceRec, {
            callback : function() {
                // 1. ensureVisible on a lockable grid will call callback twice one for normal grid and another
                //    for locked grid
                // 2. since we do not provide the scope for the callback then 'this' here will point to either
                //    normal grid or locked grid the callback is called for
                // 3. We use this.isLocked to execute callback logic for the normal grid only.
                if (this.isLocked === false) {
                    // Establishing element to scroll to
                    el = me.getElementsFromEventRecord(eventRec, resourceRec, index);
                    el = el.length && el[0] || null; // In Calendar view there might be several elements correspond to resource/event pair.
                    // Scrolling with view with animation and highlighting if needed
                    me.scrollElementIntoView(el, true, animate, highlight, null, callback, scope);
                }
            }
        });
    }
});

/**

 @class Sch.mixin.SchedulerView

 A mixin for {@link Ext.view.View} classes, providing "scheduling" functionality to the consuming view. A consuming class
 should have already consumed the {@link Sch.mixin.TimelineView} mixin.

 Generally, should not be used directly, if you need to subclass the view, subclass the {@link Sch.view.SchedulerGridView} instead.

 */
Ext.define('Sch.mixin.SchedulerView', {
    extend : 'Sch.mixin.AbstractSchedulerView',

    mixins : ['Sch.mixin.Localizable'],

    requires : [
        'Sch.feature.DragCreator',
        'Sch.feature.DragDrop',
        'Sch.feature.ResizeZone',
        'Sch.column.Resource',
        'Sch.view.Calendar',
        'Ext.XTemplate'
    ],

    /**
     * @property {Sch.feature.SchedulerDragZone} eventDragZone
     * Accessor to the event dragzone (available only if the drag drop feature is enabled)
     */

    /**
     * @cfg {String} eventResizeHandles Defines which resize handles to use. Possible values: 'none', 'start', 'end', 'both'. Defaults to 'end'
     */
    eventResizeHandles : 'end',

    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during a drag and drop process and also after the drop is made.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Event[]} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the drag proxy position
     * @param {Number} duration The duration of the item being dragged in milliseconds
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the drop position is valid, else false to prevent a drop. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    dndValidatorFn : Ext.emptyFn,

    /**
     * An empty function by default, but provided so that you can perform custom validation on
     * an item being resized. To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Resource} resourceRecord the resource of the row in which the event is located
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the resize state is valid, else false to prevent the action. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    resizeValidatorFn : Ext.emptyFn,

    /**
     * An empty function by default, but provided so that you can perform custom validation on the item being created.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean/Object} true if the state is valid, else false to prevent the action. Or return an object containing a 'valid' boolean and a 'message' string.
     */
    createValidatorFn : Ext.emptyFn,

    // Scheduled events: click events --------------------------
    /**
     * @event eventclick
     * Fires when an event is clicked
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventmousedown
     * Fires when a mousedown event is detected on a rendered event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventmouseup
     * Fires when a mouseup event is detected on a rendered event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventdblclick
     * Fires when an event is double clicked
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventcontextmenu
     * Fires when contextmenu is activated on an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record of the clicked event
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventmouseenter
     * Fires when the mouse moves over an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.EventObject} e The event object
     */
    /**
     * @event eventmouseout
     * Fires when the mouse moves out of an event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} eventRecord The event record
     * @param {Ext.EventObject} e The event object
     */

    // Resizing events start --------------------------
    /**
     * @event beforeeventresize
     * Fires before a resize starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The record about to be resized
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventresizestart
     * Fires when resize starts
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The event record being resized
     */

    /**
     * @event eventpartialresize
     * Fires during a resize operation and provides information about the current start and end of the resized event
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The event record being resized
     * @param {Date} startDate The new start date of the event
     * @param {Date} endDate The new end date of the event
     * @param {Ext.Element} element The proxy element being resized
     */

    /**
     * @event beforeeventresizefinalize
     * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
     * be done immedieately, giving you a chance to show a confirmation popup before applying the new values.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Object} resizeContext An object containing, 'start', 'end', 'newResource' properties.
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventresizeend
     * Fires after a succesful resize operation
     * @param {Mixed} view The scheduler view instance
     * @param {Sch.model.Event} record The updated event record
     */
    // Resizing events end --------------------------

    // Dnd events start --------------------------
    /**
     * @event beforeeventdrag
     * Fires before a dnd operation is initiated, return false to cancel it
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} record The record corresponding to the node that's about to be dragged
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventdragstart
     * Fires when a dnd operation starts
     * @param {Sch.mixin.SchedulerView} scheduler The scheduler object
     * @param {Array} records the records being dragged
     */

    /**
     * @event beforeeventdropfinalize
     * Fires before a succesful drop operation is finalized.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Object} dragContext An object containing, 'start', 'end', 'newResource' properties.
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event eventdrop
     * Fires after a succesful drag and drop operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event[]} records the affected records (if copies were made, they were not inserted into the store)
     * @param {Boolean} isCopy True if the records were copied instead of moved
     */

    /**
     * @event aftereventdrop
     * Fires when after a drag n drop operation, even when drop was performed on an invalid location
     * @param {Mixed} view The scheduler view instance
     */
    // Dnd events end --------------------------

    // Drag create events start --------------------------
    /**
     * @event beforedragcreate
     * Fires before a drag starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Resource} resource The resource record
     * @param {Date} date The clicked date on the timeaxis
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event dragcreatestart
     * Fires before a drag starts, return false to stop the execution
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Ext.Element} el The proxy element
     */

    /**
     * @event beforedragcreatefinalize
     * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
     * be done immedieately, giving you a chance to show a confirmation popup before applying the new values.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Object} createContext An object containing, 'start', 'end', 'resourceRecord' properties.
     * @param {Ext.EventObject} e The event object
     * @param {Ext.Element} el The proxy element
     */

    /**
     * @event dragcreateend
     * Fires after a successful drag-create operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} newEventRecord The newly created event record (added to the store in onEventCreated method)
     * @param {Sch.model.Resource} resource The resource record to which the event belongs
     * @param {Ext.EventObject} e The event object
     * @param {Ext.Element} el The proxy element
     */

    /**
     * @event afterdragcreate
     * Always fires after a drag-create operation
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Ext.Element} el The proxy element
     */
    // Drag create events end --------------------------

    /**
     * @event beforeeventadd
     * Fires after a successful drag-create operation, before the new event is added to the store. Return false to prevent the event from being added to the store.
     * @param {Sch.mixin.SchedulerView} view The scheduler view instance
     * @param {Sch.model.Event} newEventRecord The newly created event record
     */

    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.SchedulerView} schedulerView The scheduler view object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - loadingText : 'Loading events...'
     */

    calendarViewClass : 'Sch.view.Calendar',

    _initializeSchedulerView : function () {
        this.callParent(arguments);

        this.on({
            destroy     : this._destroy,
            afterrender : this._afterRender,
            itemupdate  : this.onRowUpdated,
            scope       : this
        });

        // HACK
        // 015_buffered_scroll fails in IE and FF because end row in normal view may have
        // inline style, added by sencha row synchronizer, that will break rows sync
        // TODO: When Ext 5.1.2 is out - try removing this hack
        if (Ext.getVersion().isGreaterThan('5.1.1')) {
            this.on('itemadd', function (records) {
                var el = this.all.item(this.all.endIndex - records.length);
                if (el) {
                    el.dom.style.height = '';
                }
            });
        }
        // ENDHACK

        var me = this;

        if (!this.eventPrefix) {
            throw 'eventPrefix missing';
        }

        me.eventTpl  = me.eventTpl || Ext.create(this.eventTemplateClass, {
            eventPrefix   : this.eventPrefix,
            resizeHandles : this.eventResizeHandles
        });
    },

    inheritables : function () {
        return {

            // Configuring underlying grid view
            loadingText     : this.L('loadingText'),
            overItemCls     : '',
            trackOver       : false,
            selectedItemCls : '', // We don't want row selection visible here
            // EOF: Configuring underlying grid view

            setReadOnly : function (readOnly) {
                if (this.dragCreator) {
                    this.dragCreator.setDisabled(readOnly);
                }
                this.callParent(arguments);
            },

            repaintEventsForResource : function (resourceRecord, refreshSelections) {
                var me              = this,
                    mode            = me.getMode(),
                    isHorizontal    = mode === 'horizontal',
                    // For vertical, we always repaint all events (do per-column repaint is not supported)
                    index           = isHorizontal ? me.indexOf(resourceRecord) : 0;

                if (isHorizontal) {
                    me.eventLayout.horizontal.clearCache(resourceRecord);
                }

                if (index >= 0) {
                    // HACK, Ext insists on performing layouts when refreshing a grid row.
                    // Prevent this, "should be" safe.
                    Ext.suspendLayouts();

                    // we operate "resourceRecord" here since "index" might be incorrect when grouping plugin is used
                    if (isHorizontal) {
                        me.refreshNode(resourceRecord);
                        me.lockingPartner.refreshNode(resourceRecord);
                    }
                    // Use index here to keep vertical view only refreshing first row always
                    else {
                        me.refreshNode(index);
                        me.lockingPartner.refreshNode(index);
                    }

                    Ext.resumeLayouts();

                    if (refreshSelections) {
                        var sm = me.getEventSelectionModel();
                        var events = me.eventStore.getEventsForResource(resourceRecord);

                        Ext.Array.forEach(events, function (ev) {
                            sm.forEachEventRelatedSelection(ev, function(selectedRecord) {
                                me.onEventBarSelect(selectedRecord, true);
                            });
                        });
                    }
                }
            },

            repaintAllEvents : function () {
                if (this.mode === 'horizontal') {
                    this.refresh();
                } else {
                    // All events are rendered in first row, no need to do a full refresh
                    this.refreshNode(0);
                }
            },


            handleScheduleEvent : function (e) {
                var te = e.getTarget('.' + this.eventCls, 3),
                    t = !te && e.getTarget('.' + this.timeCellCls, 3);

                if (t) {
                    var clickedDate = this.getDateFromDomEvent(e, 'floor');
                    var resourceNode = this.findRowByChild(t);
                    var index = this.indexOf(resourceNode);

                    var resource;

                    if (this.mode == 'horizontal') {
                        resource = this.getRecordForRowNode(resourceNode);
                    } else {
                        var cellNode = e.getTarget(this.timeCellSelector, 5);

                        if (cellNode) {
                            var cellIndex = typeof cellNode.cellIndex == 'number' ? cellNode.cellIndex : cellNode.getAttribute('data-cellIndex');
                            var header = this.headerCt.getGridColumns()[cellIndex];

                            resource = header && header.model;
                        }
                    }

                    if (e.type.indexOf('pinch') >= 0) {
                        this.fireEvent('schedule' + e.type, this, e);
                    } else {
                        this.fireEvent('schedule' + e.type, this, clickedDate, index, resource, e);
                    }
                }
            },


            onEventDataRefresh : function () {
                this.clearRowHeightCache();
                this.callParent(arguments);
            },


            onUnbindStore : function (store) {
                store.un({
                    refresh : this.clearRowHeightCache,
                    clear   : this.clearRowHeightCache,
                    load    : this.clearRowHeightCache,

                    scope : this
                });
                this.callParent(arguments);
            },

            // our listeners must go before any other listeners, that's why we override the 'bindStore'
            // instead of `onBindStore`
            bindStore     : function (store) {
                store && store.on({
                    refresh : this.clearRowHeightCache,
                    clear   : this.clearRowHeightCache,
                    load    : this.clearRowHeightCache,

                    scope : this
                });
                this.callParent(arguments);
            },

            refreshKeepingScroll : function() {

                this.lockingPartner.saveScrollState();
                this.lockingPartner.refresh();
                this.lockingPartner.restoreScrollState();

                this.callParent(arguments);
            }
        };
    },

    /**
     * Returns the selection model being used, and creates it via the configuration
     * if it has not been created already.
     * @return {Sch.selection.EventModel} selModel
     */
    getEventSelectionModel : function () {
        var me = this,
            eventSelModel = me.eventSelModel,
            eventSelModelType = me.eventSelModelType,
            mode;

        // already has the event selection model
        if (eventSelModel && eventSelModel.events) {
            return eventSelModel;
        }

        if (!eventSelModel) {
            eventSelModel = {};
        }

        if (!eventSelModelType && me.eventStore.getAssignmentStore()) {
            eventSelModelType = 'assignmentmodel';
        }
        else if (!eventSelModelType) {
            eventSelModelType = 'eventmodel';
        }

        mode = 'SINGLE';

        if (me.simpleSelect) {
            mode = 'SIMPLE';
        } else if (me.multiSelect) {
            mode = 'MULTI';
        }

        Ext.applyIf(eventSelModel, {
            allowDeselect : me.allowDeselect,
            mode          : mode
        });

        if (!eventSelModel.events) {
            eventSelModel = me.eventSelModel = Ext.create('selection.' + eventSelModelType, eventSelModel);
        }

        // lock the selection model if user
        // has disabled selection
        if (me.disableSelection) {
            eventSelModel.locked = true;
        }

        return eventSelModel;
    },

    _afterRender : function () {
        this.bindEventStore(this.eventStore, true);

        this.getEventSelectionModel().bindToView(this);

        this.setupEventListeners();

        this.configureFunctionality();

        var resizer = this.headerCt.resizer;

        if (resizer) {
            resizer.doResize = Ext.Function.createSequence(resizer.doResize, this.afterHeaderResized, this);
        }

        // Delete the lastItem (last item we hovered over) so that after a drag drop the UI considers the
        // mouse to be over the current element
        this.on('itemupdate',function() {
            delete this.lastItem;
        });
    },

    // private, clean up
    _destroy     : function () {
        this.bindEventStore(null);
    },


    clearRowHeightCache : function () {
        if (this.mode === 'horizontal') {
            this.eventLayout.horizontal.clearCache();
        }
    },


    configureFunctionality : function () {
        var vfScope = this.validatorFnScope || this;

        if (this.eventResizeHandles !== 'none' && Sch.feature.ResizeZone) {
            this.resizePlug = new Sch.feature.ResizeZone(Ext.applyIf({
                schedulerView : this,

                validatorFn : function (resourceRecord, eventRecord, startDate, endDate) {
                    return (this.allowOverlap || this.isDateRangeAvailable(startDate, endDate, eventRecord, resourceRecord)) &&
                            this.resizeValidatorFn.apply(vfScope, arguments);
                },

                validatorFnScope : this
            }, this.resizeConfig || {}));
        }

        if (this.enableEventDragDrop !== false && Sch.feature.DragDrop) {

            this.dragdropPlug = new Sch.feature.DragDrop(this, {
                validatorFn : function (dragRecords, targetResourceRecord, date, duration) {
                    return (this.allowOverlap || this.isDateRangeAvailable(date, Sch.util.Date.add(date, Sch.util.Date.MILLI, duration), dragRecords[0], targetResourceRecord)) &&
                            this.dndValidatorFn.apply(vfScope, arguments);
                },

                validatorFnScope : this,

                dragConfig : this.dragConfig || {}
            });
        }

        if (this.enableDragCreation !== false && Sch.feature.DragCreator) {
            this.dragCreator = new Sch.feature.DragCreator(Ext.applyIf({
                schedulerView    : this,
                disabled         : this.readOnly,
                validatorFn      : function (resourceRecord, startDate, endDate) {
                    return (this.allowOverlap || this.isDateRangeAvailable(startDate, endDate, null, resourceRecord)) &&
                            this.createValidatorFn.apply(vfScope, arguments);
                },
                validatorFnScope : this
            }, this.createConfig || {}));
        }
    },

    // ---------------------------------------
    // Interaction listeners

    onBeforeDragDrop : function (s, rec, e) {
        return !this.readOnly && !e.getTarget().className.match('sch-resizable-handle');
    },

    onDragDropStart : function () {
        if (this.dragCreator) {
            this.dragCreator.setDisabled(true);
        }

        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }

        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(false);
        }
    },

    onDragDropEnd : function () {
        if (this.dragCreator) {
            this.dragCreator.setDisabled(false);
        }

        if (this.tip) {
            this.tip.enable();
        }

        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
    },

    onBeforeDragCreate : function (s, resourceRecord, date, e) {
        return !this.readOnly && !e.ctrlKey;
    },

    onDragCreateStart : function () {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(false);
        }

        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }

        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(true);
    },

    onDragCreateEnd : function (s, newEventRecord) {
        // If an event editor is defined, it has to manage how/if/when the event is added to the event store
        if (!this.getEventEditor()) {
            if (this.fireEvent('beforeeventadd', this, newEventRecord) !== false) {
                this.onEventCreated(newEventRecord);
                this.eventStore.append(newEventRecord);
            }
            this.dragCreator.getProxy().hide();
        }

        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }
    },

    // Empty but provided so that you can override it to supply default record values etc.
    onEventCreated  : function (newEventRecord) {
    },

    onAfterDragCreate : function () {
        if (this.overScheduledEventClass) {
            this.setMouseOverEnabled(true);
        }

        if (this.tip) {
            this.tip.enable();
        }

        this.disableViewScroller(false);
    },

    onBeforeResize : function () {
        return !this.readOnly;
    },

    onResizeStart : function () {
        if (this.tip) {
            this.tip.hide();
            this.tip.disable();
        }

        if (this.dragCreator) {
            this.dragCreator.setDisabled(true);
        }

        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(true);
    },

    onResizeEnd : function () {
        if (this.tip) {
            this.tip.enable();
        }

        if (this.dragCreator) {
            this.dragCreator.setDisabled(false);
        }

        // While dragging to create an event, we don't want the scroller to interfere
        this.disableViewScroller(false);
    },

    // EOF Interaction listeners
    // ---------------------------------------


    setupEventListeners : function () {
        this.on({
            beforeeventdrag : this.onBeforeDragDrop,
            eventdragstart  : this.onDragDropStart,
            aftereventdrop  : this.onDragDropEnd,

            beforedragcreate : this.onBeforeDragCreate,
            dragcreatestart  : this.onDragCreateStart,
            dragcreateend    : this.onDragCreateEnd,
            afterdragcreate  : this.onAfterDragCreate,

            beforeeventresize : this.onBeforeResize,
            eventresizestart  : this.onResizeStart,
            eventresizeend    : this.onResizeEnd,

            scope : this
        });
    },

    afterHeaderResized : function () {
        var resizer = this.headerCt.resizer;

        // if we perform resize on panel with forceFit cfg set to true events will be sized incorrectly
        if (resizer && this.getMode() !== 'horizontal') {
            // if forceFit is enabled columns cannot be resized
            if (this.panel.forceFit) {
                this.setColumnWidth(resizer.origWidth);
            } else {
                var w = resizer.dragHd.getWidth();
                this.setColumnWidth(w);
            }
        }
    },

    columnRenderer : function (val, meta, record, row, col) {
        return this[this.mode].columnRenderer(val, meta, record, row, col);
    },

    onRowUpdated : function (resourceRecord) {
        var me = this,
            nodes;

        // Only relevant for horizontal mode
        if (me.getMode() === 'horizontal' && me.hasListener('eventrepaint')) {
            Ext.Array.forEach(resourceRecord.getEvents(), function(event) {
                nodes = me.getElementsFromEventRecord(event, resourceRecord, null, true);
                Ext.Array.forEach(nodes, function(node) {
                    me.fireEvent('eventrepaint', me, event, node);
                });
            });
        }
    }
});

/**

@class Sch.view.SchedulerGridView
@extends Sch.view.TimelineGridView
@mixin Sch.mixin.SchedulerView

Empty class just consuming the Sch.mixin.SchedulerView mixin.

*/
Ext.define("Sch.view.SchedulerGridView", {
    extend              : 'Sch.view.TimelineGridView',
    mixins              : ['Sch.mixin.SchedulerView', 'Sch.mixin.Localizable'],
    alias               : 'widget.schedulergridview'
}, function() {
    this.override(Sch.mixin.SchedulerView.prototype.inheritables() || {});
});


/**
@class Sch.mixin.Zoomable

A mixin for {@link Sch.mixin.TimelinePanel} class, providing "zooming" functionality to the consuming panel.

The zooming feature works by reconfiguring panel's time axis with the current zoom level values selected from the {@link #zoomLevels} array.
Zoom levels can be added and removed from the array to change the amount of available steps. Range of zooming in/out can be also
modified with {@link #maxZoomLevel} / {@link #minZoomLevel} properties.

This mixin adds additional methods to the timeline panel : {@link #setMaxZoomLevel}, {@link #setMinZoomLevel}, {@link #zoomToLevel}, {@link #zoomIn},
{@link #zoomOut}, {@link #zoomInFull}, {@link #zoomOutFull}.

* **Notice**: Zooming doesn't work properly when `forceFit` option is set to true for the panel or for filtered timeaxis.
*/

Ext.define('Sch.mixin.Zoomable', {

    /**
     * @cfg {Array} [zoomLevels=[]] Predefined map of zoom levels for each preset in the ascending order. Zoom level is basically a {@link Sch.preset.ViewPreset view preset},
     * which is based on another preset, with some values overriden.
     *
     * Each element is an {Object} with the following parameters :
     *
     * - `preset` (String)      - {@link Sch.preset.ViewPreset} to be used for this zoom level. This must be a valid preset name registered in {@link Sch.preset.Manager preset manager}.
     * - `width` (Int)          - {@link Sch.preset.ViewPreset#timeColumnWidth timeColumnWidth} time column width value from the preset
     * - `increment` (Int)      - {@link Sch.preset.ViewPresetHeaderRow#increment increment} value from the bottom header row of the preset
     * - `resolution` (Int)     - {@link Sch.preset.ViewPreset#timeResolution increment} part of the `timeResolution` object in the preset
     * - `resolutionUnit` (String) (Optional) - {@link Sch.preset.ViewPreset#timeResolution unit} part of the `timeResolution` object in the preset
     */
    zoomLevels: [
        //YEAR
        { width: 40,    increment: 1,   resolution: 1, preset: 'manyYears', resolutionUnit: 'YEAR' },
        { width: 80,    increment: 1,   resolution: 1, preset: 'manyYears', resolutionUnit: 'YEAR' },
        
        { width: 30,    increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH' },
        { width: 50,    increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH'},
        { width: 100,   increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH'},
        { width: 200,   increment: 1,   resolution: 1, preset: 'year', resolutionUnit: 'MONTH'},

        //MONTH
        { width: 100,   increment: 1,   resolution: 7, preset: 'monthAndYear', resolutionUnit: 'DAY'},
        { width: 30,    increment: 1,   resolution: 1, preset: 'weekDateAndMonth', resolutionUnit: 'DAY'},

        //WEEK
        { width: 35,    increment: 1,   resolution: 1, preset: 'weekAndMonth', resolutionUnit: 'DAY'},
        { width: 50,    increment: 1,   resolution: 1, preset: 'weekAndMonth', resolutionUnit: 'DAY'},
        { width: 20,    increment: 1,   resolution: 1, preset: 'weekAndDayLetter' },

        //DAY
        { width: 50,    increment: 1,   resolution: 1, preset: 'weekAndDay', resolutionUnit: 'HOUR'},
        { width: 100,   increment: 1,   resolution: 1, preset: 'weekAndDay', resolutionUnit: 'HOUR' },

        //HOUR
        { width: 50,    increment: 6,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
        { width: 100,   increment: 6,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
        { width: 60,    increment: 2,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },
        { width: 60,    increment: 1,   resolution: 30, preset: 'hourAndDay', resolutionUnit: 'MINUTE' },

        //MINUTE
        { width: 30,    increment: 15,  resolution: 5, preset: 'minuteAndHour' },
        { width: 60,    increment: 15,  resolution: 5, preset: 'minuteAndHour' },
        { width: 130,   increment: 15,  resolution: 5, preset: 'minuteAndHour' },
        { width: 60,    increment: 5,   resolution: 5, preset: 'minuteAndHour' },
        { width: 100,   increment: 5,   resolution: 5, preset: 'minuteAndHour' },
        { width: 50,    increment: 2,   resolution: 1, preset: 'minuteAndHour' },

        //SECOND
        { width: 30,    increment: 10,  resolution: 5,  preset: 'secondAndMinute' },
        { width: 60,    increment: 10,  resolution: 5,  preset: 'secondAndMinute' },
        { width: 130,   increment: 5,   resolution: 5,  preset: 'secondAndMinute' }
    ],

    /**
     * @cfg {Number} minZoomLevel Minimal zoom level to which {@link #zoomOut} will work.
     */
    minZoomLevel        : null,

    /**
     * @cfg {Number} maxZoomLevel Maximal zoom level to which {@link #zoomIn} will work.
     */
    maxZoomLevel        : null,


    /**
     * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make the scrolling area `visibleZoomFactor` times
     * wider than the timeline area itself. Used in {@link #zoomToSpan} and {@link #zoomToLevel} functions.
     */
    visibleZoomFactor   : 5,
    
    /**
     * @cfg {Boolean} zoomKeepsOriginalTimespan Whether the originally rendered timespan should be preserved while zooming. By default it is set to `false`,
     * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to render. When setting this option
     * to `true`, be careful not to allow to zoom a big timespan in seconds resolution for example. That will cause **a lot** of HTML content
     * to be rendered and affect performance. You can use {@link #minZoomLevel} and {@link #maxZoomLevel} config options for that.
     */
    zoomKeepsOriginalTimespan    : false,


    cachedCenterDate    : null,
    isFirstZoom         : true,
    isZooming           : false,
    

    initializeZooming: function () {
        //create instance-specific copy of zoomLevels
        this.zoomLevels         = this.zoomLevels.slice();

        this.setMinZoomLevel(this.minZoomLevel || 0);
        this.setMaxZoomLevel(this.maxZoomLevel !== null ? this.maxZoomLevel : this.zoomLevels.length - 1);

        this.on('viewchange', this.clearCenterDateCache, this);
    },


    getZoomLevelUnit : function (zoomLevel) {
        return Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
    },

    /*
     * @private
     * Returns number of milliseconds per pixel.
     * @param {Object} level Element from array of {@link #zoomLevels}.
     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings. 
     * Otherwise density will be calculated for actual tick width.
     * @return {Number} Return number of milliseconds per pixel.
     */
    getMilliSecondsPerPixelForZoomLevel : function (level, ignoreActualWidth) {
        var DATE    = Sch.util.Date;

        // trying to convert the unit + increment to a number of milliseconds
        // this number is not fixed (month can be 28, 30 or 31 day), but at least this convertion
        // will be consistent (should be no DST changes at year 1)
        return Math.round(
            (DATE.add(new Date(1, 0, 1), this.getZoomLevelUnit(level), level.increment) - new Date(1, 0, 1)) /
            // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)
            // we use it if available to return the precise index value from `getCurrentZoomLevelIndex` 
            (ignoreActualWidth ? level.width : level.actualWidth || level.width)
        );
    },


    presetToZoomLevel : function (presetName) {
        var preset              = Sch.preset.Manager.getPreset(presetName);

        return {
            preset          : presetName,
            increment       : preset.getBottomHeader().increment || 1,
            resolution      : preset.timeResolution.increment,
            resolutionUnit  : preset.timeResolution.unit,
            width           : preset.timeColumnWidth
        };
    },
    
    
    zoomLevelToPreset : function (zoomLevel) {
        var preset              = Sch.preset.Manager.getPreset(zoomLevel.preset).clone();
        
        var bottomHeader        = preset.getBottomHeader();
        
        bottomHeader.increment  = zoomLevel.increment;
        // TODO support vertical
        preset.timeColumnWidth  = zoomLevel.width;
        
        if (zoomLevel.resolutionUnit || zoomLevel.resolution) {
            preset.timeResolution   = {
                unit        : zoomLevel.resolutionUnit || preset.timeResolution.unit || bottomHeader.unit,
                increment   : zoomLevel.resolution || preset.timeResolution.increment || 1
            };
        }
        
        return preset;
    },


    calculateCurrentZoomLevel : function () {
        var zoomLevel       = this.presetToZoomLevel(this.viewPreset),
            min             = Number.MAX_VALUE,
            viewModel       = this.timeAxisViewModel,
            actualWidth     = viewModel.timeColumnWidth;

        zoomLevel.width     = actualWidth;
        zoomLevel.increment = viewModel.getBottomHeader().increment || 1;

        // when calculating current zoom level we should use tick width from defined zoomLevels
        // otherwise levels might be skipped
        for (var i = 0, l = this.zoomLevels.length; i < l; i++) {
            var curentLevel = this.zoomLevels[i];

            // search for a zoom level having the same preset...
            if (curentLevel.preset !== zoomLevel.preset) continue;

            // and the most close column width to the actual one
            var delta = Math.abs(curentLevel.width - actualWidth);
            if (delta < min) {
                min                     = delta;
                zoomLevel.actualWidth   = curentLevel.actualWidth;
                zoomLevel.width         = curentLevel.width;
            }
        }

        return zoomLevel;
    },


    getCurrentZoomLevelIndex : function () {
        var currentZoomLevel        = this.calculateCurrentZoomLevel();
        var currentFactor           = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);

        var zoomLevels              = this.zoomLevels;

        for (var i = 0; i < zoomLevels.length; i++) {
            var zoomLevelFactor     = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[ i ]);

            if (zoomLevelFactor == currentFactor) return i;

            // current zoom level is outside of pre-defined zoom levels
            if (i === 0 && currentFactor > zoomLevelFactor) return -0.5;
            if (i == zoomLevels.length - 1 && currentFactor < zoomLevelFactor) return zoomLevels.length - 1 + 0.5;

            var nextLevelFactor     = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[ i + 1 ]);
            
            if (zoomLevelFactor > currentFactor && currentFactor > nextLevelFactor) return i + 0.5;
        }

        throw "Can't find current zoom level index";
    },


    /**
    * Sets the {@link #maxZoomLevel} value.
    * @param {Number} level The level to limit zooming in to.
    */
    setMaxZoomLevel: function (level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }

        this.maxZoomLevel = level;
    },

    /**
    * Sets the {@link #minZoomLevel} value.
    * @param {Number} level The level to limit zooming out to.
    */
    setMinZoomLevel: function (level) {
        if (level < 0 || level >= this.zoomLevels.length) {
            throw new Error("Invalid range for `setMinZoomLevel`");
        }

        this.minZoomLevel = level;
    },


    // when zooming out, the precision for the center date becomes not so good (1px starts to contains too big time interval)
    // because of that zooming will be "floating"
    // to prevent that we cache the center date
    // cache will be cleared after any user scroll operation
    /** @ignore */
    getViewportCenterDateCached : function () {
        if (this.cachedCenterDate) return this.cachedCenterDate;

        return this.cachedCenterDate = this.getViewportCenterDate();
    },


    clearCenterDateCache : function () {
        this.cachedCenterDate = null;
    },


    /**
     * Allows zooming to certain level of {@link #zoomLevels} array. Automatically limits zooming between {@link #maxZoomLevel} 
     * and {@link #minZoomLevel}. Can also set time axis timespan to the supplied start and end dates.
     *
     * @param {Number} level Level to zoom to.
     * @param {Object} span The time frame. Used to set time axis timespan to the supplied start and end dates. If provided, the view
     * will be centered in this time interval
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     *
     * @param {Object} [options] Object, containing options for this method
     * @param {Number} options.customWidth Lowest tick width. Might be increased automatically
     * @param {Date} options.scrollTo Date that should be scrolled to
     * @return {Number} level Current zoom level or null if it hasn't changed.
     */
    zoomToLevel: function (level, span, options) {
        level                       = Ext.Number.constrain(level, this.minZoomLevel, this.maxZoomLevel);
        options                     = options || {};

        var currentZoomLevel        = this.calculateCurrentZoomLevel();
        var currentFactor           = this.getMilliSecondsPerPixelForZoomLevel(currentZoomLevel);

        var nextZoomLevel           = this.zoomLevels[ level ];
        var nextFactor              = this.getMilliSecondsPerPixelForZoomLevel(nextZoomLevel);

        if (currentFactor == nextFactor && !span) {
            // already at requested zoom level
            return null;
        }

        var me                      = this;
        var view                    = this.getSchedulingView();
        var viewEl                  = view.getOuterEl();
        var scrollSource            = view.getScrollEventSource();


        var isVertical              = this.mode == 'vertical';

        var centerDate              = span ? new Date((span.start.getTime() + span.end.getTime()) / 2) : this.getViewportCenterDateCached();

        var panelSize               = isVertical ? viewEl.getHeight() : viewEl.getWidth();

        var presetCopy              = Sch.preset.Manager.getPreset(nextZoomLevel.preset).clone();
        var bottomHeader            = presetCopy.getBottomHeader();
        
        var hasSpanProvided         = Boolean(span);

        span                        = this.calculateOptimalDateRange(centerDate, panelSize, nextZoomLevel, span);
        
        presetCopy[ isVertical ? 'timeRowHeight' : 'timeColumnWidth' ] = options.customWidth || nextZoomLevel.width;

        bottomHeader.increment      = nextZoomLevel.increment;

        this.isZooming              = true;

        this.viewPreset             = nextZoomLevel.preset;
        
        var timeAxis                = this.timeAxis;
            
        presetCopy.increment        = nextZoomLevel.increment;
        presetCopy.timeResolution.unit   = Sch.util.Date.getUnitByName(nextZoomLevel.resolutionUnit || presetCopy.timeResolution.unit || bottomHeader.unit);
        presetCopy.timeResolution.increment  = nextZoomLevel.resolution;

        this.setViewPreset(presetCopy, span.start || this.getStart(), span.end || this.getEnd(), false, true);
        
        // after switching the view preset the `width` config of the zoom level may change, because of adjustments
        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method
        // will return the exact level index after zooming
        nextZoomLevel.actualWidth   = this.timeAxisViewModel.getTickWidth();
        
        // re-calculate the center date after reconfiguring the timeaxis, 
        // because the actual start/end date may change because of time axis "autoAdjust" property
        if (hasSpanProvided) centerDate = options.centerDate || new Date((timeAxis.getStart().getTime() + timeAxis.getEnd().getTime()) / 2);

        var x = null, y = null;

        if (isVertical) {
            y = view.getYFromDate(centerDate, true) - panelSize / 2;

            me.cachedCenterDate = centerDate;
            
            // there's a missync between header scroll and view scroll which can corrupt view center date
            view.getScrollable().scrollTo(null, y);
            view.headerCt.getScrollable().scrollTo(null, y);
        } else {
            x = view.getXFromDate(centerDate, true) - panelSize / 2;
            me.cachedCenterDate = centerDate;
            
            // there's a missync between header scroll and view scroll which can corrupt view center date
            view.getScrollable().scrollTo(x);
            view.headerCt.getScrollable().scrollTo(x);
        }

        me.isZooming              = false;
        
        me.fireEvent('zoomchange', me, level, x, y);

        /**
         * @event zoomchange
         *
         * Fires after zoom level has been changed
         *
         * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline object
         * @param {Number} level The index of the new zoom level
         */


        return level;
    },

    /*
     * Alias for {@link #zoomToLevel}
     */
    setZoomLevel : function() {
        this.zoomToLevel.apply(this, arguments);
    },

    /**
     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.
     * 
     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole time axis
     * will be extended in the same way as {@link #zoomToLevel} method does, to allow scrolling for user. 
     *
     * @param {Object} span The time frame.
     * @param {Date} span.start The time frame start.
     * @param {Date} span.end The time frame end.
     *
     * @return {Number} level Current zoom level or null if it hasn't changed.
     */
    zoomToSpan : function (span, config) {
        if (span.start && span.end && span.start < span.end) {
            config = config || {};
            
            if (config.leftMargin || config.rightMargin) {
                config.adjustStart = 0;
                config.adjustEnd = 0;
            }
            
            Ext.applyIf(config, {
                leftMargin  : 0,
                rightMargin : 0
            });
            
            var start       = span.start,
                end         = span.end,
                // this config enables old zoomToSpan behavior which we want o use for zoomToFit in Gantt 
                needToAdjust  = config.adjustStart >= 0 && config.adjustEnd >=0;
                
            if (needToAdjust) {
                start       = Sch.util.Date.add(start, this.timeAxis.mainUnit, - config.adjustStart);
                end         = Sch.util.Date.add(end, this.timeAxis.mainUnit, config.adjustEnd);    
            }

            // get scheduling view width
            var availableWidth  = this.getSchedulingView().getTimeAxisViewModel().getAvailableWidth();

            // if potential width of col is less than col width provided by zoom level
            //   - we'll zoom out panel until col width fit into width from zoom level
            // and if width of column is more than width from zoom level
            //   - we'll zoom in until col width fit won't fit into width from zoom level

            var currLevel       = Math.floor(this.getCurrentZoomLevelIndex());

            // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level
            if (currLevel == -1) currLevel = 0;

            var zoomLevels      = this.zoomLevels;
            
            var diffMS          = end - start,
                msPerPixel      = this.getMilliSecondsPerPixelForZoomLevel(zoomLevels[ currLevel ], true),
                // increment to get next zoom level:
                // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,
                // so that more content will "fit" into 1 px
                //
                // +1 mean that given timespan will already fit into available width in the current zoom level, but,
                // perhaps if we'll zoom in a bit more, the fitting will be better 
                inc             = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableWidth ? -1 : 1,
                candidateLevel  = currLevel + inc;

            var zoomLevel, levelToZoom = null;

            // loop over zoom levels
            while (candidateLevel >= 0 && candidateLevel <= zoomLevels.length - 1) {

                // get zoom level
                zoomLevel   = zoomLevels[ candidateLevel ];

//                // get its preset copy
//                preset      = this.zoomLevelToPreset(zoomLevel);
//                
//                // apply zoom level params to timeAxis
//                timeAxis.consumeViewPreset(preset);
                
                msPerPixel = this.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);
                var spanWidth   = diffMS / msPerPixel + config.leftMargin + config.rightMargin;
                
                // if zooming out
                if (inc == -1) {
                    // if columns fit into available space, then all is fine, we've found appropriate zoom level
                    if (spanWidth <= availableWidth) {
                        levelToZoom     = candidateLevel;
                        // stop searching
                        break;
                    }
                // if zooming in
                } else {
                    // if columns still fits into available space, we need to remember the candidate zoom level as a potential
                    // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit
                    // into available view
                    if (spanWidth <= availableWidth) {
                        // if it's not currently active level
                        if (currLevel !== candidateLevel - inc) {
                            // remember this level as applicable
                            levelToZoom     = candidateLevel;
                        }
                    } else {
                        // Sanity check to find the following case:
                        // If we're already zoomed in at the appropriate level, but the current zoomLevel is "too small" to fit and had to be expanded,
                        // there is an edge case where we should actually just stop and use the currently selected zoomLevel
                        break;
                    }
                }

                candidateLevel += inc;
            }

            // If we didn't find a large/small enough zoom level, use the lowest/highest level
            levelToZoom     = levelToZoom !== null ? levelToZoom : candidateLevel - inc;
            
            zoomLevel       = zoomLevels[ levelToZoom ];
            
            var unitToZoom  = Sch.preset.Manager.getPreset(zoomLevel.preset).getBottomHeader().unit;
            
            if (config.leftMargin || config.rightMargin) {
                // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly
                start = new Date(start.getTime() - msPerPixel * config.leftMargin);
                end = new Date(end.getTime() + msPerPixel * config.rightMargin);
            }
            
            var columnCount = Sch.util.Date.getDurationInUnit(start, end, unitToZoom, true) / zoomLevel.increment;

            if (columnCount === 0) {
                return;
            }
            
            var customWidth = Math.floor(availableWidth / columnCount);
            
            var centerDate  = new Date((start.getTime() + end.getTime()) / 2);
            
            var range;
            
            if (needToAdjust) {
                range = {
                    start   : start,
                    end     : end
                };
            } else {
                range = this.calculateOptimalDateRange(centerDate, availableWidth, zoomLevel);
            }
            
            return this.zoomToLevel(levelToZoom, 
                range,
                { 
                    customWidth : customWidth, 
                    centerDate  : centerDate 
                }
            );
        }

        return null;
    },

    /**
    * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom in by this value.
    * Otherwise a value of `1` will be used.
    *
    * @param {Number} levels (optional) amount of levels to zoom in
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomIn: function (levels) {
        //if called without parameters or with 0, zoomIn by 1 level
        levels          = levels || 1;

        var currentZoomLevelIndex       = this.getCurrentZoomLevelIndex();

        if (currentZoomLevelIndex >= this.zoomLevels.length - 1) return null;

        return this.zoomToLevel(Math.floor(currentZoomLevelIndex) + levels);
    },

    /**
    * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view will zoom out by this value.
    * Otherwise a value of `1` will be used.
    *
    * @param {Number} levels (optional) amount of levels to zoom out
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOut: function(levels){
        //if called without parameters or with 0, zoomIn by 1 level
        levels          = levels || 1;

        var currentZoomLevelIndex       = this.getCurrentZoomLevelIndex();

        if (currentZoomLevelIndex <= 0) return null;

        return this.zoomToLevel(Math.ceil(currentZoomLevelIndex) - levels);
    },

    /**
    * Zooms in the timeline to the {@link #maxZoomLevel} according to the array of zoom levels.
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomInFull: function () {
        return this.zoomToLevel(this.maxZoomLevel);
    },

    /**
    * Zooms out the timeline to the {@link #minZoomLevel} according to the array of zoom levels.
    *
    * @return {Number} currentLevel New zoom level of the panel or null if level hasn't changed.
    */
    zoomOutFull: function () {
        return this.zoomToLevel(this.minZoomLevel);
    },


    /*
    * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,
    * as rendering too many columns takes noticeable amount of time so their number is limited.
    */
    calculateOptimalDateRange: function (centerDate, panelSize, zoomLevel, userProvidedSpan) {
        // this line allows us to always use the `calculateOptimalDateRange` method when calculating date range for zooming
        // (even in case when user has provided own interval)
        // other methods may override/hook into `calculateOptimalDateRange` to insert own processing
        // (inifinte scrolling feature does)
        if (userProvidedSpan) return userProvidedSpan;
        
        var timeAxis            = this.timeAxis;
        
        if (this.zoomKeepsOriginalTimespan) {
            return {
                start           : timeAxis.getStart(),
                end             : timeAxis.getEnd()
            };
        }
        
        var schDate             = Sch.util.Date;


        var unit                = this.getZoomLevelUnit(zoomLevel);

        var difference          = Math.ceil(panelSize / zoomLevel.width * zoomLevel.increment * this.visibleZoomFactor / 2);

        var startDate           = schDate.add(centerDate, unit, -difference);
        var endDate             = schDate.add(centerDate, unit, difference);

        return {
            start   : timeAxis.floorDate(startDate, false, unit, zoomLevel.increment),
            end     : timeAxis.ceilDate(endDate, false, unit, zoomLevel.increment)
        };
    }
});

/**

@class Sch.mixin.AbstractTimelinePanel
@private

A base mixin giving the consuming panel "time line" functionality.
This means that the panel will be capable to display a list of "events", along a {@link Sch.data.TimeAxis time axis}.

This class should not be used directly.

*/

Ext.define('Sch.mixin.AbstractTimelinePanel', {
    requires: [
        'Sch.data.TimeAxis',
        'Sch.view.model.TimeAxis',
        'Sch.feature.ColumnLines',
        'Sch.preset.Manager'
    ],

    mixins: [
        'Sch.mixin.Zoomable'
    ],
    
    /**
     * @cfg {String} orientation An initial orientation of the view - can be either `horizontal` or `vertical`. Default value is `horizontal`.
     * Options: ['horizontal', 'vertical']
     * @deprecated Use {@link #mode} instead
     */
    orientation             : 'horizontal',
    
    /**
     * @cfg {String} mode An initial mode of the view - can be either `calendar`, `horizontal` or `vertical`. Default value is `horizontal`.
     * Please note, that view preset for vertical and horizontal mode is defined by {@link #viewPreset} and view preset for calendar is 
     * defined by {@link #calendarViewPreset}
     * 
     * 
     * Options: ['calendar', 'horizontal', 'vertical']
     */

    /**
     * @cfg {Number} weekStartDay A valid JS date index between 0-6. (0: Sunday, 1: Monday etc.).
     */
    weekStartDay            : 1,

    /**
     * @cfg {Boolean} snapToIncrement true to snap to resolution increment while interacting with scheduled events.
     */
    snapToIncrement         : false,

    /**
     * @cfg {Boolean} readOnly true to disable editing.
     */
    readOnly                : false,

    /**
     * @cfg {Boolean} forceFit Set to true to force the time columns to fit to the available horizontal space.
     */
    forceFit                : false,

    /**
     * @cfg {String} eventResizeHandles Defines which resize handles to use for resizing events. Possible values: 'none', 'start', 'end', 'both'. Defaults to 'both'
     */
    eventResizeHandles      : 'both',

    /**
     * @cfg {Number} rowHeight The row height (used in horizontal mode only)
     */

    /**
     * @cfg {Sch.data.TimeAxis} timeAxis The backing store providing the input date data for the timeline panel.
     */
    timeAxis                : null,

    /**
     * @cfg {Boolean} autoAdjustTimeAxis The value for the {@link Sch.data.TimeAxis#autoAdjust} config option, which will be used
     * when creating the time axis instance. You can set this option to `false` to make the timeline panel start and end on the exact provided
     * {@link #startDate}/{@link #endDate} w/o adjusting them.
     */
    autoAdjustTimeAxis      : true,

    /**
     * @private
     * @cfg {Sch.view.model.TimeAxis/Object} timeAxisViewModel The backing view model for the visual representation of the time axis.
     * Either a real instance or a simple config object.
     */
    timeAxisViewModel       : null,

    /**
     * @cfg {Object} validatorFnScope
     * The scope used for the different validator functions.
     */

    /**
     * @cfg {Sch.crud.AbstractManager} crudManager The CRUD manager holding all the project stores.
     */
    crudManager : null,

    /**
     * @cfg {String} viewPreset
     * @property {String} viewPreset
     * A key used to lookup a predefined {@link Sch.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'), managed by {@link Sch.preset.Manager}. See {@link Sch.preset.Manager} for more information.
     * 
     * 
     * Options: ['secondAndMinute', 'minuteAndHour', 'hourAndDay', 'dayAndWeek', 'weekAndDay', 'weekAndMonth', 'monthAndYear', 'year', 'manyYears', 'weekAndDayLetter', 'weekDateAndMonth']
     */
    viewPreset              : 'weekAndDay',
    
    /**
     * @cfg {String} calendarViewPreset
     * @property {String} calendarViewPreset
     * A key used to lookup a predefined {@link Sch.preset.ViewPreset}, managed by {@link Sch.preset.Manager}. See {@link Sch.preset.Manager} for more information.
     * Default view preset for scheduler in calendar mode
     * 
     * 
     * Options: ['day', 'week']
     */
    calendarViewPreset      : 'week',

    /**
     * @cfg {Boolean} trackHeaderOver `true` to highlight each header cell when the mouse is moved over it.
     */
    trackHeaderOver         : true,

    /**
     * @cfg {Date} startDate The start date of the timeline. If omitted, and a TimeAxis has been set, the start date of the provided {@link Sch.data.TimeAxis} will be used.
     * If no TimeAxis has been configured, it'll use the start/end dates of the loaded event dataset. If no date information exists in the event data
     * set, it defaults to the current date and time.
     */
    startDate               : null,

    /**
     * @cfg {Date} endDate The end date of the timeline. If omitted, it will be calculated based on the {@link #startDate} setting and
     * the 'defaultSpan' property of the current {@link #viewPreset}.
     */
    endDate                 : null,
    
    /**
     * @cfg {Number} startTime Start time for calendar mode, used only with day/week presets.
     */
    startTime               : 0,
    
    /**
     * @cfg {Number} endTime End time for calendar mode, used only with day/week presets.
     */
    endTime                 : 24,

    columnLines             : true,

    /**
     * Returns dates that will constrain resize and drag operations. The method will be called with the Resource, and
     * for operations on existing events - the event. For drag create operation, the mousedown date will be passed as the second parameter
     * @return {Object} Constaining object
     * @return {Date} return.start Start date
     * @return {Date} return.end End date
     */
    getDateConstraints		: Ext.emptyFn,
    
    /**
     * @cfg {Boolean} snapRelativeToEventStartDate Affects drag drop and resizing of events when {@link #snapToIncrement} is enabled. If set to `true`, dates will be snapped relative to event start.
     * e.g. for a zoom level with timeResolution = { unit: "s", increment: "20" }, an event that starts at 10:00:03 and is dragged would snap its start date to 10:00:23, 10:00:43 etc.
     * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start) - 10:00:03, 10:00:20, 10:00:40 etc.
     */
    snapRelativeToEventStartDate    : false,
    
    trackMouseOver          : false,

    // If user supplied a 'rowHeight' config or a panel subclass with such a value - skip reading this setting
    // from the viewpreset
    readRowHeightFromPreset : true,

    /**
     * @cfg {Number} eventBorderWidth
     * The width of the border of your event, needed to calculate the correct start/end positions
     */
    eventBorderWidth        : 1,

    /**
    * Returns the orientation of this panel, "horizontal" or "vertical"
    * @return {String}
    * @deprecated
    */
    getOrientation  : function () {
        return this.getMode.apply(this, arguments);
    },
    
    /**
    * Returns the mode of this panel, "horizontal", "vertical" or "calendar"
    * @return {String}
    */
    getMode: function () {
        return this.mode;
    },


    isHorizontal : function() {
        return this.getMode() === 'horizontal';
    },


    isVertical : function() {
        return !this.isHorizontal();
    },

    /**
     * @event beforeviewchange
     * Fires before the current view changes to a new view type or a new time span. Return false to abort this action.
     * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline panel instance
     * @param {Object} preset The new preset
     */

    /**
     * @event viewchange
     * Fires after current view preset or time span has changed
     * @param {Sch.mixin.TimelinePanel} timelinePanel The timeline panel instance
     */


    cellBorderWidth         : 1,
    cellTopBorderWidth      : 1,        // 0 since Ext JS 4.2.1
    cellBottomBorderWidth   : 1,

    renderers               : null,


    // Must be called during initialization by consuming class
    _initializeTimelinePanel : function() {
        // this is an entry point to this mixin, so we should wrap 'mode' here
        this.mode = this.mode || this.orientation || 'horizontal';

        if (this.mode === 'calendar') {
            this.oldViewPreset  = this.viewPreset;
            this.viewPreset     = this.calendarViewPreset;    
        }
        
        var preset      = this.viewPreset && Sch.preset.Manager.getPreset(this.viewPreset);

        if (!preset) {
            throw 'You must define a valid view preset object. See Sch.preset.Manager class for reference';
        }

        this.initializeZooming();

        this.renderers                  = [];

        // Setting a rowHeight config on the panel should override any rowHeight value in the view presets
        if (this.readRowHeightFromPreset) {
            this.readRowHeightFromPreset    = !this.rowHeight;
        }

        if (!this.timeAxis) {
            this.timeAxis = new Sch.data.TimeAxis({ 
                autoAdjust  : this.autoAdjustTimeAxis,
                mode        : this.mode === 'calendar' ? 'calendar' : 'plain'
            });
        }

        if (!this.timeAxisViewModel || !(this.timeAxisViewModel instanceof Sch.view.model.TimeAxis)) {
            var config                  = Ext.apply({
                mode            : this.mode,
                snapToIncrement : this.snapToIncrement,
                forceFit        : this.forceFit,
                timeAxis        : this.timeAxis,
                eventStore      : this.getEventStore(),
                viewPreset      : this.viewPreset
            }, this.timeAxisViewModel || {});

            this.timeAxisViewModel      = new Sch.view.model.TimeAxis(config);
        }
        
        this.timeAxisViewModel.on('update', this.onTimeAxisViewModelUpdate, this);
        
        this.timeAxisViewModel.refCount++;

        this.on('destroy', this.onPanelDestroyed, this);
        
        var orientationClasses;
        switch (this.mode) {
            case 'horizontal'   : orientationClasses = ['sch-horizontal']; break;
            case 'vertical'     : orientationClasses = ['sch-vertical', 'sch-vertical-resource']; break;
            case 'calendar'     : orientationClasses = ['sch-vertical', 'sch-calendar']; break;
        }
        
        this.addCls([].concat.apply(['sch-timelinepanel'], orientationClasses));
    },

    onTimeAxisViewModelUpdate : function() {
        var view = this.getSchedulingView();

        if (view && view.viewReady) {
            view.refreshKeepingScroll();

            this.fireEvent('viewchange', this);
        }
    },

    onPanelDestroyed : function() {
        var timeAxisViewModel   = this.timeAxisViewModel;

        timeAxisViewModel.un('update', this.onTimeAxisViewModelUpdate, this);
        timeAxisViewModel.refCount--;

        if (timeAxisViewModel.refCount <= 0) {
            timeAxisViewModel.destroy();
        }
    },

    /**
    * @abstract
    *
    * @return {Sch.mixin.AbstractSchedulerView} A view consuming the {@link Sch.mixin.AbstractSchedulerView} mixin
    */
    getSchedulingView: function () {
        throw 'Abstract method call';
    },

    /**
    * The {@link #readOnly} accessor. Use it to switch the `readonly` state.
    */
    setReadOnly: function (readOnly) {
        this.getSchedulingView().setReadOnly(readOnly);
    },

    /**
    * Returns true if the panel is currently read only.
    * @return {Boolean} readOnly
    */
    isReadOnly: function () {
        return this.getSchedulingView().isReadOnly();
    },

    /**
     * Alias for {@link setViewPreset}
     */
    switchViewPreset: function () {
        this.setViewPreset.apply(this, arguments);
    },

    /**
     * Sets the current view preset. See the {@link Sch.preset.Manager} class for details.
     * Calling it will first fire a {@link Sch.panel.SchedulerGrid#beforeviewchange SchedulerGrid} /
     * {@link Sch.panel.SchedulerTree#beforeviewchange SchedulerTree} beforeviewchange event,
     * followed by a {@link Sch.panel.SchedulerGrid#viewchange SchedulerGrid} /
     * {@link Sch.panel.SchedulerTree#viewchange SchedulerTree} viewchange event.
     * Returning `false` from any 'beforeviewchange' listener will cancel the operation.
     *
     * @param {String} preset The id of the new preset (see {@link Sch.preset.Manager} for details)
     * @param {Date} [startDate] A new start date for the time axis
     * @param {Date} [endDate] A new end date for the time axis
     */
    setViewPreset : function(preset, startDate, endDate, initial, noScroll) {
        var timeAxis        = this.timeAxis;

        if (this.fireEvent('beforeviewchange', this, preset, startDate, endDate) !== false) {

            var isHorizontal        = this.getMode() === 'horizontal';

            if (Ext.isString(preset)) {
                this.viewPreset     = preset;
                preset              = Sch.preset.Manager.getPreset(preset);
            }

            if (!preset) {
                throw 'View preset not found';
            }

            // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it
            if (!(initial && timeAxis.isConfigured)) {
                var timeAxisCfg     = {
                    weekStartDay    : this.weekStartDay,
                    startTime       : this.startTime,
                    endTime         : this.endTime
                };

                if (initial) {
                    if (timeAxis.getCount() === 0 || startDate) {
                        timeAxisCfg.start = startDate || new Date();
                    }
                } else {
                    timeAxisCfg.start   = startDate || timeAxis.getStart();
                }

                timeAxisCfg.end     = endDate;

                timeAxis.consumeViewPreset(preset);
                timeAxis.reconfigure(timeAxisCfg, true);

                this.timeAxisViewModel.reconfigure({
                    headerConfig        : preset.headerConfig,
                    columnLinesFor      : preset.columnLinesFor || 'middle',
                    rowHeightHorizontal : this.readRowHeightFromPreset ? preset.rowHeight : (this.rowHeight || this.timeAxisViewModel.getViewRowHeight()),
                    tickWidth           : isHorizontal ? preset.timeColumnWidth : preset.timeRowHeight || preset.timeColumnWidth || 60,
                    timeColumnWidth     : preset.timeColumnWidth,

                    // timeColumnWidth is also used for row height in vertical mode
                    rowHeightVertical   : preset.timeRowHeight || preset.timeColumnWidth || 60,
                    timeAxisColumnWidth : preset.timeAxisColumnWidth,
                    resourceColumnWidth : this.resourceColumnWidth || preset.resourceColumnWidth || 100
                });
            }

            var view = this.getSchedulingView();

            view.setDisplayDateFormat(preset.displayDateFormat);

            if (this.getMode() === 'vertical') {
                view.setColumnWidth(this.resourceColumnWidth || preset.resourceColumnWidth || 100, true);
            }

            if (!noScroll) {
                if (isHorizontal) {
                    view.scrollHorizontallyTo(0);
                } else {
                    view.scrollVerticallyTo(0);
                }
            }
        }
    },

    /**
     * Method to get the current view preset of the timeline panel.
     * @return {String} The name of the currently active view preset
     */
    getViewPreset : function() {
        return this.viewPreset;
    },

    /**
     * Method to get the current start date of the scheduler
     * @return {Date} The start date
     */
    getStart: function () {
        return this.getStartDate();
    },

    /**
     * Method to get the current start date of the scheduler
     * @return {Date} The start date
     */
    getStartDate: function () {
        return this.timeAxis.getStart();
    },


    /**
     * Method to get the current end date of the scheduler
     * @return {Date} The end date
     */
    getEnd: function () {
        return this.getEndDate();
    },

    /**
     * Method to get the current end date of the scheduler
     * @return {Date} The end date
     */
    getEndDate: function () {
        return this.timeAxis.getEnd();
    },

    /**
     * Updates the widths of all the time columns to the supplied value. Only applicable when {@link #forceFit} is set to false.
     * @param {Number} width The new time column width
     */
    setTimeColumnWidth: function (width, preventRefresh) {
        this.timeAxisViewModel.setTickWidth(width, preventRefresh);
    },

    /**
     * @return {Number} width The time column width
     */
    getTimeColumnWidth: function () {
        return this.timeAxisViewModel.getTickWidth();
    },

    getRowHeight: function () {
        return this.timeAxisViewModel.getViewRowHeight();
    },

    /**
    * Moves the time axis forward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump forward
    */
    shiftNext: function (amount) {
        this.suspendLayouts && this.suspendLayouts();

        this.timeAxis.shiftNext(amount);

        this.suspendLayouts && this.resumeLayouts(true);
    },

    /**
    * Moves the time axis backward in time in units specified by the view preset 'shiftUnit', and by the amount specified by the parameter or by the shiftIncrement config of the current view preset.
    * @param {Number} amount (optional) The number of units to jump backward
    */
    shiftPrevious: function (amount) {
        this.suspendLayouts && this.suspendLayouts();

        this.timeAxis.shiftPrevious(amount);

        this.suspendLayouts && this.resumeLayouts(true);
    },

    /**
    * Convenience method to go to current date.
    */
    goToNow: function () {
        this.setTimeSpan(new Date());
    },

    /**
    * Changes the time axis timespan to the supplied start and end dates.
    * @param {Date} start The new start date
    * @param {Date} end (Optional) The new end date. If not supplied, the {@link Sch.preset.ViewPreset#defaultSpan} property of the current view preset will be used to calculate the new end date.
    */
    setTimeSpan: function (start, end) {
        if (this.timeAxis) {
            this.timeAxis.setTimeSpan(start, end);
        }
    },

    /**
    * Changes the time axis start date to the supplied date.
    * @param {Date} amount The new start date
    */
    setStart: function (date) {
        this.setTimeSpan(date);
    },

    /**
    * Changes the time end start date to the supplied date.
    * @param {Date} amount The new end date
    */
    setEnd: function (date) {
        this.setTimeSpan(null, date);
    },

    /**
    * Returns the {@link Sch.data.TimeAxis} instance in use.
    * @return {Sch.data.TimeAxis}
    */
    getTimeAxis: function () {
        return this.timeAxis;
    },


    /**
    * Scrolls the time line to the specified `date`.
    * @param {Date} date The date to which to scroll the time line
    */
    scrollToDate: function (date, animate) {
        var view = this.getSchedulingView();
        var coordinate = view.getCoordinateFromDate(date, true);

        this.scrollToCoordinate(coordinate, date, animate, false);
    },

    /**
    * Scrolls the time line so that specified `date` is in the center of the view.
    * @param {Date} date The date to which to scroll the time line
    * @param {Boolean} animate (optional) Whether or not scroll should be animated 
    */
    scrollToDateCentered: function (date, animate) {
        var view = this.getSchedulingView();
        var delta = 0;
        
        if (this.mode === 'horizontal') {
            delta = view.getBox().width / 2;
        } else {
            delta = view.getBox().height / 2;
        }

        var coordinate = Math.round(view.getCoordinateFromDate(date, true) - delta);
        this.scrollToCoordinate(coordinate, date, animate, true);
    },

    //private
    scrollToCoordinate: function (coordinate, date, animate, centered) {
        var view    = this.getSchedulingView();
        var me      = this;
        // Not currently have this date in a timeaxis
        if (coordinate < 0) {
            if (this.infiniteScroll) {
                // for infinite scroll we have a special formula to calculate adjustment borders
                // shiftToDate() will perform adjustment and then recall scrollToDate() again
                view.shiftToDate(date, centered);

            } else {
                // adjust the timeaxis first
                var halfVisibleSpan = (this.timeAxis.getEnd() - this.timeAxis.getStart()) / 2;

                this.setTimeSpan(new Date(date.getTime() - halfVisibleSpan), new Date(date.getTime() + halfVisibleSpan));

                if (centered) {
                    me.scrollToDateCentered(date, animate);
                } else {
                    me.scrollToDate(date, animate);
                }
            }

            return;
        }

        if (this.mode === 'horizontal') {
            view.scrollHorizontallyTo(coordinate, animate);
        } else {
            view.scrollVerticallyTo(coordinate, animate);
        }
        view.fireEvent('scroll', this, coordinate);
    },

    /**
     * Returns the center date of the currently visible timespan of scheduler.
     *
     * @return {Date} date Center date for the viewport.
     */
    getViewportCenterDate: function(){
        return this.getSchedulingView().getViewportCenterDate();
    },

    addCls : function() {
        throw 'Abstract method call';
    },

    removeCls : function() {
        throw 'Abstract method call';
    },

    registerRenderer : function(fn, scope) {
        this.renderers.push({
            fn      : fn,
            scope   : scope
        });
    },

    deregisterRenderer : function(fn, scope) {
        Ext.each(this.renderers, function(rend, i) {
            if (fn === rend) {
                Ext.Array.removeAt(this.renderers, i);
                return false;
            }
        });
    }

    /**
     * Returns the event store instance
     * @method getEventStore
     * @abstract
     * @return {Ext.data.AbstractStore}
     */
});

/**

 @class Sch.mixin.TimelinePanel
 @extends Sch.mixin.AbstractTimelinePanel
 A base mixing for {@link Ext.panel.Panel} classes, giving to the consuming panel the "time line" functionality.
 This means that the panel will be capabale to display a list of "events", ordered on the {@link Sch.data.TimeAxis time axis}.

 Generally, should not be used directly, if you need to subclass the scheduler panel, subclass the {@link Sch.panel.SchedulerGrid} or {@link Sch.panel.SchedulerTree}
 instead.

*/

if (!Ext.ClassManager.get("Sch.mixin.TimelinePanel")) {

Ext.define('Sch.mixin.TimelinePanel', {
    extend : 'Sch.mixin.AbstractTimelinePanel',

    requires : [
        'Sch.column.timeAxis.Horizontal',
        'Sch.preset.Manager',
        'Sch.patches.NodeCache',
        'Sch.patches.BufferedRenderer',
        'Sch.patches.RowSynchronizer',
        'Sch.patches.Chrome'
    ],

    mixins : [
        'Sch.mixin.Zoomable'
    ],

    /**
    * @cfg {Object} lockedGridConfig A custom config object used to initialize the left (locked) grid panel.
    */

    /**
    * @cfg {Object} schedulerConfig A custom config object used to initialize the right (schedule) grid panel.
    */

    /**
    * @cfg {String/Ext.Template} tooltipTpl
    * Template used to show a tooltip over a scheduled item, null by default (meaning no tooltip). The tooltip will be populated with the data in
    * record corresponding to the hovered element. See also {@link #tipCfg} and to provide your own custom data object for this
    * template, please see {@link Sch.mixin.TimelineView#getDataForTooltipTpl}.
    */

    /**
     * @cfg {Sch.mixin.TimelinePanel/String} partnerTimelinePanel A reference to another timeline panel (or a component id) that this panel should be 'partner' with.
     * If this config is supplied, this panel will:
     *
     * - Share and use the {@link Sch.data.TimeAxis} timeAxis from the partner panel.
     * - Synchronize the width of the two locked grid panels (after a drag of the splitter).
     * - Synchronize horizontal scrolling between two panels.
     */

    /**
     * @cfg {Number} bufferCoef
     *
     * This config defines the width of the left and right invisible parts of the timespan when {@link #infiniteScroll} set to `true`.
     *
     * It should be provided as a coefficient, which will be multiplied by the width of the scheduling area.
     *
     * For example, if `bufferCoef` is `5` and the panel view width is 200px then the timespan will be calculated to
     * have approximately 1000px (`5 * 200`) to the left and 1000px to the right of the visible area, resulting
     * in 2200px of totally rendered content.
     *
     * The timespan gets recalculated when the scroll position reaches the limits defined by the {@link #bufferThreshold} option.
     *
     */
    bufferCoef                  : 5,

    /**
     * @cfg {Number} bufferThreshold
     *
     * This config defines the horizontal scroll limit, which, when exceeded will cause a timespan shift.
     * The limit is calculated as the `panelWidth * {@link #bufferCoef} * bufferThreshold`. During scrolling, if the left or right side
     * has less than that of the rendered content - a shift is triggered.
     *
     * For example if `bufferCoef` is `5` and the panel view width is 200px and `bufferThreshold` is 0.2, then the timespan
     * will be shifted when the left or right side has less than 200px (5 * 200 * 0.2) of content.
     */
    bufferThreshold             : 0.2,

    /**
     * @cfg {Boolean} infiniteScroll
     *
     * True to automatically adjust the panel timespan during horizontal scrolling, when the scroller comes close to the left/right edges.
     *
     * The actually rendered timespan in this mode (and thus the amount of HTML in the DOM) is calculated based
     * on the {@link #bufferCoef} option. The moment when the timespan shift happens is determined by the {@link #bufferThreshold} value.
     */
    infiniteScroll              : false,

    /**
     * @cfg {Boolean} showCrudManagerMask set this to true to display a load mask during CRUD manager server requests. Note: works only if {@link #crudManager} is specified.
     */
    showCrudManagerMask         : true,

    waitingForAutoTimeSpan      : false,

    columnLinesFeature          : null,

    renderWaitListener          : null,

    schedulePinchThreshold      : 30,
    pinchStartDistanceX         : null,
    pinchStartDistanceY         : null,
    pinchDistanceX              : null,
    pinchDistanceY              : null,
    horizontalColumns           : null,
    verticalColumns             : null,
    calendarColumns             : null,
    forceDefineTimeSpanByStore  : false,

    /**
    * @cfg {Object} tipCfg
    * The {@link Ext.Tooltip} config object used to configure a tooltip (only applicable if tooltipTpl is set).
    */
    tipCfg : {
        cls         : 'sch-tip',

        showDelay   : 1000,
        hideDelay   : 0,

        autoHide    : true,
        anchor      : 'b'
    },

    /**
     * @event timeheaderclick
     * Fires after a click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event timeheaderdblclick
     * Fires after a double click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The end date of the header cell
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event timeheadercontextmenu
     * Fires after a right click on a time header cell
     * @param {Sch.view.HorizontalTimeAxis} column The column object
     * @param {Date} startDate The start date of the header cell
     * @param {Date} endDate The start date of the header cell
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event scheduleclick
     * Fires after a click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event scheduledblclick
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event schedulecontextmenu
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event schedulepinchstart
     * Fires after a click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event schedulepinch
     * Fires after a doubleclick on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The clicked date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @event schedulepinchend
     * Fires after a context menu click on the schedule area
     * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
     * @param {Date} clickedDate The pinched date
     * @param {Number} rowIndex The row index
     * @param {Sch.model.Resource} resource The resource, an event occured on
     * @param {Ext.EventObject} e The event object
     */

    /**
     * @cfg {Object} l10n
     * A object, purposed for the class localization. Contains the following keys/values:

     - loadingText : 'Loading, please wait...'
     - savingText : 'Saving changes, please wait...'
     */

    inheritables : function () {

        return {
            // Configuring underlying table panel
            columnLines         : true,
            enableLocking       : true,
            lockable            : true,
            stateEvents         : ['viewchange'],
            syncRowHeight       : false,

            // EOF: Configuring underlying table panel
            cellTopBorderWidth  : 0,

            constructor : function (config) {
                config = config || {};

                if (this.layout === 'border') {
                    // HACK http://www.sencha.com/forum/showthread.php?287716-Ext.grid.locking.Lockable-GridPanel-layout-config&p=1051698#post1051698
                    config.layout = 'border';
                }

                this.callParent([config]);
            },

            // private
            initComponent : function () {

                if (this.partnerTimelinePanel) {

                    // Allow a cmp id to be passed in
                    if (typeof this.partnerTimelinePanel === 'string') {
                        this.partnerTimelinePanel = Ext.getCmp(this.partnerTimelinePanel);
                    }

                    this.timeAxisViewModel = this.partnerTimelinePanel.timeAxisViewModel;
                    this.timeAxis   = this.partnerTimelinePanel.getTimeAxis();
                    this.startDate  = this.timeAxis.getStart();
                    this.endDate    = this.timeAxis.getEnd();
                }


//                // for infinite scroll we turn timeaxis auto adjustment to get exact timeaxis.start date
//                // as a first left visible date tick
//                if (this.infiniteScroll) {
//                    this.autoAdjustTimeAxis     = false;
//                }

                this._initializeTimelinePanel();

                this.configureChildGrids();

                // Now the time axis view model is configured using the forceFit setting.
                // We never want the native Ext JS grid implementation of forceFit - disable it
                this.forceFit = false;

                this.configureColumns();

                var viewConfig      = this.normalViewConfig = this.normalViewConfig || {};
                var id              = this.getId();

                // Copy some properties to the view instance
                Ext.apply(this.normalViewConfig, {
                    id                      : id + '-timelineview',
                    eventPrefix             : this.autoGenId ? null : id,
                    timeAxisViewModel       : this.timeAxisViewModel,
                    eventBorderWidth        : this.eventBorderWidth,
                    timeAxis                : this.timeAxis,
                    readOnly                : this.readOnly,
                    mode                    : this.mode,
                    rtl                     : this.rtl,
                    cellBorderWidth         : this.cellBorderWidth,
                    cellTopBorderWidth      : this.cellTopBorderWidth,
                    cellBottomBorderWidth   : this.cellBottomBorderWidth,
                    infiniteScroll          : this.infiniteScroll,
                    bufferCoef              : this.bufferCoef,
                    bufferThreshold         : this.bufferThreshold
                });

                Ext.Array.forEach(
                    [
                        "eventRendererScope",
                        "eventRenderer",
                        "dndValidatorFn",
                        "resizeValidatorFn",
                        "createValidatorFn",
                        "tooltipTpl",
                        "validatorFnScope",
                        "eventResizeHandles",
                        "enableEventDragDrop",
                        "enableDragCreation",
                        "resizeConfig",
                        "createConfig",
                        "tipCfg",
                        "getDateConstraints"
                    ],
                    function (prop) {
                        if (prop in this) viewConfig[prop] = this[prop];
                    },
                    this
                );

                this.callParent(arguments);

                this.patchNavigationModel(this);

                this.setViewPreset(this.viewPreset, this.startDate || this.timeAxis.getStart(), this.endDate || this.timeAxis.getEnd(), true);

                // if no start/end dates specified let's get them from event store
                if (!this.startDate) {
                    var store       = this.getTimeSpanDefiningStore();

                    // if events already loaded
                    if (Ext.data.TreeStore && store instanceof Ext.data.TreeStore ? store.getRootNode().childNodes.length : store.getCount()) {
                        this.applyStartEndDatesFromStore();

                    // if timespan defining store is in state of loading
                    // or forceDefineTimeSpanByStore enabled
                    // we wait till the store gets loaded and only then refresh view
                    } else if (store.isLoading() || this.forceDefineTimeSpanByStore) {
                        this.bindAutoTimeSpanListeners();
                    }
                }

                var columnLines     = this.columnLines;

                if (columnLines) {
                    this.columnLinesFeature = new Sch.feature.ColumnLines(Ext.isObject(columnLines) ? columnLines : undefined);
                    this.columnLinesFeature.init(this);

                    this.columnLines    = true;
                }

                this.relayEvents(this.getSchedulingView(), [
                    /**
                    * @event beforetooltipshow
                    * Fires before the event tooltip is shown, return false to suppress it.
                    * @param {Sch.mixin.TimelinePanel} scheduler The scheduler object
                    * @param {Sch.model.Event} eventRecord The event record of the clicked record
                    */
                    'beforetooltipshow',

                    'scheduleclick',
                    'scheduledblclick',
                    'schedulecontextmenu',
                    'schedulepinch',
                    'schedulepinchstart',
                    'schedulepinchend'
                ]);

                this.on('boxready', this.__onBoxReady, this);

                // HACK, required since Ext has an async scroll sync mechanism setup which won't play nice with our "sync scroll" above.
                this.on('zoomchange', function () {
                    // After a zoom, the header is resized and Ext JS TablePanel reacts to the size change.
                    // Ext JS reacts after a short delay, so we cancel this task to prevent Ext from messing up the scroll sync
                    this.normalGrid.scrollTask.cancel();
                });

                // if we have CrudManager instance assigned, we should show and hide a load mask
                // But not with autoSync enabled, since that'll be a terrible user experience
                if (this.crudManager && !this.crudManager.autoSync && this.showCrudManagerMask) {
                    this.mon(this.crudManager, {
                        beforesend      : this.beforeCrudOperationStart,

                        synccanceled    : this.onCrudOperationComplete,
                        loadcanceled    : this.onCrudOperationComplete,
                        load            : this.onCrudOperationComplete,
                        sync            : this.onCrudOperationComplete,
                        loadfail        : this.onCrudOperationComplete,
                        syncfail        : this.onCrudOperationComplete,

                        scope           : this
                    });

                    // User might already have triggered a load operation
                    if (this.crudManager.isLoading()) {
                        this.beforeCrudOperationStart(this.crudManager, null, 'load');
                    }
                }

                this.afterInitComponent();
            },

            getState : function () {
                var me = this,
                    state = me.callParent(arguments);

                Ext.apply(state, {
                    viewPreset      : me.viewPreset,
                    startDate       : me.getStart(),
                    endDate         : me.getEnd(),
                    zoomMinLevel    : me.zoomMinLevel,
                    zoomMaxLevel    : me.zoomMaxLevel,
                    currentZoomLevel: me.currentZoomLevel
                });
                return state;
            },

            applyState : function (state) {
                var me = this;

                me.callParent(arguments);

                if (state && state.viewPreset) {
                    me.setViewPreset(state.viewPreset, state.startDate, state.endDate);
                }
                if (state && state.currentZoomLevel) {
                    me.zoomToLevel(state.currentZoomLevel);
                }
            },

            setTimeSpan : function () {
                if (this.waitingForAutoTimeSpan) {
                    this.unbindAutoTimeSpanListeners();
                }

                this.callParent(arguments);

                // if view was not initialized due to our refresh stopper the onTimeAxisViewModelUpdate method will not do a refresh
                // if that happened we do refresh manually
                if (!this.normalGrid.getView().viewReady) {
                    this.getView().refresh();
                }
            }
        };
    },


    bindAutoTimeSpanListeners : function () {
        var store                           = this.getTimeSpanDefiningStore();

        this.waitingForAutoTimeSpan         = true;

        // prevent panel refresh till eventStore gets loaded
        this.normalGrid.getView().on('beforerefresh', this.refreshStopper, this);
        this.lockedGrid.getView().on('beforerefresh', this.refreshStopper, this);

        this.mon(store, 'load', this.applyStartEndDatesFromStore, this);

        if (Ext.data.TreeStore && store instanceof Ext.data.TreeStore) {
            this.mon(store, 'rootchange', this.applyStartEndDatesFromStore, this);
            this.mon(store, 'nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
        } else {
            this.mon(store, 'add', this.applyStartEndDatesFromStore, this);
        }
    },


    refreshStopper : function (view) {
        return view.store.getCount() === 0;
    },


    getTimeSpanDefiningStore : function () {
        throw "Abstract method called";
    },

    unbindAutoTimeSpanListeners : function () {
        this.waitingForAutoTimeSpan = false;

        var store   = this.getTimeSpanDefiningStore();

        // allow panel refresh back
        this.normalGrid.getView().un('beforerefresh', this.refreshStopper, this);
        this.lockedGrid.getView().un('beforerefresh', this.refreshStopper, this);

        // unbind listener
        store.un('load', this.applyStartEndDatesFromStore, this);

        if (Ext.data.TreeStore && store instanceof Ext.data.TreeStore) {
            store.un('rootchange', this.applyStartEndDatesFromStore, this);
            store.un('nodeappend', this.applyStartEndDatesAfterTreeAppend, this);
        } else {
            store.un('add', this.applyStartEndDatesFromStore, this);
        }
    },


    applyStartEndDatesAfterTreeAppend : function () {
        var store   = this.getTimeSpanDefiningStore();

        // Need to block the reading of the total store timespan until the store is done loading
        // With CRUD manager, we need the __loading flag since multiple append events are fired during load
        if (!store.isSettingRoot && !store.__loading) {
            this.applyStartEndDatesFromStore();
        }
    },


    applyStartEndDatesFromStore : function () {
        var store   = this.getTimeSpanDefiningStore();
        var span    = store.getTotalTimeSpan();

        // If event store contains events without duration, add a 1 mainUnit buffer to each side
        if (span.end && span.start && span.end - span.start === 0) {
            span.start = Sch.util.Date.add(span.start, this.timeAxis.mainUnit, -1);
            span.end   = Sch.util.Date.add(span.end, this.timeAxis.mainUnit, 1);
        }

        this.setTimeSpan(span.start || new Date(), span.end);
    },


    onLockedGridItemDblClick : function (grid, record, el, rowIndex, event) {
        if (this.mode === 'vertical' && record) {
            this.fireEvent('timeheaderdblclick', this, record.get('start'), record.get('end'), rowIndex, event);
        }
    },

    /**
    * Returns the view which renders the schedule and time columns. This method should be used instead of the usual `getView`,
    * since `getView` will return an instance of a special "locking" grid view, which has no scheduler-specific features.
    *
    * @return {Sch.mixin.SchedulerView} view A view implementing the {@link Sch.mixin.SchedulerView} mixin
    */
    getSchedulingView : function () {
        return this.normalGrid.getView();
    },

    getHorizontalTimeAxisColumn : function () {
        return this.getSchedulingView().getHorizontalTimeAxisColumn();
    },

    configureColumns : function () {

        var columns         = this.columns || [];

        // The 'columns' config can also be a config object for Ext.grid.header.Container
        if (columns.items) {
            columns = columns.items;
        } else {
            // Clone it to make sure we handle the case of a column array object put on the class prototype
            columns = this.columns = columns.slice();
        }

        var lockedColumns   = [];
        var normalColumns   = [];

        // Split locked and normal columns first
        Ext.Array.forEach(columns, function (column) {
            if (column.position === 'right') {
                if (!Ext.isNumber(column.width)) {
                    Ext.Error.raise('"Right" columns must have a fixed width');
                }
                column.locked = false;

                normalColumns.push(column);
            } else {
                column.locked = true;
                lockedColumns.push(column);
            }
            column.lockable = false;
        });

        Ext.Array.erase(columns, 0, columns.length);
        Ext.Array.insert(columns, 0, lockedColumns.concat(
            {
                xtype                   : 'timeaxiscolumn',
                timeAxisViewModel       : this.timeAxisViewModel,
                trackHeaderOver         : this.trackHeaderOver,
                renderer                : this.mainRenderer,
                scope                   : this
            }
        ).concat(normalColumns));

        // Save reference to original set of columns
        this.horizontalColumns = Ext.Array.clone(columns);

        this.verticalColumns = [
            Ext.apply({
                xtype                   : 'verticaltimeaxis',
                width                   : 100,
                timeAxis                : this.timeAxis,
                timeAxisViewModel       : this.timeAxisViewModel,
                cellTopBorderWidth      : this.cellTopBorderWidth,
                cellBottomBorderWidth   : this.cellBottomBorderWidth
            }, this.timeAxisColumnCfg || {})
        ];

        this.calendarColumns = [
            Ext.apply({
                xtype                   : 'verticaltimeaxis',
                width                   : 60,
                timeAxis                : this.timeAxis,
                timeAxisViewModel       : this.timeAxisViewModel,
                cellTopBorderWidth      : this.cellTopBorderWidth,
                cellBottomBorderWidth   : this.cellBottomBorderWidth
            }, this.calendarTimeAxisCfg || {})
        ];

        if (this.mode === 'vertical') {
            this.columns    = this.verticalColumns.concat(this.createResourceColumns(this.resourceColumnWidth || this.timeAxisViewModel.resourceColumnWidth));
            this.store      = this.timeAxis;
        } else if (this.mode === 'calendar') {
            // in order to build columns/rows for calendar view we need time axis with view preset consumed
            // but axis is filled only after columns are initialized thus can be changed only via 'reconfigure' method
            // than requires grid to be rendered.
            // We provide empty configs for columns and rows in order to make this procedure slightly faster
            // There is almost no other way untill timeaxis is filled before 'callParent' call.
            this.columns = [];
            this.store = null;
            this.on('afterrender', this.refreshCalendarColumns, this);
        }
    },


    mainRenderer : function (val, meta, rowRecord, rowIndex, colIndex) {
        var renderers       = this.renderers,
            resource        = this.mode === 'horizontal' || this.mode === 'calendar' ? rowRecord : this.resourceStore.getAt(colIndex),
            retVal          = '&nbsp;'; // To ensure cells always consume correct height

        // Ext doesn't clear the meta object between cells
        meta.rowHeight      = null;

        for (var i = 0; i < renderers.length; i++) {
            retVal          += renderers[i].fn.call(renderers[i].scope || this, val, meta, resource, rowIndex, colIndex) || '';
        }

        if (this.variableRowHeight) {
            // Set row height
            var view                = this.getSchedulingView();
            var defaultRowHeight    = this.getRowHeight();

            meta.style              = 'height:' + ((meta.rowHeight || defaultRowHeight) - view.cellTopBorderWidth - view.cellBottomBorderWidth) + 'px';
        }

        return retVal;
    },

    // Child grids sync code
    // ---------------------------------
    __onBoxReady : function () {
        var me = this;

        me.normalGrid.on({
            collapse    : me.onNormalGridCollapse,
            expand      : me.onNormalGridExpand,
            scope       : me
        });

        me.lockedGrid.on({
            collapse    : me.onLockedGridCollapse,
            itemdblclick: me.onLockedGridItemDblClick,
            scope       : me
        });

        if (this.partnerTimelinePanel) {
            if (this.partnerTimelinePanel.rendered) {
                this.setupPartnerTimelinePanel();
            } else {
                this.partnerTimelinePanel.on('boxready', this.setupPartnerTimelinePanel, this);
            }
        }

        if (Ext.supports.Touch) {
            this.getSchedulingView().on({
                schedulepinchstart : this.onSchedulePinchStart,
                schedulepinch      : this.onSchedulePinch,
                schedulepinchend   : this.onSchedulePinchEnd,
                scope              : this
            });
        }
    },


    onLockedGridCollapse : function () {
        if (this.normalGrid.collapsed) {
            this.normalGrid.expand();
        }
    },

    onNormalGridCollapse : function () {
        var me = this;

        //Hack for Gantt to prevent creating second expander when normal grid initially collapsed
        if (!me.normalGrid.reExpander) {
            me.normalGrid.reExpander = me.normalGrid.placeholder;
        }

        if (!me.lockedGrid.rendered) {
            me.lockedGrid.on('render', me.onNormalGridCollapse, me, { delay: 1 });
        } else {
            me.lockedGrid.flex = 1;
            me.lockedGrid.updateLayout();

            if (me.lockedGrid.collapsed) {
                me.lockedGrid.expand();
            }

            // Show a vertical scrollbar in locked grid if normal grid is collapsed
            me.addCls('sch-normalgrid-collapsed');
        }
    },

    onNormalGridExpand : function () {
        this.removeCls('sch-normalgrid-collapsed');

        delete this.lockedGrid.flex;
        this.lockedGrid.updateLayout();
    },

    onPartnerCollapseExpand : function (panel) {
        if (panel.getCollapsed()) {
            this.lockedGrid.collapse();
        } else {
            this.lockedGrid.expand();
        }
    },

    setupPartnerTimelinePanel : function () {

        // Sync locked grids by listening for splitter resize events of both locked grids.
        var otherPanel = this.partnerTimelinePanel;
        var externalSplitter = otherPanel.down('splitter');
        var ownSplitter = this.down('splitter');

        if (externalSplitter) {
            externalSplitter.on('dragend', function () {
                this.lockedGrid.setWidth(otherPanel.lockedGrid.getWidth());
            }, this);
        }

        if (ownSplitter) {
            ownSplitter.on('dragend', function () {
                otherPanel.lockedGrid.setWidth(this.lockedGrid.getWidth());
            }, this);
        }

        var lockedWidth = otherPanel.isVisible() ? otherPanel.lockedGrid.getWidth() : otherPanel.lockedGrid.width;

        // Ext 5.1.0 don't support initially collapsed locked grid, exception will be raised.
        // Ext 4.2.1 is outdated and have a bug that prevents this code from working.
        // It means that in 4.2.1 if locked grid is initially collapsed, width won't be synced until splitter is dragged
        if (otherPanel.lockedGrid.getCollapsed()) {
            // after locked grid is initially expanded we can sync width
            otherPanel.lockedGrid.on('viewready', function (panel) {
                this.lockedGrid.setWidth(panel.getWidth());
            }, this);
        } else {
            this.lockedGrid.setWidth(lockedWidth);
        }

        // if we change collapse state in process of layout update
        // component won't be collapsible/expandable anymore
        this.on('afterlayout', function () {
            if (otherPanel.lockedGrid.getCollapsed()) {
                this.lockedGrid.collapse();
            } else {
                this.lockedGrid.expand();
                this.lockedGrid.setWidth(lockedWidth);
            }
        }, this, { single : true });

        otherPanel.lockedGrid.on({
            collapse    : this.onPartnerCollapseExpand,
            expand      : this.onPartnerCollapseExpand,
            scope       : this
        });

        this.lockedGrid.on({
            collapse    : this.onPartnerCollapseExpand,
            expand      : this.onPartnerCollapseExpand,
            scope       : otherPanel
        });

        // sync scrolling with external timeline panel
        var otherView = otherPanel.getSchedulingView(),
            otherScrollSource = otherView.scrollManager ? otherView.scrollManager.scroller : otherView.getEl(),
            ownView = this.getSchedulingView(),
            ownScrollSource = ownView.scrollManager ? ownView.scrollManager.scroller : ownView.getEl(),
            activeScrollSource,
            resetFn = Ext.Function.createBuffered(function() {
                activeScrollSource = null;
            }, 300);

        // Need to prevent the view being scrolled by user from updating itself based on its partner also firing 'scroll' events
        var syncScroll = function (e, el) {
            var sourceView = el.id === ownView.id ? ownView : otherView;
            var targetView = el.id === ownView.id ? otherView : ownView;

            if (!activeScrollSource) {
                activeScrollSource = sourceView;
            }

            resetFn();

            if (targetView !== activeScrollSource) {
                targetView.setScrollX(sourceView.getScroll().left);
            }
        };

        otherView.mon(ownScrollSource, 'scroll', syncScroll);
        ownView.mon(otherScrollSource, 'scroll', syncScroll);

        // Update the 'viewPreset' property manually since it's a public property of the TimelinePanel.
        this.on('viewchange', function () {
            otherPanel.viewPreset = this.viewPreset;
        }, this);

        otherPanel.on('viewchange', function () {
            this.viewPreset = otherPanel.viewPreset;
        }, this);
    },
    // EOF child grids sync code --------------------------

    beforeCrudOperationStart : function (manager, params, type) {
        if (this.rendered) {
            this.setLoading({
                msg : type === 'load' ? this.L('loadingText') : this.L('savingText')
            });
        } else {
            Ext.destroy(this.renderWaitListener);
            this.renderWaitListener = this.on('render', Ext.Function.bind(this.beforeCrudOperationStart, this, Array.prototype.slice.apply(arguments)), this, {
                delay       : 1,
                destroyable : true
            });
        }
    },

    onCrudOperationComplete : function () {
        Ext.destroy(this.renderWaitListener);

        this.setLoading(false);
    },

    onSchedulePinchStart : function (view, e) {
        this.pinchStartDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
        this.pinchStartDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
    },

    onSchedulePinch : function (view, e) {
        this.pinchDistanceX = Math.abs(e.touches[0].pageX - e.touches[1].pageX);
        this.pinchDistanceY = Math.abs(e.touches[0].pageY - e.touches[1].pageY);
    },

    onSchedulePinchEnd   : function (view, e) {
        var xDistance = this.pinchDistanceX;
        var yDistance = this.pinchDistanceY;
        var isHorizontal = this.getMode()[0] === 'h';

        if (Math.abs(xDistance - this.pinchStartDistanceX) > this.schedulePinchThreshold) {
            var scaleX = Math.abs(xDistance / this.pinchStartDistanceX);

            if (isHorizontal) {
                scaleX > 1 ? this.zoomIn() : this.zoomOut();
            } else {
                this.timeAxisViewModel.setViewColumnWidth(scaleX * this.timeAxisViewModel.resourceColumnWidth);
            }
        }

        if (Math.abs(yDistance - this.pinchStartDistanceY) > this.schedulePinchThreshold) {
            var scaleY = Math.abs(yDistance / this.pinchStartDistanceY);

            view.setRowHeight(view.getRowHeight() * scaleY);
        }

        this.pinchStartDistanceX = this.pinchStartDistanceY = this.pinchDistanceX = this.pinchDistanceY = null;
    },

    // Patches navigation model to skip undesired programmatic row focusing if timeline row is about to be focused.
    // This prevents timeline view scrolling to the top/left when clicking a non-focused timeline view row.
    // https://www.assembla.com/spaces/bryntum/tickets/1795
    patchNavigationModel : function (me) {
        me.getView().getNavigationModel().focusItem = function (item) {
            item.addCls(this.focusCls);

            if ((Ext.isIE && !item.hasCls('sch-timetd')) ||          // For IE, avoid focus when clicking on any schedule cell
                (!Ext.isIE && me.getOrientation() === 'horizontal')) // For non-IE: in vertical or calendar view, skip scroll to top
            {
                item.focus();
            }
        };

        // https://www.sencha.com/forum/showthread.php?301110-Last-focused-item-is-not-synced-which-causes-scroll-jump
        var lockedView = me.lockedGrid.getView();
        var normalView = me.normalGrid.getView();

        lockedView.on('rowclick', function (view, record, tr, rowIndex) {
            if (normalView.lastFocused) {
                normalView.lastFocused.rowIdx = rowIndex;
                normalView.lastFocused.record = record;
            }
        });

        normalView.on('rowclick', function (view, record, tr, rowIndex) {
            if (lockedView.lastFocused) {
                lockedView.lastFocused.rowIdx = rowIndex;
                lockedView.lastFocused.record = record;
            }
        });
    },

    configureChildGrids : function () {
        var me = this;

        // Make local copies of these configs in case someone puts them on the prototype of a subclass.
        me.lockedGridConfig = Ext.apply({}, me.lockedGridConfig || {});
        me.normalGridConfig = Ext.apply({}, me.schedulerConfig || me.normalGridConfig || {});

        var lockedGrid = me.lockedGridConfig,
            normalGrid = me.normalGridConfig;

        if (me.lockedXType) {
            lockedGrid.xtype = me.lockedXType;
        }

        if (me.normalXType) {
            normalGrid.xtype = me.normalXType;
        }

        // Configure the child grids
        Ext.applyIf(lockedGrid, {
            useArrows         : true,
            split             : true,
            animCollapse      : false,
            collapseDirection : 'left',
            trackMouseOver    : false,
            region            : 'west'
        });

        Ext.applyIf(normalGrid, {
            viewType : me.viewType,
            layout   : 'fit',

            enableColumnMove   : false,
            enableColumnResize : false,
            enableColumnHide   : false,
            trackMouseOver     : false,

            collapseDirection : 'right',
            collapseMode      : 'placeholder',

            animCollapse : false,
            region       : 'center'
        });

        if (me.mode === 'vertical') {
            lockedGrid.store = normalGrid.store = me.timeAxis;
        }

        if (lockedGrid.width) {
            // User has specified a fixed width for the locked section, disable the syncLockedWidth method
            me.syncLockedWidth = Ext.emptyFn;
            // Enable scrollbars for locked section
            lockedGrid.scroll = Ext.supports.Touch ? 'both' : 'horizontal';
            lockedGrid.scrollerOwner = true;
        }
    },

    afterInitComponent : function () {
        var me = this;

        var lockedView = me.lockedGrid.getView();
        var normalView = me.normalGrid.getView();
        var isTree = Ext.data.TreeStore && me.store instanceof Ext.data.TreeStore;

        if (me.normalGrid.collapsed) {
            // Need to workaround this, child grids cannot be collapsed initially
            me.normalGrid.collapsed = false;

            // Note, for the case of buffered view/store we need to wait for the view box to be ready before collapsing
            // since the paging scrollbar reads the view height during setup. When collapsing too soon, its viewSize will be 0.
            normalView.on('boxready', function () {
                me.normalGrid.collapse();
            }, me, { delay : 10 });
        }

        if (me.lockedGrid.collapsed) {
            if (lockedView.bufferedRenderer) lockedView.bufferedRenderer.disabled = true;
        }

        // Without this fix, scrolling on Mac Chrome does not work in locked grid
        if (Ext.getScrollbarSize().width === 0) {
            // https://www.assembla.com/spaces/bryntum/support/tickets/252
            lockedView.addCls('sch-ganttpanel-force-locked-scroll');
        }

        if (isTree) {
            this.setupLockableFilterableTree();
        }

        // HACK, no sane way of getting rid of grid column menu items (as of 4.2.1).
        // Grouping view overwrites showMenuBy property
        // http://www.sencha.com/forum/showthread.php?269612-Config-to-get-rid-of-Lock-Unlock-column-options&p=987653#post987653
        this.on('afterrender', function() {

            var showMenuBy = this.lockedGrid.headerCt.showMenuBy;

            this.lockedGrid.headerCt.showMenuBy = function () {
                showMenuBy.apply(this, arguments);

                me.showMenuBy.apply(this, arguments);
            };
        });
    },

    setupLockableFilterableTree : function () {
        var me = this;
        var lockedView = me.lockedGrid.getView();

        // enable filtering support for trees
        var filterableProto = Sch.mixin.FilterableTreeView.prototype;

        lockedView.initTreeFiltering = filterableProto.initTreeFiltering;
        lockedView.onFilterChangeStart = filterableProto.onFilterChangeStart;
        lockedView.onFilterChangeEnd = filterableProto.onFilterChangeEnd;
        lockedView.onFilterCleared = filterableProto.onFilterCleared;
        lockedView.onFilterSet = filterableProto.onFilterSet;

        lockedView.initTreeFiltering();
    },

    showMenuBy : function (t, header) {
        var menu = this.getMenu(),
            unlockItem = menu.down('#unlockItem'),
            lockItem = menu.down('#lockItem'),
            sep = unlockItem.prev();

        sep.hide();
        unlockItem.hide();
        lockItem.hide();
    },

    /**
     * Changes the timeframe of the scheduling chart to fit all the events in it.
     * @param {Object} [options] Options object for the zooming operation.
     * @param {Integer} [options.leftMargin] Defines margin in pixel between the first event start date and first visible date
     * @param {Integer} [options.rightMargin] Defines margin in pixel between the last event end date and last visible date
     */
    zoomToFit : function (options) {
        options = Ext.apply({
            adjustStart : 1,
            adjustEnd   : 1
        }, options);

        var eventStore = this.getEventStore();
        var span = eventStore.getTotalTimeSpan();

        if (this.zoomToSpan(span, options) === null) {
            // if no zooming was performed - fit columns to view space
            this.getSchedulingView().fitColumns();
        }
    }
}, function () {
    var MIN_EXT_VERSION = '5.1.0';

    Ext.apply(Sch, {
        /*PKGVERSION*/VERSION : '3.0.6'
    });

    // DELETE THIS CHECK IF YOU WANT TO RUN AGAINST AN OLDER UNSUPPORTED EXT JS VERSION
    if (Ext.versions.extjs.isLessThan(MIN_EXT_VERSION)) {
        var c = console;
        c && c.log('The Ext JS version you are using needs to be updated to at least ' + MIN_EXT_VERSION);
    }
});

}

/**

@class Sch.mixin.AbstractSchedulerPanel
@private

A mixin providing "scheduling" functionality to the consuming "panel".
A consuming class should have already consumed the {@link Sch.mixin.AbstractTimelinePanel} mixin.

This should not be used directly.

*/

Ext.define('Sch.mixin.AbstractSchedulerPanel', {

    requires: [
        'Sch.model.Event',
        'Sch.model.Resource',
        'Sch.data.EventStore',
        'Sch.data.ResourceStore',
        'Sch.util.Date',
        'Sch.plugin.ResourceZones'
    ],

    /**
    * @cfg {String} eventBarIconClsField
    * A field in the Event model whose value will be applied as a CSS class to each event bar to place a 16x16 icon.
    */
    eventBarIconClsField    : '',

    /**
    * @cfg {Boolean} enableEventDragDrop true to enable drag and drop of events, defaults to true
    */
    enableEventDragDrop: true,

    /**
    * @cfg {String} eventBarTextField The field in your data model that will be rendered into each event bar.
    * You can alternatively use the eventBarRenderer to get full control over what gets displayed.
    */

    /**
     * @cfg {String} resourceColumnClass
     * Defines the column class for the resources, override this to use your own custom column class. (Used only in vertical orientation)
     */
    resourceColumnClass : "Sch.column.Resource",

    /**
     * @cfg {Number} resourceColumnWidth
     * Used only in vertical mode. Defines the width of a single column.
     */
    resourceColumnWidth : null,
    
    /**
     * @cfg {Number} calendarColumnWidth
     * Used only in calendar mode. Defines the width of a single column.
     */
    calendarColumnWidth : null,

    /**
    * @cfg {Boolean} allowOverlap Set to false if you don't want to allow events overlapping (defaults to true).
    */
    allowOverlap: true,

    /**
    * @cfg {String} startParamName The name of the start date parameter that will be passed to in every `eventStore` load request.
    */
    startParamName: 'startDate',

    /**
    * @cfg {String} endParamName The name of the end date parameter that will be passed to in every `eventStore` load request.
    */
    endParamName: 'endDate',

    /**
    * @cfg {Boolean} passStartEndParameters true to apply start and end dates of the current view to any `eventStore` load requests.
    */
    passStartEndParameters: false,

    variableRowHeight : true,
    
    /**
     * @cfg {Number} barMargin
     * Controls how much space to leave between the event bars and the row borders. Defaults to 1.
     */

    /**
     * @cfg {Boolean} constrainDragToResource
     * Set to true to only allow dragging events within the same resource. Defaults to false.
     */

    /**
    * @cfg {Function} eventRenderer
    * An empty function by default, but provided so that you can override it. This function is called each time an event
    * is rendered into the schedule to render the contents of the event. It's called with the event, its resource and a tplData object which
    * allows you to populate data placeholders inside the event template.
    * By default, the {@link #eventTpl} includes placeholders for 'cls' and 'style'. The cls property is a CSS class which will be added to the
    * event element. The style property is an inline style declaration for the event element. If you override the default {@link #eventTpl}, you can of course
    * include other placeholder in your template markup. Note: You will still need to keep the original built-in placeholders for the scheduler to work.
    *
    * <pre>
    *  eventRenderer : function (eventRec, resourceRec, templateData) {
    *      templateData.style = 'color:white';                 // You can use inline styles too.
    *      templateData.cls = resourceRec.get('Category');     // Read a property from the resource record, used as a CSS class to style the event
    *
    *      return Ext.Date.format(eventRec.getStartDate(), 'Y-m-d') + ': ' + eventRec.getName();
    *  }
    *</pre>
    * @param {Sch.model.Event} eventRecord The event about to be rendered
    * @param {Sch.model.Resource} resourceRecord The resource row in which the event is being created
    * @param {Object} tplData An object that will be applied to the containing {@link #eventTpl}.
    * @param {Number} row The row index
    * @param {Number} col The column index
    * @param {Sch.data.ResourceStore} ds The resource store
    * @return {String/Object} A simple string, or a custom object which will be applied to the {@link #eventBodyTemplate}, creating the actual HTML
    */
    eventRenderer: null,

    /**
    * @cfg {Object} eventRendererScope The scope to use for the {@link #eventRenderer} function
    */
    eventRendererScope : null,

    /**
     * @cfg {Sch.data.EventStore} eventStore The {@link Ext.data.Store} holding the events to be rendered into the scheduler (required).
     * @required
     */
    eventStore: null,

    /**
     * @cfg {Sch.data.ResourceStore} resourceStore The {@link Ext.data.Store} holding the resources to be rendered into the scheduler (required).
     */
    resourceStore: null,

    /**
     * @method onEventCreated An empty function by default, but provided so that you can override it to supply default record values etc. This function is called after a new event has been created (but
     * before it is inserted to the store). This is for example called after a user dragged a new bar in the scheduler (the DragFreate feature).
     * @param {Sch.model.Event} eventRecord The event that was just created
     */
    onEventCreated: function (newEventRecord) {},

    /**
    * @cfg {Ext.Template} eventTpl The wrapping template used to renderer your events in the scheduler. Normally you should not override this,
    * only do so if you need total control of how the events are rendered/styled. See the {@link #eventBodyTemplate} for more information.
    */

    /**
    * @cfg {String/Ext.Template} eventBodyTemplate The template used to generate the markup of your events in the scheduler. To 'populate' the eventBodyTemplate with data, use the {@link #eventRenderer} method
    */

    /**
    *  @cfg {Object} timeAxisColumnCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in vertical mode.
    */
    
    /**
     * @cfg {Object} calendarTimeAxisCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in calendar mode.
     */

    /**
     * @cfg {Sch.data.EventStore} resourceZones A special store containing data used to highlight the underlying schedule for the resources,
     * using {@link Sch.plugin.ResourceZones}. This can be used to color non-working time or any other meta data associated with a resource.
     * See also {@link #resourceZonesConfig}.
     */
    resourceZones       : null,

    /**
     * @cfg {Object} resourceZonesConfig An object with configuration options for {@link Sch.plugin.ResourceZones}. Ignored if no {@link #resourceZones}
     * config is provided.
     */
    resourceZonesConfig : null,

    initStores : function() {
        var resourceStore   = this.resourceStore || this.store;

        if (!resourceStore) {
            if (this.crudManager) {
                resourceStore = this.resourceStore = this.crudManager.getResourceStore();
            }

            resourceStore = resourceStore || new Sch.data.ResourceStore();
        }

        if (!this.eventStore) {

            if (this.crudManager) {
                this.eventStore = this.crudManager.getEventStore();
            }

            this.eventStore = this.eventStore || new Sch.data.EventStore();
            if (!this.eventStore) {
                Ext.Error.raise("You must specify an eventStore config");
            }
        }

        // Set "store" for the grid panel API
        this.store          = Ext.StoreManager.lookup(resourceStore);
        this.resourceStore  = this.store;
        this.eventStore     = Ext.StoreManager.lookup(this.eventStore);

        if (!this.eventStore.isEventStore) {
            Ext.Error.raise("Your eventStore should be a subclass of Sch.data.EventStore (or consume the EventStore mixin)");
        }

        this.resourceStore.eventStore = this.eventStore;

        if (this.passStartEndParameters) {
            this.eventStore.on('beforeload', this.applyStartEndParameters, this);
        }
    },

    _initializeSchedulerPanel : function() {
        this.initStores();

        if (this.eventBodyTemplate && Ext.isString(this.eventBodyTemplate)) {
            this.eventBodyTemplate = new Ext.XTemplate(this.eventBodyTemplate);
        }
    },

    /**
    * Returns the resource store instance
    * @return {Sch.data.ResourceStore}
    */
    getResourceStore: function () {
        return this.resourceStore;
    },

    /**
    * Returns the event store instance
    * @return {Sch.data.EventStore}
    */
    getEventStore: function () {
        return this.eventStore;
    },

    // Applies the start and end date to each event store request
    applyStartEndParameters: function (eventStore, options) {
        var proxy = eventStore.getProxy();

        proxy.setExtraParam(this.startParamName, this.getStart());
        proxy.setExtraParam(this.endParamName, this.getEnd());
    },

    createResourceColumns : function (colWidth) {
        var newItems = [];
        var me = this;

        this.resourceStore.each(function (resource) {
            newItems.push(
                Ext.create(me.resourceColumnClass, {
                    renderer : me.mainRenderer,
                    scope    : me,
                    width    : colWidth || 100,
                    text     : resource.getName(),
                    model    : resource
                })
            );
        });

        return newItems;
    }
});


/**

 @class Sch.mixin.SchedulerPanel
 @extends Sch.mixin.AbstractSchedulerPanel

 A mixin for {@link Ext.panel.Panel} classes, providing "scheduling" functionality to the consuming panel.
 A consuming class should have already consumed the {@link Sch.mixin.TimelinePanel} mixin.

 Generally, should not be used directly, if you need to subclass the scheduler panel, subclass the {@link Sch.panel.SchedulerGrid} or {@link Sch.panel.SchedulerTree}
 instead.

 */
Ext.define('Sch.mixin.SchedulerPanel', {

    extend              : 'Sch.mixin.AbstractSchedulerPanel',

    requires            : [
        'Sch.view.SchedulerGridView',
        'Sch.selection.EventModel',
        'Sch.column.timeAxis.Vertical'
    ],

    /**
     * @cfg {String} eventSelModelType The xtype of the selection model to be used to events. Should be a {@link Sch.selection.EventModel} or its subclass.
     */
    eventSelModelType   : null, // 'eventmodel', 'assignmentmodel'

    /**
     * @cfg {Object} eventSelModel The configuration object for the event selection model. See {@link Sch.selection.EventModel} for available configuration options.
     */
    eventSelModel       : null,

    /**
     * @cfg {Boolean} enableEventDragDrop true to enable drag and drop of events, defaults to true
     */
    enableEventDragDrop : true,

    /**
     * @cfg {Boolean} enableDragCreation true to enable creating new events by click and drag, defaults to true
     */
    enableDragCreation  : true,

    /**
     * @cfg {Object} dragConfig Custom config to pass to the {@link Sch.feature.SchedulerDragZone}
     * instance which will be created by {@link Sch.feature.DragDrop}.
     */
    dragConfig          : null,

    /**
     * @cfg {Object} timeAxisColumnCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in vertical mode.
     */

     /**
     * @cfg {Object} calendarTimeAxisCfg A {@link Ext.grid.column.Column} config used to configure the time axis column in calendar mode.
     */

    /**
     * @cfg {Object} createConfig Custom config to pass to the {@link Sch.feature.DragCreator} instance
     */

    /**
     * @cfg {Object} resizeConfig Custom config to pass to the {@link Sch.feature.ResizeZone} instance
     */

    componentCls                : 'sch-schedulerpanel',

    // even that this config "belongs" to the Sch.mixin.TimelinePanel mixin
    // we can't define it there, because of various reasons (extjs mixin system)
    // this is guarded by the 203_buffered_view_1.t.js test in gantt and 092_rowheight.t.js in scheduler
    /**
     * @ignore
     * @cfg {Boolean} lockedGridDependsOnSchedule set this to true if you require the left (locked) grid section to be refreshed when the schedule is updated.
     */
    lockedGridDependsOnSchedule : true,

    /**
     * @cfg {Boolean} [multiSelect=false]
     * True to allow selection of more than one event at a time, false to allow selection of only a single item
     * at a time or no selection at all, depending on the value of {@link #singleSelect}.
     */
    /**
     * @cfg {Boolean} [singleSelect]
     * Allows selection of exactly one event at a time. As this is the default selection mode anyway, this config
     * is completely ignored.
     */
    /**
     * @cfg {Boolean} [simpleSelect=false]
     * True to enable multiselection by clicking on multiple events without requiring the user to hold Shift or Ctrl,
     * false to force the user to hold Ctrl or Shift to select more than on item.
     */

    /**
     * @cfg {Function} dndValidatorFn
     * An empty function by default, but provided so that you can perform custom validation on
     * the item being dragged. This function is called during a drag and drop process and also after the drop is made.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true if the drop position is valid, else false to prevent a drop.
     * @param {Array} dragRecords an array containing the records for the events being dragged
     * @param {Sch.model.Resource} targetResourceRecord the target resource of the the event
     * @param {Date} date The date corresponding to the drag proxy position
     * @param {Number} duration The duration of the item being dragged in milliseconds
     * @param {Event} e The event object
     * @return {Boolean}
     */

    /**
     * @cfg {Function} resizeValidatorFn
     * Provide to perform custom validation on an item being resized.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true if the resize state is valid, else false.
     * @param {Sch.model.Resource} resourceRecord the resource of the row in which the event is located
     * @param {Sch.model.Event} eventRecord the event being resized
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean}
     */


    /**
     * @cfg {Function} createValidatorFn
     * Provide to perform custom validation on the item being created.
     * To control what 'this' points to inside this function, use
     * {@link Sch.panel.TimelineGridPanel#validatorFnScope} or {@link Sch.panel.TimelineTreePanel#validatorFnScope}.
     * Return true to signal that the new event is valid, or false prevent it.
     * @param {Sch.model.Resource} resourceRecord the resource for which the event is being created
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Event} e The event object
     * @return {Boolean} true
     */

    verticalListeners : null,

    /**
     * @event orientationchange
     * Fires after an orientation change
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler panel
     * @param {String} orientation The new orientation ('horizontal' or 'vertical')
     * @deprecated 2.2.22 Use {@link #modechange}
     */

     /**
     * @event modechange
     * Fires after a mode change
     * @param {Sch.panel.SchedulerGrid/Sch.panel.SchedulerTree} scheduler The scheduler panel
     * @param {String} mode The new mode ('horizontal', 'vertical', 'calendar')
     */

    // Cached value of locked grid width used when switching orientation
    horizontalLockedWidth : null,

    inheritables : function () {
        return {
            variableRowHeight   : true,

            // private
            initComponent : function () {
                var viewConfig = this.normalViewConfig = this.normalViewConfig || {};
                this._initializeSchedulerPanel();

                this.verticalListeners = {
                    clear       : this.refreshResourceColumns,
                    datachanged : this.refreshResourceColumns,
                    update      : this.refreshResourceColumns, // TODO WASTEFUL
                    load        : this.refreshResourceColumns,
                    scope       : this
                };

                this.calendarListeners = {
                    reconfigure     : this.refreshCalendarColumns,
                    priority        : 1,
                    scope           : this
                };

                this.calendarViewListeners = {
                    columnresize    : this.onCalendarColumnResize,
                    scope           : this
                };

                Ext.apply(viewConfig, {
                    eventStore        : this.eventStore,
                    resourceStore     : this.resourceStore,
                    eventBarTextField : this.eventBarTextField || this.eventStore.model.prototype.nameField
                });

                Ext.Array.forEach(
                    [
                        "barMargin",
                        "eventBodyTemplate",
                        "eventTpl",
                        "allowOverlap",
                        "dragConfig",
                        "eventBarIconClsField",
                        "onEventCreated",
                        "constrainDragToResource",
                        "snapRelativeToEventStartDate",
                        "eventSelModelType",
                        "simpleSelect",
                        "multiSelect",
                        "allowDeselect"
                    ],
                    function (prop) {
                        if (prop in this) viewConfig[prop] = this[prop];
                    },
                    this
                );

                this.callParent(arguments);

                // mode is safe to use after callParent where we check for deprecated 'orientation' option
                if (this.mode === 'vertical') {
                    this.mon(this.resourceStore, this.verticalListeners);
                }

                var lockedView      = this.lockedGrid.getView();
                var normalView      = this.getSchedulingView();

                this.registerRenderer(normalView.columnRenderer, normalView);

                if (this.resourceZones) {
                    var resourceZoneStore = Ext.StoreManager.lookup(this.resourceZones);
                    resourceZoneStore.setResourceStore(this.resourceStore);

                    this.resourceZonesPlug = new Sch.plugin.ResourceZones(Ext.apply({
                        store : resourceZoneStore
                    }, this.resourceZonesConfig));

                    this.resourceZonesPlug.init(this);
                }

                normalView.on('columnwidthchange', this.onColWidthChange, this);

                // Relaying after parent class has setup the locking grid components
                this.relayEvents(normalView, [
                /**
                 * @event eventclick
                 * Fires when an event is clicked
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The event record of the clicked event
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventclick',

                /**
                 * @event eventmousedown
                 * Fires when a mousedown event is detected on a rendered event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventmousedown',

                /**
                 * @event eventmouseup
                 * Fires when a mouseup event is detected on a rendered event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventmouseup',

                /**
                 * @event eventdblclick
                 * Fires when an event is double clicked
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The event record of the clicked event
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventdblclick',

                /**
                 * @event eventcontextmenu
                 * Fires when contextmenu is activated on an event
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} eventRecord The event record of the clicked event
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventcontextmenu',

                /**
                 * @event eventmouseenter
                 * Fires when the mouse moves over an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventmouseenter',

                /**
                 * @event eventmouseleave
                 * Fires when the mouse moves out of an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventmouseleave',

                /**
                 * @event eventkeydown
                 * Fires when a keydown event is detected on an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventkeydown',

                /**
                 * @event eventkeyup
                 * Fires when a keyup event is detected on an event
                 * @param {Mixed} view The scheduler view instance
                 * @param {Sch.model.Event} eventRecord The event record
                 * @param {Ext.EventObject} e The event object
                 */
                    'eventkeyup',
                    // Resizing events start --------------------------
                /**
                 * @event beforeeventresize
                 * Fires before a resize starts, return false to stop the execution
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The record about to be resized
                 * @param {Ext.EventObject} e The event object
                 */
                    'beforeeventresize',

                /**
                 * @event eventresizestart
                 * Fires when resize starts
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The event record being resized
                 */
                    'eventresizestart',

                /**
                 * @event eventpartialresize
                 * Fires during a resize operation and provides information about the current start and end of the resized event
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The event record being resized
                 * @param {Date} startDate The new start date of the event
                 * @param {Date} endDate The new end date of the event
                 * @param {Ext.Element} element The proxy element being resized
                 */
                    'eventpartialresize',

                /**
                 * @event beforeeventresizefinalize
                 * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
                 * be done immediately, giving you a chance to show a confirmation popup before applying the new values.
                 * To finalize the operation, call the 'finalize' method available on the resizeContext object.
                 * @param {Mixed} view The scheduler view instance
                 * @param {Object} resizeContext An object containing 'eventRecord', 'start', 'end' and 'finalize' properties.
                 * @param {Ext.EventObject} e The event object
                 */
                    'beforeeventresizefinalize',

                /**
                 * @event eventresizeend
                 * Fires after a succesful resize operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The updated event record
                 */
                    'eventresizeend',
                    // Resizing events end --------------------------

                    // Dnd events start --------------------------
                /**
                 * @event beforeeventdrag
                 * Fires before a dnd operation is initiated, return false to cancel it
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} record The record corresponding to the node that's about to be dragged
                 * @param {Ext.EventObject} e The event object
                 */
                    'beforeeventdrag',

                /**
                 * @event eventdragstart
                 * Fires when a dnd operation starts
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event[]} records An array with the records being dragged
                 */
                    'eventdragstart',

                /**
                 * @event eventdrag
                 * Fires when an event is dragged onto a new resource or time slot
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event[]} records An array with the records being dragged
                 * @param {Date} date The new start date of the main event record
                 * @param {Sch.model.Resource} resource The new resource for the main event record
                 * @param {Object} dragData A custom drag drop context object
                 */
                    'eventdrag',

                /**
                 * @event beforeeventdropfinalize
                 * Fires before a succesful drop operation is finalized. Return false to finalize the drop at a later time.
                 * To finalize the operation, call the 'finalize' method available on the context object. Pass `true` to it to accept drop or false if you want to cancel it
                 * NOTE: you should **always** call `finalize` method whether or not drop operation has been canceled
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Object} dragContext An object containing 'eventRecord', 'start', 'end', 'newResource', 'finalize' properties.
                 * @param {Ext.EventObject} e The event object
                 */
                    'beforeeventdropfinalize',

                /**
                 * @event eventdrop
                 * Fires after a succesful drag-drop operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event[]} records the affected records (if copies were made, they were not inserted into the store)
                 * @param {Boolean} isCopy True if the records were copied instead of moved
                 */
                    'eventdrop',

                /**
                 * @event aftereventdrop
                 * Fires after a drag-drop operation, even when drop was performed on an invalid location
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 */
                    'aftereventdrop',
                    // Dnd events end --------------------------

                    // Drag create events start --------------------------
                /**
                 * @event beforedragcreate
                 * Fires before a drag starts, return false to stop the execution
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Resource} resource The resource record
                 * @param {Date} date The clicked date on the timeaxis
                 * @param {Ext.EventObject} e The event object
                 */
                    'beforedragcreate',

                /**
                 * @event dragcreatestart
                 * Fires before a drag starts
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Ext.Element} el The proxy element
                 */
                    'dragcreatestart',

                /**
                 * @event beforedragcreatefinalize
                 * Fires before a succesful resize operation is finalized. Return false from a listener function to prevent the finalizing to
                 * be done immediately, giving you a chance to show a confirmation popup before applying the new values.
                 * To finalize the operation, call the 'finalize' method available on the createContext object.
                 * @param {Mixed} view The scheduler view instance
                 * @param {Object} createContext An object containing, 'start', 'end', 'resourceRecord' properties.
                 * @param {Ext.EventObject} e The event object
                 * @param {Ext.Element} el The proxy element
                 */
                    'beforedragcreatefinalize',

                /**
                 * @event dragcreateend
                 * Fires after a successful drag-create operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} newEventRecord The newly created event record (added to the store in onEventCreated method)
                 * @param {Sch.model.Resource} resource The resource record to which the event belongs
                 * @param {Ext.EventObject} e The event object
                 * @param {Ext.Element} el The proxy element
                 */
                    'dragcreateend',

                /**
                 * @event afterdragcreate
                 * Always fires after a drag-create operation
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Ext.Element} el The proxy element
                 */
                    'afterdragcreate',
                    // Drag create events end --------------------------

                /**
                 * @event beforeeventadd
                 * Fires after a successful drag-create operation, before the new event is added to the store. Return false to prevent the event from being added to the store.
                 * @param {Sch.view.SchedulerGridView} scheduler The scheduler view
                 * @param {Sch.model.Event} newEventRecord The newly created event record
                 */
                    'beforeeventadd'
                ]);

                // enable our row height injection if the default extjs row height synching mechanism is disabled
                // (it is disabled by default in our Lockable mixin, because it's slow)
                if (!this.syncRowHeight) this.enableRowHeightInjection(lockedView, normalView);


            },

            applyViewSettings: function (preset, initial) {
                this.callParent(arguments);

                var schedulingView = this.getSchedulingView(),
                    height;

                initial = initial || !this.rendered;

                if (this.orientation === 'vertical') {
                    // timeColumnWidth is used for row height in vertical mode
                    height = preset.timeColumnWidth || 60;
                    schedulingView.setColumnWidth(preset.resourceColumnWidth || 100, true);
                    schedulingView.setRowHeight(height, true);
                }
            },

            afterRender : function (){
                this.callParent(arguments);

                 if (this.mode === 'calendar') {
                    this.mon(this.timeAxis, this.calendarListeners);
                    this.normalGrid.on(this.calendarViewListeners);
                }

                this.getSchedulingView().on({
                    // Performance enhancements
                    eventdragstart      : this.doSuspendLayouts,
                    aftereventdrop      : this.doResumeLayouts,

                    eventresizestart    : this.doSuspendLayouts,
                    eventresizeend      : this.doResumeLayouts,
                    // EOF Performance enhancements

                    scope               : this
                });

                if (this.lockedGridDependsOnSchedule) {
                    this.normalGrid.getView().on('itemupdate', this.onNormalViewItemUpdate, this);
                }

                this.relayEvents(this.getEventSelectionModel(), [
                    /**
                     * @event eventselectionchange
                     * Fired after a selection change has occurred
                     * @param {Sch.selection.EventModel} this
                     * @param {Sch.model.Event[]} selected The selected events
                     */
                    'selectionchange',

                    /**
                     * @event eventdeselect
                     * Fired after a record is deselected
                     * @param {Sch.selection.EventModel} this
                     * @param  {Sch.model.Event} record The deselected event
                     */
                    'deselect',

                    /**
                     * @event eventselect
                     * Fired after a record is selected
                     * @param {Sch.selection.EventModel} this
                     * @param  {Sch.model.Event} record The selected event
                     */
                    'select'
                ], 'event');
            },

            getTimeSpanDefiningStore : function () {
                return this.eventStore;
            }
        };
    },

    doSuspendLayouts : function() {
        // if infinite scroll is set we want to resume layouts for short timespan when scheduler is being refreshed
        var s = this.getSchedulingView();

        s.infiniteScroll && s.timeAxis.on({
            beginreconfigure    : this.onBeginReconfigure,
            endreconfigure      : this.onEndReconfigure,
            scope               : this
        });

        this.lockedGrid.suspendLayouts();
        this.normalGrid.suspendLayouts();
    },

    doResumeLayouts : function() {
        var s = this.getSchedulingView();

        s.infiniteScroll && s.timeAxis.un({
            beginreconfigure    : this.onBeginReconfigure,
            endreconfigure      : this.onEndReconfigure,
            scope               : this
        });

        this.lockedGrid.resumeLayouts();
        this.normalGrid.resumeLayouts();
    },

    onBeginReconfigure : function() {
        this.normalGrid.resumeLayouts();
    },

    onEndReconfigure : function() {
        this.normalGrid.suspendLayouts();
    },

    onColWidthChange : function (timeAxisViewModel, width) {
        switch (this.getMode()) {
            case 'vertical'     :
                this.resourceColumnWidth = width;
                this.refreshResourceColumns();
                break;
            case 'calendar'     :
                this.calendarColumnWidth = width;
                this.refreshCalendarColumns();
                break;
        }
    },

    enableRowHeightInjection : function (lockedView, schedulingView) {
        var me = this;

        var cellTpl = new Ext.XTemplate(
            '{%',
                'this.processCellValues(values);',
                'this.nextTpl.applyOut(values, out, parent);',
            '%}',
            {
                priority          : 1,
                processCellValues : function (cellValues) {
                    if (schedulingView.mode === 'horizontal') {
                        var nbrBands        = 1;

                        if (schedulingView.dynamicRowHeight) {
                            var resource        = cellValues.record;
                            var layout          = schedulingView.eventLayout.horizontal;

                            nbrBands            = layout.getNumberOfBands(resource, function() {
                                return schedulingView.eventStore.filterEventsForResource(resource, schedulingView.timeAxis.isRangeInAxis, schedulingView.timeAxis);
                            });
                        }

                        var rowHeight       = (nbrBands * me.getRowHeight()) - ((nbrBands - 1) * schedulingView.barMargin) - schedulingView.cellTopBorderWidth - schedulingView.cellBottomBorderWidth;

                        cellValues.style    = (cellValues.style || '') + ';height:' + rowHeight + 'px;';
                    }
                }
            }
        );

        lockedView.addCellTpl(cellTpl);

        // this is a workaround, to force ExtJS grid to use "long" rendering path when doing cell updates
        // which involves the cell templates (which we had overrode)
        // w/o it, grid may use "fast" path and only update the cell content, leaving the row height unsynchronized
        Ext.Array.forEach(lockedView.getColumnManager().getColumns(), function (column) {
            column.hasCustomRenderer    = true;
        });

        // on the `refresh` event from the store, we want the normal view to be refreshed first,
        // because refreshing it will also cache the events layout data. After that, the locked view will just reuse the
        // cached data, otherwise the layout data would be calculated twice
        lockedView.store.un('refresh', lockedView.onDataRefresh, lockedView);
        lockedView.store.on('refresh', lockedView.onDataRefresh, lockedView);

        lockedView.on('destroy', function() {
            lockedView.store.un('refresh', lockedView.onDataRefresh, lockedView);
        });
    },


    /**
     * Returns the selection model being used, and creates it via the configuration
     * if it has not been created already.
     * @return {Sch.selection.EventModel} selModel
     */
    getEventSelectionModel : function () {
        return this.getSchedulingView().getEventSelectionModel();
    },

    refreshResourceColumns : function () {
        var w = this.resourceColumnWidth || this.timeAxisViewModel.resourceColumnWidth;

        this.normalGrid.reconfigure(null, this.createResourceColumns(w));
    },

    onCalendarColumnResize    : function (headerCt, column, width) {
        // Columns for calendar view are not resizable and configured to fill all available space (like forceFit)
        // After panel is resized 'columnresize' is fired for each column containing same 'width' value
        // and the simpliest way to refresh events is to render them per column.
        // Also have to save new column width to view model
        this.timeAxisViewModel.setViewColumnWidth(width, true);

        var calendarView = this.getSchedulingView().calendar;
        calendarView.repaintEventsForColumn(column, column.getIndex());
    },

    refreshCalendarColumns : function () {
        var rows    = this.createCalendarRows();
        var columns = this.createCalendarColumns();

        this.reconfigure(rows, this.calendarColumns.concat(columns));
    },

    /**
     * Switches the orientation of this panel
     * @param {String} orientation Either "horizontal" or "vertical"
     * @deprecated
     */
    setOrientation  : function () {
        this.setMode.apply(this, arguments);
    },

    /**
     * Switches the mode of this panel
     * @param {String} mode Either "horizontal", "vertical" or "calendar"
     */
    setMode : function (mode, force) {
        // This could be called too early during initComponent phase (by responsive mechanism in Ext JS)
        if (!this.normalGrid) {
            this.on('afterrender', function() {
                this.setMode(mode, true);
            });

            return;
        }

        if (mode === this.mode && !force) {
            return;
        }

        // calendar and vertical modes are similar, but we have to recognize them individually
        // in order to do that we consider sch-vertical as a main CSS for both,
        // sch-calendar for calendar and sch-vertical-resource for vertical
        switch (mode) {
            case 'horizontal'   :
                this.addCls('sch-horizontal');
                this.removeCls(['sch-vertical', 'sch-calendar', 'sch-vertical-resource']);
                break;
            case 'vertical'     :
                this.addCls(['sch-vertical-resource', 'sch-vertical']);
                this.removeCls(['sch-calendar', 'sch-horizontal']);
                break;
            case 'calendar'     :
                this.addCls(['sch-calendar', 'sch-vertical']);
                this.removeCls(['sch-vertical-resource', 'sch-horizontal']);
                break;
        }

        this.mode = mode;

        var me              = this,
            preventer       = function () { return false;},
            normalGrid      = me.normalGrid,
            lockedView      = me.lockedGrid.getView(),
            schedulingView  = me.getSchedulingView(),
            normalHeaderCt  = normalGrid.headerCt;

        lockedView.on('beforerefresh', preventer);
        schedulingView.on('beforerefresh', preventer);

        schedulingView.blockRefresh = lockedView.blockRefresh = true;
        schedulingView.setMode(mode);

        Ext.suspendLayouts();
        normalHeaderCt.removeAll(true);
        Ext.resumeLayouts();

        // activate required manager
        if (mode !== 'calendar') {
            me.timeAxis.setMode('plain');

            // remove listeners to avoid refreshing calendar columns using wrong presets
            me.mun(me.timeAxis, me.calendarListeners);

            if (me._oldViewPreset) {
                me.setViewPreset.apply(me, me._oldViewPreset);
                delete me._oldViewPreset;
            }
        } else {
            me._oldViewPreset    = [me.viewPreset, me.timeAxis.getStart(), me.timeAxis.getEnd()];

            me.timeAxis.setMode('calendar');

            me.setViewPreset(me.calendarViewPreset);

            me.mon(me.timeAxis, me.calendarListeners);
        }


        if (mode === 'horizontal') {
            me.mun(me.resourceStore, me.verticalListeners);
            me.normalGrid.un(me.calendarViewListeners);

            schedulingView.setRowHeight(me.rowHeight || me.timeAxisViewModel.rowHeightHorizontal, true);
            me.reconfigure(me.resourceStore, me.horizontalColumns);

            if (this.horizontalLockedWidth !== null) {
                this.lockedGrid.setWidth(this.horizontalLockedWidth);
            }

        } else if (mode === 'calendar') {
            // TODO: we want to save time span of the axis and restore it upon switching back
            me.mun(me.resourceStore, me.verticalListeners);
            me.normalGrid.on(me.calendarViewListeners);

            me.refreshCalendarColumns();

            schedulingView.setRowHeight(me.rowHeight || me.timeAxisViewModel.rowHeightVertical, true);
            schedulingView.setColumnWidth(me.timeAxisViewModel.calendarColumnWidth || 100, true);
        } else {
            me.normalGrid.un(me.calendarViewListeners);

            var lockedWidth = 0;
            this.horizontalLockedWidth = this.lockedGrid.getWidth();

            me.mon(me.resourceStore, me.verticalListeners);

            me.reconfigure(me.timeAxis, me.verticalColumns.concat(me.createResourceColumns(me.resourceColumnWidth || me.timeAxisViewModel.resourceColumnWidth)));

            Ext.Array.forEach(me.lockedGrid.query('gridcolumn'), function(col) { lockedWidth += col.rendered ? col.getWidth() : col.width || 100; });

            schedulingView.setColumnWidth(me.timeAxisViewModel.resourceColumnWidth || 100, true);

            me.lockedGrid.setWidth(lockedWidth);
        }

        lockedView.un('beforerefresh', preventer);
        schedulingView.un('beforerefresh', preventer);
        schedulingView.blockRefresh = lockedView.blockRefresh = false;

        me.getView().refresh();

        this.fireEvent('modechange', this, mode);
        this.fireEvent('orientationchange', this, mode);
    },

    createCalendarRows    : function () {
        var me      = this;
        var rows    = me.timeAxis.getRowTicks();

        // we have to cache calerndar rows amount to use it in timeAxisViewModel calculations
        me.timeAxisViewModel.calendarRowsAmount = rows.length;

        return new Ext.data.Store({
            model   : 'Sch.model.TimeAxisTick',
            data    : rows
        });
    },

    createCalendarColumns : function () {
        var me              = this;
        var currentHeader   = me.timeAxis.headerConfig.middle;
        var columns         = [];

        me.timeAxis.forEachAuxInterval(currentHeader.splitUnit, null, function (start, end, i) {
            // we iterate not over generated ticks, but over split units which are used to build columns
            // so this method wouldn't return correct start/end dates in case startTime/endTime has changed
            start.setHours(this.startTime);
            end = new Date(start);
            end.setHours(this.endTime);

            var header = {
                xtype       : 'weekview-day',
                renderer    : me.mainRenderer,
                scope       : me,
                start       : start,
                end         : end
            };

            if (currentHeader.renderer) {
                header.text = currentHeader.renderer.call(currentHeader.scope || me, start, end, header, i, me.eventStore);
            } else {
                header.text = Ext.Date.format(start, currentHeader.dateFormat);
            }

            columns.push(header);
        });

        return columns;
    },

    /**
     * Sets the row height of the timeline panel
     * @param {Number} height The height to set
     * @param {Boolean} preventRefresh `true` to prevent view refresh
     */
    setRowHeight: function (height, preventRefresh) {
        // Prevent any side effects if the panel is not yet done initializing
        preventRefresh = preventRefresh || !this.lockedGrid;

        this.timeAxisViewModel.setViewRowHeight(height, preventRefresh);
    },

    onNormalViewItemUpdate : function (record, index, oldRowEl) {
        if (this.lockedGridDependsOnSchedule) {
            var lockedView = this.lockedGrid.getView();

            lockedView.suspendEvents();
            // we cannot trust 'index' argument it may be wrong in case of grouping feature enabled
            lockedView.refreshNode(lockedView.indexOf(record));
            lockedView.resumeEvents();
        }
    }
});


// !XXX when adding new methods to this mixing need to also update the
// `setupLockableTree` method in the Sch.mixin.Lockable
Ext.define("Sch.mixin.FilterableTreeView", {

    prevBlockRefresh        : null,


    initTreeFiltering : function () {
        var doInit  = function () {
            var treeStore       = this.store;

            this.mon(treeStore, 'nodestore-datachange-start', this.onFilterChangeStart, this);
            this.mon(treeStore, 'nodestore-datachange-end', this.onFilterChangeEnd, this);

            if (!treeStore.allowExpandCollapseWhileFiltered) {
                this.mon(treeStore, 'filter-clear', this.onFilterCleared, this);
                this.mon(treeStore, 'filter-set', this.onFilterSet, this);
            }
        };

        if (this.rendered)
            doInit.call(this);
        else
            this.on('beforerender', doInit, this, { single : true });
    },


    onFilterChangeStart : function () {
        this.prevBlockRefresh   = this.blockRefresh;

        // block refresh in filterable tree view, for the cases when this mixin is consumed by non-tree views
        // "blockRefresh" is already true in all tree views, so in the Sch.data.mixin.FilterableTreeStore
        // we use "nodeStore.fireEvent('clear', nodeStore);" hack, which is directly tied to "refresh" method of the view
        // in case when non-tree view consumes this mixin, we need to temporarily block the refresh manually,
        // to avoid double refresh
        this.blockRefresh       = true;

        Ext.suspendLayouts();
    },


    onFilterChangeEnd : function () {
        Ext.resumeLayouts(true);

        this.blockRefresh       = this.prevBlockRefresh;
    },


    onFilterCleared : function () {
        delete this.toggle;

        var el          = this.getEl();

        if (el) el.removeCls('sch-tree-filtered');
    },


    onFilterSet : function () {
        this.toggle     = function () {};

        var el          = this.getEl();

        if (el) el.addCls('sch-tree-filtered');
    }
});

/**

@class Sch.panel.TimelineGridPanel
@extends Ext.grid.Panel
@mixin Sch.mixin.TimelinePanel

Internal class. 

*/
Ext.define("Sch.panel.TimelineGridPanel", {
    extend  : "Ext.grid.Panel",
    mixins  : [
        'Sch.mixin.Localizable',
        'Sch.mixin.TimelinePanel'
    ],
    subGridXType            : 'gridpanel',

    initComponent : function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function() {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});
/**

 @class Sch.panel.TimelineTreePanel
 @extends Ext.tree.Panel
 @mixin Sch.mixin.TimelinePanel

 Internal class.

 */
if (!Ext.ClassManager.get("Sch.panel.TimelineTreePanel")) {

Ext.define("Sch.panel.TimelineTreePanel", {
    extend   : "Ext.tree.Panel",
    requires : [
        // need to require grid panel too here, because one of the sub-grids will be a normal grid
        'Ext.grid.Panel',
        'Ext.data.TreeStore',
        // will be used in the `setupLockableTree` of lockable mixin
        'Sch.mixin.FilterableTreeView',

        'Sch.patches.ColumnResizeTree'
    ],
    mixins   : [
        'Sch.mixin.Localizable',
        'Sch.mixin.TimelinePanel'
    ],

    useArrows   : true,
    rootVisible : false,
    lockedXType : 'treepanel',

    initComponent : function () {
        this.callParent(arguments);
        this.getSchedulingView()._initializeTimelineView();
    }
}, function () {
    this.override(Sch.mixin.TimelinePanel.prototype.inheritables() || {});
});

}

/** 

@class Sch.panel.SchedulerGrid
@extends Sch.panel.TimelineGridPanel
@mixin Sch.mixin.SchedulerPanel

@alternateClassName Sch.SchedulerPanel

A scheduler panel based on the {@link Ext.grid.Panel} class which allows you to visualize and manage "resources" and their scheduled "events".

Please refer to the <a href="#!/guide/scheduler_getting_started">getting started guide</a> for a detailed introduction.

{@img scheduler/images/ext-scheduler.png}

*/
Ext.define("Sch.panel.SchedulerGrid", {
    extend                  : "Sch.panel.TimelineGridPanel",
    mixins                  : [ 
        'Sch.mixin.SchedulerPanel'
    ],
    alias                   : [ 'widget.schedulergrid', 'widget.schedulerpanel'],
    alternateClassName      : 'Sch.SchedulerPanel',
    viewType                : 'schedulergridview',

    initComponent : function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeSchedulerView();
    }

}, function() {
    this.override(Sch.mixin.SchedulerPanel.prototype.inheritables() || {});
});
/** 

@class Sch.panel.SchedulerTree
@extends Sch.panel.TimelineTreePanel
@mixin Sch.mixin.SchedulerPanel

A complete scheduler panel using a tree view. This class can be used when you have a lot of resources organized in a hierarchical structure.

{@img scheduler/images/scheduler-tree.png}

Please refer to the {@link Sch.panel.SchedulerGrid} for additional documentation, as these classes
are virtually identical. This document will only provide the tree-specific details.

In the scheduler tree case:

- the `resourceStore` is expected to be an instance of the {@link Sch.data.ResourceTreeStore}.
- the scheduler tree does not support vertical orientation.
- in your columns definition, you must include a column which will contain the tree itself (the `treecolumn` xtype):

        var schedulerTree = Ext.create('Sch.panel.SchedulerTree', {
            columns: [
                {
                    xtype       : 'treecolumn',
                    
                    text        : 'Name',
                    width       : 200,
                    sortable    : true,
                    dataIndex   : 'Name'
                }
            ]
        });


*/
Ext.define("Sch.panel.SchedulerTree", {
    extend      : "Sch.panel.TimelineTreePanel",
    mixins      : ['Sch.mixin.SchedulerPanel'], 
    alias       : [ 'widget.schedulertree'],
    viewType    : 'schedulergridview',
    
    setOrientation : function () {
        return this.setMode.apply(this, arguments);
    },

    setMode : function (mode) {
        if (mode !== 'horizontal') {
            Ext.Error.raise("Sch.panel.SchedulerTree only support horizontal mode");
        }
    },

    initComponent : function() {
        this.callParent(arguments);
        this.getSchedulingView()._initializeSchedulerView();
    }
}, function() {
    this.override(Sch.mixin.SchedulerPanel.prototype.inheritables() || {});
});
/**
@class Sch.widget.PagingToolbar

This class is a specialized paging toolbar that is aware of CRUD manager functionality.
The class uses a CRUD manager data loading if the store is included to CRUD collection.
This Component loads blocks of data into the store by passing parameters used for paging criteria.

        var crudManager     = Ext.create('Sch.data.CrudManager', {
            resourceStore   : resourceStore,
            eventStore      : eventStore
        });

        Ext.create('Sch.panel.SchedulerGrid', {
            eventBarTextField   : 'Name',
            viewPreset          : 'dayAndWeek',
            startDate           : new Date(2012, 8, 10),
            endDate             : new Date(2012, 10, 10),
            width               : 800,
            height              : 350,

            crudManager         : crudManager,

            //define bottom bar with pagination toolbar
            bbar                : {
                xtype           : 'sch_pagingtoolbar',
                store           : resourceStore,
                displayInfo     : true,
                displayMsg      : 'Displaying resources {0} - {1} of {2}',
                emptyMsg        : "No resources to display"
            }
        });

*/
Ext.define('Sch.widget.PagingToolbar', {
    extend  : 'Ext.toolbar.Paging',
    alias   : 'widget.sch_pagingtoolbar',

    getStoreId : function () {
        if (this.storeId) return this.storeId;

        var storeId     = this.store.storeId;

        if (!storeId) {
            var crudManager = this.store.crudManager;
            var store       = crudManager && crudManager.getStore(this.store);

            storeId         = store && store.storeId;
        }

        this.storeId    = storeId;

        return storeId;
    },

    loadPage : function (pageNum) {
        var me = this;

        if (me.store.crudManager) {
            var storeId     = me.getStoreId();

            if (storeId) {
                var params          = {};

                params[storeId]     = {
                    pageSize    : me.store.pageSize,
                    page        : pageNum
                };

                me.store.crudManager.load(params);
            }
        } else {
            me.store.loadPage(pageNum);
        }
    },

    // @OVERRIDE
    // @private
    onPagingKeyDown : function(field, e) {
        var me = this,
            k = e.getKey(),
            pageData = me.getPageData(),
            increment = e.shiftKey ? 10 : 1,
            pageNum;

        if (k == e.RETURN) {
            e.stopEvent();
            pageNum = me.readPageFromInput(pageData);
            if (pageNum !== false) {
                pageNum = Math.min(Math.max(1, pageNum), pageData.pageCount);
                if(me.fireEvent('beforechange', me, pageNum) !== false){
                    me.loadPage(pageNum);
                }
            }
        } else if (k == e.HOME || k == e.END) {
            e.stopEvent();
            pageNum = k == e.HOME ? 1 : pageData.pageCount;
            field.setValue(pageNum);
        } else if (k == e.UP || k == e.PAGE_UP || k == e.DOWN || k == e.PAGE_DOWN) {
            e.stopEvent();
            pageNum = me.readPageFromInput(pageData);
            if (pageNum) {
                if (k == e.DOWN || k == e.PAGE_DOWN) {
                    increment *= -1;
                }
                pageNum += increment;
                if (pageNum >= 1 && pageNum <= pageData.pageCount) {
                    field.setValue(pageNum);
                }
            }
        }
    },

    // @OVERRIDE
    /**
     * Move to the first page, has the same effect as clicking the 'first' button.
     */
    moveFirst : function(){
        if (this.fireEvent('beforechange', this, 1) !== false){
            this.loadPage(1);
        }
    },

    // @OVERRIDE
    /**
     * Move to the previous page, has the same effect as clicking the 'previous' button.
     */
    movePrevious : function(){
        var me = this,
            prev = me.store.currentPage - 1;

        if (prev > 0) {
            if (me.fireEvent('beforechange', me, prev) !== false) {
                me.loadPage(prev);
            }
        }
    },

    // @OVERRIDE
    /**
     * Move to the next page, has the same effect as clicking the 'next' button.
     */
    moveNext : function(){
        var me = this,
            total = me.getPageData().pageCount,
            next = me.store.currentPage + 1;

        if (next <= total) {
            if (me.fireEvent('beforechange', me, next) !== false) {
                me.loadPage(next);
            }
        }
    },

    // @OVERRIDE
    /**
     * Move to the last page, has the same effect as clicking the 'last' button.
     */
    moveLast : function(){
        var me = this,
            last = me.getPageData().pageCount;

        if (me.fireEvent('beforechange', me, last) !== false) {
            me.loadPage(last);
        }
    },

    // @OVERRIDE
    /**
     * Refresh the current page, has the same effect as clicking the 'refresh' button.
     */
    doRefresh : function(){
        var me = this,
            current = me.store.currentPage;

        if (me.fireEvent('beforechange', me, current) !== false) {
            me.loadPage(current);
        }
    }
});

